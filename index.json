[{"categories":["数据库"],"content":"多表连接的原理是什么？on 和 and 条件有什么不同？","date":"2022/05/09","objectID":"/posts/sql%E4%BC%98%E5%8C%963-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/","tags":["mysql优化"],"title":"sql优化(3)-表连接原理","uri":"/posts/sql%E4%BC%98%E5%8C%963-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"sql优化(3)-表连接原理 ","date":"2022/05/09","objectID":"/posts/sql%E4%BC%98%E5%8C%963-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/:1:0","tags":["mysql优化"],"title":"sql优化(3)-表连接原理","uri":"/posts/sql%E4%BC%98%E5%8C%963-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"表连接介绍 为了比较好地理解，先创建一张学生信息表和学生成绩表作为例子： CREATETABLEstudent(stu_noINTNOTNULLcomment'学号',stu_nameVARCHAR(5)COMMENT'姓名',stu_majorVARCHAR(5)COMMENT'专业',PRIMARYKEY(stu_no)）COMMENT'学生信息表';CREATETABLEscore(stu_noINTcomment'学号',subjectVARCHAR(30)comment'科目',scoreINTcomment'成绩',PRIMARYKEY(stu_no,subject))COMMENT'学生成绩表'; 向这两个表中插入一些数据。 对于表连接，SQL语法上可以连接任意数量的表。但是如果不附加任何限制条件，这些表连接产生的笛卡儿积可能是非常巨大的。比如 100 行记录的表连接起来产生的笛卡儿积就有 100 X 100 X 100 = 1 000 000 行记录。所以在表连接时过滤掉特定的记录组合是有必要的。 例如下面这个查询： ---查询除王五之外的学生成绩及格的信息select*fromstudent,scorewherestudent.name!='王五'andstudent.stu_no=score.stu_noandscore.score\u003e60 在连接查询中的过滤条件可以分成下面两种： 涉及单表的条件: 比如 student.name!=‘王五’ 和 score.score\u003e60 涉及两表的条件：比如 student.stu_no=score.stu_no 这个连接查询的执行过程大致如下： **步骤1：**首先确定第一个需要查询的表，这个表称为驱动表。假设驱动表是 学生表 student ,对于 学生表 student 的单表筛选条件就是 student.name!=‘王五’ 。单表访问方法有很多，这里因为数据量太少，直接全表扫描，即扫描方法为 all。 **步骤2：**步骤1中从驱动表每获取到一条记录，都需要到成绩表 score 中查找匹配的记录。匹配的记录，指的是符合过滤条件的记录。因为是根据 student 表中的记录去找 score 表中的记录，所以 score 表也可以称为被驱动表。步骤1从驱动表中得到了 2条记录，也就意味着需要查询2次socre表。 ​ 当从student表查询到的第一条记录，也就是当 name!=‘王五’ ，过滤条件 student.stu_no=score.stu_no 相当于 score.stu_no=‘20180101’ ，score表相当于有了 stu_no=‘20180101’ 和 score\u003e60 这两个过滤条件，然后到score表执行单表查询。 ​ 当从student表查询到的第二条记录，也就是当 name!=‘王五’ ，过滤条件 student.stu_no=score.stu_no 相当于 score.stu_no=‘20180102’ ，score表相当于有了 stu_no=‘20180102’ 和 score\u003e60 这两个过滤条件，然后到score表执行单表查询。 最终获取的查询结果就是： 王五同学（也就是学号为20180103的同学）因为某些原因没有参加考试，所以在成绩表中没有对应的成绩记录。如果老师想查看所有学生的考试成绩，即使是缺考的学生，他们的成绩也应该展示出来。 这个需求的本质是这样的：针对驱动表中的某条记录，即使在被驱动表中没有找到与之匹配的记录，也仍然需要把该驱动表记录加入到结果集。为了解决这个问题，就有了内连接和外连接的概念。 对于内连接的两个表，若驱动表中的记录在被驱动表找不到匹配的记录，则该记录不会加入到最后的结果集 对于外连接的两个表，即使驱动表中的记录在被驱动表中没有匹配的记录，也仍然需要加入到结果集 MySQL 中，根据选取的驱动表的不同 ，外连接可以细分为 ： 左外连接：选取左侧的表为驱动表 ( A left join B A为左侧) 右外连接：选取右侧的表为驱动表 ( A right join B B为右侧) 对于外连接来说，有时候不想把驱动表的全部记录都加入到最后的结果集。 为了解决这个问题，过滤条件在不同的地方是有不同的语义的。 WHERE 子句中的过滤条件 WHERE子句中的过滤条件，不论是内连接还是外连接，凡是不符合WHERE 子句中过滤条件的记录都不会被加入到最后的结果集 。 ON 子句中的过滤条件 对于外连接的驱动表中的记录来说，如果无法在被驱动表中找到匹配 ON子句中过滤条件的记录，那么该驱动表记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充 需要注意 ，这个 ON 子句是专门为\"外连接驱动表中的记录在被驱动表找不到匹配记录时是否应该把该驱动表记录加入结果集中\"这个场景提出的。所以，如果把 ON 子句放到内连接中，MySQL 会把它像 WHERE 子句一样对待。 也就是说内连接中的 WHERE 子句和 ON 子句是等价的 ","date":"2022/05/09","objectID":"/posts/sql%E4%BC%98%E5%8C%963-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/:1:1","tags":["mysql优化"],"title":"sql优化(3)-表连接原理","uri":"/posts/sql%E4%BC%98%E5%8C%963-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"连接的原理 嵌套循环连接 对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问好多遍; 具体访问几遍取决于对驱动表执行单表查询后的结果集中有多少条记录。对于内连接来说，选取哪个表为驱动表都没关系；而外连接的驱动表是固定的，也就是说左(外)连接的驱动表就是左边的那个表，右(外)连接的驱动表就是右边的那个表。前面已经介绍过表连接查询的大致过程： 步骤1：选取驱动衰，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询 步骤2：对步骤1 中查询驱动表得到的结果集中的每一条记录，都分别到被驱动表中查找匹配的记录 (也是选择代价最低的单表访问方法) 如果有3个表进行连接，那么步骤2中得到的结果集就像是新的驱动表，然后第3个表就成为了被驱动表，然后重复上面的过程。也就是针对步骤 2中得到的结果集中的每一条记录，都需要~到第3个表中找一找有没有匹配的记录。 ---伪代码 for each row in t1 satisfying conditions about tl { for each rQW in t2 satisfying cond tions about t2 { for each row in t3 satisfying conditions about t3 { send to client; } } } 这个过程就像是一个嵌套的循环，所以这种\" 驱动表只访问1次，但被驱动表却可能访问多次，且访问次数取决于对驱动表执行单表查询后的结果集中有多少条记录\"的连接执行方式 称为嵌套循环连接（Nested-Loop Join) ，这是最简单也是最笨拙的一种连接查询算法。 需要注意的是,对于嵌套循环连接算法来说，每当从驱动表中得到了一条记录时，就根据这条记录立时到被驱动表中查询一次。如果得到了匹配的记录， 就把组合后的记录发送给客户端。然后再到驱动表中获取下一条记录；这个过程将重复进行。不是把驱动表中所有的记录都先查出来放到某个地方(比如内存或者磁盘中) ，然后再遍历这些记录。 另外对于全套循环连接，本质上也是嵌套的单表查询，所以可以利用索引进行查询优化，这里就是在单表方法方法中有详细说明 基于块的嵌套循环连接 现实中的表数据量一般比较大，几百万、几千万甚至几亿条记录的表到处都是。假设不能使用索引加快被驱动表的查询过程，所以对于驱动表结果集中的每一条记录， 需要对被驱动表执行全表扫描。这样在对被驱动表进行全表扫描时，可能表前面的记录还在内存中，而表后面的记录还在磁盘上。而等到扫描表中后面的记录时，有可能由于内存不足，需要把表前面的记录从内存中释放掉，给现在正在扫描的记录腾地方。在采用嵌套循环连接算法的两表连接过程中，被驱动表可是要被访问好多次。如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读这个表好多次，这个 磁盘I/O 的代价就非常大了.所以得想办法，尽量减少被驱动表的访问次数。 驱动表结果集中有多少条记录，就可能把被驱动表从磁盘加载到内存中多少次。是否可以在把被驱动表中的记录加载到内存时，一次性地与驱动表中的多条记录进行匹配呢？这样就可以大大减少重复从磁盘上加载被驱动表的代价了 。MySQL 中有一个名为 Join Buffer (连接缓冲区）的概念。 Join Buffer 就是在执行连接查询前申请的一块固定大小的内存。先把若干条驱动表结果集中的记录装在这个 Join Buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性地与 Join Buffer 中的多条驱动表记录进行匹配。由于匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的磁盘I/O 代价。 最好的情况是 Join Buffer 够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了把这加入了 Join Buffe 的嵌套循环连接算法称为基于块的嵌套循环连接 (Block Nested-Loop Join） 算法。 这个 Join Buffer 的大小可以通过启动选项或者系统变量 join_buffe _size 进行配置, 默认大小为 262144 字节(也就是 255KB) ，最小可以设置为128 字节.当然，在优化对被驱动表的查询时，最好是为被驱动表加上高效率的索引。如果实在不能使用索引，并且自己机器的内存也比较大 ，则可以尝试调大 join_buffer_size 的值来对连接查询进行优化。 另外需要注意的是， Join Buffer 中并不会存放驱动表记录的所有列，只有查询列表中的列和过滤条件中的列才会被放到 Join Buffer 中，所以最好不要把*作为查询列表，只需要把真正想要查询的列放到查询列表，这样可以 Join Buffer 中放置更多的记录 参考：MySql 是怎样运行的_从根上理解Mysql ","date":"2022/05/09","objectID":"/posts/sql%E4%BC%98%E5%8C%963-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/:1:2","tags":["mysql优化"],"title":"sql优化(3)-表连接原理","uri":"/posts/sql%E4%BC%98%E5%8C%963-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"访问单表有哪些方法？","date":"2022/05/08","objectID":"/posts/sql%E4%BC%98%E5%8C%962-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/","tags":["mysql优化"],"title":"sql优化(2)-单表访问方法","uri":"/posts/sql%E4%BC%98%E5%8C%962-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/"},{"categories":["数据库"],"content":"单表访问方法 MySQL 是怎么执行单表查询的(就是 FROM 子句后面只有一个表)。一般对sql的性能查询可以用explian+要查询的sql语句。对于type属性就是表的访问方法。 什么是访问方法 类比使用各种地图 App 来查找到某个地方的路线， 如果搜索从北京西站到北京站的路线，地图 App 会给出多种路线供选择，其中的花费的钱和时间都不相同，无论采用哪一种路线，最终的目标都是从北京西站到北京站。我们平时所写的那些查询语句本质上只是一种声明式的语法，只是告诉 MySQL 要获取的数据符合哪些规则 ，至于 MySQL 是如何把查询结果搞出来的则是 MySQL 内部解决的事情。 **把 MySQL 执行查询语句的方式称为访问方法（access method ）或者访问类型 。**同一个查询语句可以使用多种不同的访问方法来执行，虽然最后的查询结果都是一样的，但是不同的执行方式花费的时间成本可能差距甚大。就像是从北京西站到北京站，可以坐公交车去，还可以骑共享单车去，当然也可以走着去。 使用单索引的访问方法 先展开说访问方法之前，先用创建一张举例用的demo表 CREATETABLEtable_demo(idINTNOTNULLAUTO_INCREMENT,keylVARCHAR(lOO),key2INT,key3VARCHAR(100),key_partlVARCHAR(100),key_part2VARCHAR(10Q),key_part3VARCHAR(100),common_fieldVλRCHAR(lOO),PRIMARYKEY(id),KEYidx_keyl(keyl),UNIQUEKEYuk_key2(key2),keyidx_key3(key3),KEYidx_part(key_partl,key_part2,keY_part3)) 为这个 table_demo 表建立1个聚簇索引4个二级索引，分别是： 为 id 列建立的聚簇索引; 为 key1 列建立的 idx_key1 二级索引 为 key2 列建立的 uk_key2 唯一索引 为 key3 列建立的 idx_key3 二级索引 为key_part1、key_part2、 key_part3列建立联合索引 假设往这个表插入10万条随机数据。然后进行下面这些查询操作： const 查询1： select*fromtable_demowherekey2=1438; 这个查询的执行可以分为下面两步： 使用唯一索引 uk_key2, 在索引对应的 B+ 树索引中，根据 key2列与常数的等值比较条件定位到一条二级索引记录(二级索引会记录包含 key2值和 对应的主键id值 ) 然后再根据该记录的 id 值到聚簇索引（即主键索引）中获取到完整的用户记录 这种通过主键或者唯一索引列与常数的等值比较来定位条记录是特别快的，所以把这种通过主键或者非空唯一索号列来定位一条记录的访问方法定义为 const (意思是常数级别的，代价是可以忽略不计的) 。不过这种 const 访问方法只能在主键列或者唯一二级索引列与一个常数进行等值比较时才有效，如果主键或者唯一二索引的索引列由多个列构成，则只有在索引列中的每个列都与常数进行等值比较时，这个const 访问方法才有效〈这是因为只有在该索引的每个列都采用等值比较时，才可以保证最多只有一条记录符合搜索条件)。 对于唯一二级索引列来说 在查询列为 NULL 值时，情况比较特殊。比如下面这样 select*fromtable_demowherekey2isnull; 因为唯一二级索引列并不限制 NUL 值的数量 所以上述语句可能访问到多条记录，也就是说上面这个语句不可以使用 const 访问方法来执行。 ref 查询2： select*fromtable_demowherekey1='abc'; 对于这个查询，当然可以选择全表扫描的方式来执行，不过也可以使用 idx_keyl 来执行，此时对应的扫描区间就是[ ‘abc’, ‘abc’] ，这是个单点扫描区间 我们可以定位到 keyl = ‘abc’ 条件的第一条记录，然后沿辑记录所在的单向链表向后扫描，直到某条记录不符合 key1 = ‘abc’ 条件为止。由于查询列表是 *，因此针对获取到的每 二级索引记录，都需要根据该记录的 id 值执行回表操作， 到聚簇索引中获取到完整的用户记录后再发送给客户端。 由于普通二级索引并不限制列值的唯一性，所以位于扫描区间 ‘abc’ 中的 级索引记录可能有多条， 此时使用二级索引执行查询的代价就取决于该扫描区间中的记录条数。如果该扫描区间中的记录较少 ，则回表操作的代价还是比较低的。把这种\"搜索条件为二级索引列与常数进行得值比较，形成的扫描区为单点扫描区间，采用二级索引来 执行查询\"的访问方法称为 ref 。 对于普通的二级索引来说 ，通过索引列进行等值比较后可能会匹配到多条连续的二级索引记录，而不是像主键或者唯一二级索引那样最多只能匹配一条记录.所以这种 ref 访问方法比 const 差了那么一点。 另外二级索引列允许存储 NULL 值时，无论是普通的二级索引 ，还是唯一二级索引 ，它们的索引列并不 限制NULL值的数量，所以在执行包 “key IS NULL” 形式的搜索条件的查询时，最多只能使用 ref 访问方法 而不能使用 const 访问方法。 对于联合索引，按照最左匹配原则，只要最左边连续的列与常数进行等值比较，就可以采用ref 访问方法。如key_part1、key_part2、 key_part3列建成联合索引： select*fromtable_demowherekey_part1='a';select*fromtable_demowherekey_part1='a'andkey_part2='b';select*fromtable_demowherekey_part1='a'andkey_part2='b'andkey_part3='c'; 如果索引列中最左边连续的列不全部是等值比较的话，它的访问方法就不能称为 ref 了。 ref_or_null 查询3： select*fromtable_demowherekey1='abc'orkey1isnull; 当查询3 使用二级索引而不是全表扫描的方式执行该查询时，对应的扫描区间就是 [NULL, NULL] 以及 [‘abc’ ‘abc’] 。像这样不仅需要找出某个二级索引列的值等于某个常数的记录，而且还需要把该列中值为 NULL 的记录也找出来的查询所使用的方法就叫 ref_or_null 。 可以看到 ref_or_null 访问方法只是比 ref 访问方法多扫描了一些值为 NULL 二级索引记录。 range 查询4： select*fromtable_demowherekey2in(1438,1567)or(key2\u003e1andkey2\u003c100) 在对索引列与某一个常数进府等值比较时，才会使用到前文介绍的几种访问方法 。面对更为复杂的搜索条件如查询2，如果使用uk_key2索引形成的所对应的扫描区间为(1,100)、[1438,1438]、[1567,567]。把\"使用索引执行查询时， 对应 扫描区间为若干个单点扫描区区 或者范围扫描区间\"的访问方法称为 range (仅包含一个单点扫描区间的 方法不能 称为 range 访问方法，扫描区间为(-∞，+∞)的访问方法也不能称为 range 访问方法)。 index 查询5： selectkey_part2,keY_part3fromtable_demowherekey_part2='abc' 对于查询5，如果使用联合索引idx_key_part ，因为key_part2不是联合索引idx_key_part 的索引列中最左边的列，所以无法通过联合索引形成合适的扫描区间来减少扫描记录数据，从而无法使用ref或者range访问方法来执行这个语句。但是这个查询恰好符合下面这两个条件： 它的查询列只有 key_part2, keY_part3 这2个列，而联合索引 idx_key_part 的索引值又包含这两个列 搜索条件中只有key_part2列，这个列也包含在索引idx_key_part中 也就是说，我们可以直接遍历 idx_key_part 索引的所有二级索引记录， 针对获取到每一条二级索引记录，都判断 key_part2 = ‘abc’ 条件是否成立。如果成立，就从中读取出 key_part2、key_part3 这2个列的值并将它们发送给客户端。很显然 在这种使用 idx_key_part 索引执行上述查询的情况下，对应 扫锚区间就是(-∞ +∞) 。 由于二级索引记录比聚簇索记录小得多(聚簇索引记录要存储用户定义的所有列以及隐藏列，而二级索引记录只需要存放索引列和主键) ，而且这个过程不用执行回表操作，所以直接扫描全部的二级索引记录比直接扫描全部的聚簇索引记录的成本要小很多。把这种扫描全部二级索引记录的访问方法称为 index 方法。 另外，当通过全表扫描对使用 lnnoDB 存储引擎的表执行查询时, 如果添加了 “ORDER BY 主键” 的语句，那么该语句在执行时也会被人为地认定未使用的是 index 访问方法 。 select*fromtable_demoorderbyid; all 最直接的查询行方式就是全表扫描 ，对于 InnoDB 表来说就是直接扫描全部的聚簇索引记录，把这种使用全表扫描执行查询的访问方法称为 all 访问方法。 使用","date":"2022/05/08","objectID":"/posts/sql%E4%BC%98%E5%8C%962-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/:0:1","tags":["mysql优化"],"title":"sql优化(2)-单表访问方法","uri":"/posts/sql%E4%BC%98%E5%8C%962-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/"},{"categories":["数据库"],"content":"如何判断一条sql的大致数据量？","date":"2022/04/29","objectID":"/posts/sql%E4%BC%98%E5%8C%961-%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4%E5%92%8C%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6/","tags":["mysql优化","扫描区间"],"title":"sql优化(1)-扫描区间和边界条件","uri":"/posts/sql%E4%BC%98%E5%8C%961-%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4%E5%92%8C%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6/"},{"categories":["数据库"],"content":"sql优化(1)-扫描区间和边界条件 对于某个查询来说，最简单粗暴的执行方案就是扫描表中的所有记录，判断每一条记录是否符合搜索条件。如果符合，就将其发送到客户，否则就跳过该记录。这种执行方案也称为全表扫描。对于使用 InnoD 存储引擎的表来说，全表扫描意味着从聚簇索引第一个叶子节点的第一条记录开始，沿着记录所在的单向链表向后扫描， 直到最后一个叶子节点的最后一条记录。虽然全表扫描是种很笨的执行方案，但却是一种万能的执行方案， 所有的查询都可以使用这种方案来执行。 还有更快的方法，利用 B+ 树查找索引列值等于某个值的记录，这样可以明显减少需要扫描的记录数量（索引本质是已经过排序的数据结构），只需要扫描某个区间或者某些区间中的记录也可以明显减少需要扫描的记录数量。 为方便理解，先建一个演示表 CREATETABLEtable_demo(idINTNOTNULLAUTO_INCREMENT,keylVARCHAR(lOO),key2INT,key3VARCHAR(100),key_partlVARCHAR(100),key_part2VARCHAR(10Q),key_part3VARCHAR(100),common_fieldVλRCHAR(lOO),PRIMARYKEY(id),KEYidx_keyl(keyl),UNIQUEKEYuk_key2(key2),keyidx_key3(key3),KEYidx_part(key_partl.key_part2,keY_part3)) 为这个 table_demo 表建立1个聚簇索引4个二级索引，分别是： 为 id 列建立的聚簇索引; 为 key1 列建立的 idx_key1 二级索引 为 key2 列建立的 uk_key2 唯一索引 为 key3 列建立的 idx_key3 二级索引 为key_part1、key_part2、 key_part3列建立联合索引 假设往这个表插入10万条随机数据。然后进行下面这些查询操作： 查询语句1： select*fromtable_demowhereid\u003e=2andid\u003c=100 这个语句其实是想查找 id 值在 [2,100] 区间中的所有聚簇索引记录。可以通过聚簇索引对应树快速地定位 id 值为 2的那条聚簇索引记录，然后沿着记录所在的单向链表向后扫描直到某条聚簇索引记录的 id 值不在 [2,100] 区间中为止 (即 id 值不再符合 id\u003c= 100 条件)。把这个例子中待扫描记录的 id 值所在的区间称为扫描区间，把形成这个扫描区间的搜索条件(也就是 id \u003e= 2 AND id \u003c=100) 称为形成这个扫描区间的边界条件。 其实对于全表扫描来说 相当于扫描 值在 (-∞，+∞ ) 区间中 记录，也就是说全农扫描对应的扫描区间是 (-∞，+∞ ) 查询语句2： select*fromtable_demowherekey2in(1438,6328)or(key2\u003e38andkey2\u003c79) 该查询的搜索条件涉及 key2 列， 又正好 key2 列建立了 uk_key2 索引 .如果使 uk_key2 索引执行这个查询，则相当于从下面的3个扫描区间获取二级索引记录。 [1438,6328]：对应的边界条件是 key in (1438) [6328,6328]：对应的边界条件是 key in (6328) (38,79)：对应的边界条件是 key\u003e38 and key\u003c79 方便起见，可以把像 [1438,1438]、[6328,6328] 这样只包含一个值的扫描区间称为单点扫描区间， [38,79] 这样包含多个值的拍描区间称为范围扫描区间。 查询语句3： select*fromtable_demowherekeyl\u003c' a 'ANOkey3\u003e'z' 如果使用 idx_key1 索引执行查询，那么相应的扫描区间就是 (-∞，‘a’ )， 形成该扫描区间的边界条件就是 key1 \u003c ‘a’， key3 \u003e ‘z’ 就是普通的搜索条件，这些普通的搜索条件需要在获取到 idx_key1二级索引记录后，再执行回表操作，在获取到完整的用户记录后才能去判断它们是否成立。 如果使用 idx_key3 索引执行查询，那么相应的扫描区间就是 (‘z’ , +∞ )， 形成该扫描区间的边界条件就是 key3 \u003e ‘z’， key1 \u003c ‘a’ 就是普通的搜索条件，这些普通的搜索条件需要在获取到 idx_key2二级索引记录后，再执行回表操作，在获取到完整的用户记录后才能去判断它们是否成立。 所以，对于查询语句3，无论选择哪个索引，都有一部分筛选条件不能成为边界条件。 一个查询语句中的 WHERE 子句可能有很多个小的搜索条件，这些搜索条件使用 AND 或者 OR 操作符连接起来。 条件1 AND 条件2 只有当 条件1 和 条件2 都为 TRUE 时，整个表达式才为 TRUE 条件1 OR 条件2 只要 条件1 或者 条件2 有一个为 TRUE，整个表达式就为 TRUE 在执行一个查询语句时，首先需要找出所有可用的索引以及使用它们时对应的扫描区间。 查询语句4： select*fromtable_demowherekey2\u003e100andkey2\u003e200;select*fromtable_demowherekey2\u003e100orkey2\u003e200; 对于 key2\u003e100 、key2\u003e200 可以用到索引uk_key2，对应的扫描区间是 (100, +∞ )、（200，+∞）。and 就是把两个扫描区间取交集，即(200,+∞)；or就是把两个扫描区间取并集，即(100,+∞ )，这个就比较好理解。 查询语句5： select*fromtable_demowherekey2\u003e100andkey1\u003e'c';select*fromtable_demowherekey2\u003e100orkey1\u003e'c'; 对于这个两个查询，如果使用uk_key2 索引的话，key2\u003e100 可用形成扫描区间(100,+∞) ，key1\u003e‘c’ 对于uk_key2 索引来说是没有办法按照扫描区间来查找的（因为uk_key2 索引是按照key2列的值按大小顺序进行排序的，对于key1的值来说，是无序的），就只能全部扫描，即 (-∞,+∞ )。(100,+∞ )和 (-∞,+∞ ) 的并集也还是 (-∞,+∞ )，所以，即便使用uk_key2 索引，还是需要全表扫描，并且先扫描索引，还需要通过回表操作获取key1列的值，这无疑是比直接全表扫描更耗时。 对于扫描区间的 (-∞,+∞ )的筛选条件可以当成逻辑判断中的状态 TRUE 例如： select * from table_demo where key2\u003e100 or key1\u003e‘c’; 替换： select * from table_demo where key2\u003e100 or TRUE; 即： select * from table_demo where TRUE ; 使用key2列索引形成的索引区间是 TRUE，即 (-∞,+∞ ) 全表扫描 查询语句6： select*fromtable_demowhere(key1\u003e'xyz'andkey2=748)or(key1\u003c'abc'andkey1\u003e'lmn')or(key1like'%suf'andkey1\u003e'zzz'and(key2\u003c8000orcommon_field='abc')); 假设使用 idx_keyl 执行查询 那么对于key2、common_field 的筛选条件就都是需要全表扫描的，对于key1 like ‘%suf’ 是匹配字符末尾，也是需要全表扫描的， 即扫描范围是 (-∞,+∞ ) ,即查询语句可以替换成以下： select * from table_demo where (key1 \u003e ‘xyz’ and TRUE ) or (key1 \u003c ‘abc’ and key1 \u003e ’lmn’) or (TRUE and key1 \u003e ‘zzz’ and (TRUE orTRUE)); 因为 key1 \u003c ‘abc’ 和 key1 \u003e ’lmn’ 这两个条件永远无法满足，即FALSE，上述条件可用简化成： select * from table_demo where key1 \u003e ‘xyz’ or key1 \u003e ‘zzz’ 即扫描区间是（‘xyz’,+∞）和 （‘zzz’,,+∞）取并集，即扫描区间是（‘xyz’,+∞），需要把满足 key1 \u003e ‘xyz’ 条件的所有二级索引记录都取出来，针对获取到的每一条二级索引记录，都要用它的主键值再进行回表操作， 在得到完整的用户记录之后再使用其他的搜索条件进行过滤 。 假设使用 idx_key2 执行查询 那么对于key1、common_field 的筛选条件就都是需要全表扫描的，即扫描范围是 (-∞,+∞ ) ,即查询语句可以替换成以下： select * from table_demo where ​ (TRUE and key2 = 748 ) or ​ (FALSE) or ​ (TRUE and TRUE and (key2 \u003c8000 or TURE)); key2 \u003c8000 or TURE 结果 肯定是TURE，继续简化： select * from table_demo where key2 = 748 or TRUE 即：select * from table_demo where TRUE 得出来的扫描空间是： (-∞,+","date":"2022/04/29","objectID":"/posts/sql%E4%BC%98%E5%8C%961-%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4%E5%92%8C%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6/:1:0","tags":["mysql优化","扫描区间"],"title":"sql优化(1)-扫描区间和边界条件","uri":"/posts/sql%E4%BC%98%E5%8C%961-%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4%E5%92%8C%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6/"},{"categories":["数据治理"],"content":"什么是数据质量？如何提高数据质量","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/","tags":["数据质量"],"title":"数据质量概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"数据质量概述 ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/:1:0","tags":["数据质量"],"title":"数据质量概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"什么是数据 数据(data)：是事实或观察的结果，是对客观事物的逻辑归纳，是用于表示客观事物的未经加工的的原始素材。 数据可以是连续的值，比如声音、图像，称为模拟数据或者计量型数据。也可以是离散的，如符号、文字，称为数字数据或计数型数据。在计算机系统中，数据以二进制信息单元0，1的形式表示。 在信息技术中，数据也被理解为以数字形式存储的信息（尽管数据不仅限于已数字化的信息，还有纸面上的数据等）如姓名、地址、生日、周六晚餐吃的东西、最近买的书等有关信息。 ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/:1:1","tags":["数据质量"],"title":"数据质量概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"什么是数据质量 数据质量：一个评估规则维度提供一种测量与管理信息和数据的方式。 数据质量就是通过一组维度来测量数据的方式。就如同判断东西的好坏和性价比一样，数据也有一些好坏的评判标准。 数据完整性 **完整性（Completeness）：**用来描述信息的完整程度。 完整性指的是数据信息是否存在缺失的状况，数据缺失的情况可能是整个数据记录缺失，也可能是数据中某个字段信息的记录缺失。 数据完整性问题包括： ​ 模型设计不完整，例如：唯一性约束不完整、参照不完整； ​ 数据条目不完整，例如：数据记录丢失或不可用； ​ 数据属性不完整，例如：数据属性空值。 不完整的数据所能借鉴的价值就会大大降低，也是数据质量问题最为基础和常见的一类问。 数据唯一性 **唯一性（Uniqueness）：**用来描述数据是否存在重复记录。 比如真实成交 1 万条，但数据表有 3000 条重复了，成了 1.3 万条成交记录，这种数据不符合数据唯一性。 重复数据、冗余数据是导致业务无法协同、流程无法追溯的重要因素，也是数据治理需要解决的最基本的数据问题。 数据及时性 **及时性（Timeless）：**用来描述从业务发生到对应数据正确存储并可正常查看的时间间隔程度，也叫数据的延时时长，数据在及时性上应能尽可能贴合业务实际发生时点。 一般来说数据同步都是基于业务系统的落表技术字段（比如：CREATE_TIME），而真是业务发生的时间可能与该字段存在时间间隔。可以通过简单的sql对两个时间比较，判断数据的及时性是否符合需求。 数据有效性 有效性（Validity）： 用来描述模型或数据是否满足用户定义的条件（也称为数据规范性）。通常从命名、数据类型、长度、值域、取值范围、内容规范等方面进行约束。 **代码值域约束：**描述检核对象的代码值是否在对应的代码表内。如业务规则定义“性别”的取值应该是“1-未知的性别”、“2-男性”、“3-女性”、“4-未说明的性别”，如果出现“A”、“B”这样的取值，则认为“性别”的代码值域存在问题； **长度约束：**描述检核对象的长度是否满足长度约束。如“金融机构编码”在《人民银行金融机构编码规范》中规定长度为14位，如果出现非14位的值，则判定为不满足长度约束，不是一个有效的“金融机构编码”； **内容规范约束：**描述检核对象的值是否按照一定的要求和规范进行数据的录入与存储。如“存款账号”应仅含数字，如果出现字母或其他非法字符，则不是一个有效的“存款账号”，不满足内容规范约束； 取值范围约束：描述检核对象的取值是否在预定义的范围内。如“授信额度”取值范围应大于等于 0，如果出现小于 0 的情况，则超出了取值范围的约束，不是一个有效的“授信额度”； 数据准确性 **准确性（Accuracy）：**用来描述数据是否与其对应的客观实体的特征相一致（需要一个确定的和可访问的权威参考源）。 数据准确性主要是指取值的准确性，描述该检核对象是否与其对应的客观实体的特征相一致。例如：投保人的性别代码为 0-女性，虽然满足代码值域约束，但却不满足取值准确性约束，因为该人为男性，其性别代码应为 1-男性；再比如：国际保函业务的手续费应录入为国际担保手续费收入，却录入成国内担保手续费收入。 准确性要求不仅数据的取值范围和内容规范满足有效性的要求，其值也是客观真实世界的数据。由此可见，有效的数据未必是准确的，反之成立。准确性通常需要业务人员或其他当事人手工核查。 对待这种情况，数据质量规则没办法直接统一处理，只能通过即使查询的方式对数据结果进行详细核查。 数据一致性 **一致性（Consistency）：**用来描述同一信息主体在不同的数据集中信息属性是否相同，各实体、属性是否符合一致性约束关系。 数据质量的一致性主要体现在数据记录的规范和数据是否符合逻辑，一致性并不意味着数值上的绝对相同，而是数据收集、处理的方法和标准的一致。常见的一致性指标有：ID 重合度、属性一致、取值一致、采集方法一致、转化步骤一致。 **等值一致性：**一个检核对象数据取值必须与另一个或多个检核对象在一定规则下相等。一般指外键关联的场景。例如：保单表，理赔表的保单号存在保单主表，同一张表，两个字段之间的关联关系。 存在一致性：一个检核对象的数据值必须在另一个检核对象满足某一条件时存在。主要是强调业务的关联性，一个状态发生了则某个值一定会如何。例如：投保状态为已投保，则投保日期不应为空； 逻辑一致性：一个检核对象上的数据值必须与另一个检核对象的数据值满足某种逻辑关系（如大于、小于等）。 主要强调的是字段间的互相约束关系。例如：投保开始时间小于等于投保结束时间。 ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/:1:2","tags":["数据质量"],"title":"数据质量概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"数据质量管理 分析以下的场景： 场景一：作为数据分析人员，要统计一下近 7 天用户的购买情况，结果从数仓中统计完发现，很多数据发生了重复记录，甚至有些数据统计单位不统一。 场景二：业务看报表，发现某一天的成交 gmv 暴跌，经过排查发现，是当天的数据缺失。 造成这一情况的一个重要因素就是忽视了对数据质量的客观评估，没有制定合理的衡量标准，导致没有发现数据已出现问题。 技术层面 我们需要保证数据从源端到最终应用端流转过程中的数据质量，一方面我们需要提高每一位数据开发者的技术能力来提高模型和 ETL 的设计与落地质量，另一方面我们使用数据质量工具来对 ETL 过程进行监控。对于源端的数据问题，有时候也可以通过技术手段解决，比如编码映射、ID-Mapping、缺失值补全等等。 数据模型设计的质量问题，例如：数据库表结构、数据库约束条件、数据校验规则的设计开发不合理，造成数据录入无法校验或校验不当，引起数据重复、不完整、不准确。 数据源存在数据质量问题，例如：有些数据是从生产系统采集过来的，在生产系统中这些数据就存在重复、不完整、不准确等问题，而采集过程有没有对这些问题做清洗处理，这种情况也比较常见。 数据采集过程质量问题， 例如：采集点、采集频率、采集内容、映射关系等采集参数和流程设置的不正确，数据采集接口效率低，导致的数据采集失败、数据丢失、数据映射和转换失败。 数据传输过程的问题，例如：数据接口本身存在问题、数据接口参数配置错误、网络不可靠等都会造成数据传输过程中的发生数据质量问题。 数据装载过程的问题，例如：数据清洗规则、数据转换规则、数据装载规则配置有问题。 数据存储的质量问题，例如：数据存储设计不合理，数据的存储能力有限，人为后台调整数据，引起的数据丢失、数据无效、数据失真、记录重复。 系统之间的数据不一致问题。 业务层面 有时候，数据质量问题的根本原因是业务问题造成的，我们就需要从业务着手解决。 我们需要有业务专家或者业务部门参与，统一数据口径、纠正理解偏差、通过深入的沟通明确业务方诉求。 数据质量改进的驱动因素永远来自业务目标，不能脱离业务需求谈数据质量。制定数据质量改进方案的基础，首先是清晰定义业务需求，然后是根据业务需求对企业业务的长期影响来定义数据质量问题的优先级。衡量业务影响、定义问题优先级有助于明确治理目标并跟进数据质量改进的进度。 业务需求不清晰，例如：数据的业务描述、业务规则不清晰，导致技术无法构建出合理、正确的数据模型。 业务需求的变更，这个问题其实是对数据质量影响非常大的，需求一变，数据模型设计、数据录入、数据采集、数据传输、数据装载、数据存储等环节都会受到影响，稍有不慎就会导致数据质量问题的发生。 业务端数据输入不规范，常见的数据录入问题，如：大小写、全半角、特殊字符等一不小心就会录错。人工录入的数据质量与录数据的业务人员密切相关，录数据的人工作严谨、认真，数据质量就相对较好，反之就较差。 管理层面 技术再努力起到的作用毕竟有限，有些事情必须通过管理手段去约束。通过管理使得规范得以贯彻，通过管理来提高团队成员的数据质量意识，通过管理手段去协调各个参与方提高效率。 可以建立数据质量保障委员会，源端团队负责人、数据团队负责人、业务团队负责人，都要参与其中。统一规划顶层设计，制定统一数据架构、数据标准，设计数据质量的管理机制，采用分类处理的方式持续提升数据质量。源端的数据问题最好在源端解决，建立指标体系统一各方的数据口径，明确数据问题的责任谁的问题谁解决。 总之，只有管理上重视了，整体工作才好开展。 认知问题。企业管理缺乏数据思维，没有认识到数据质量的重要性，重系统而轻数据，认为系统是万能的，数据质量差些也没关系。 没有明确数据归口管理部门或岗位，缺乏数据认责机制，出现数据质量问题找不到负责人。 缺乏数据规划，没有明确的数据质量目标，没有制定数据质量相关的政策和制度。 数据输入规范不统一，不同的业务部门、不同的时间、甚至在处理相同业务的时候，由于数据输入规范不同，造成数据冲突或矛盾。 缺乏有效的数据质量问题处理机制，数据质量问题从发现、指派、处理、优化没有一个统一的流程和制度支撑，数据质量问题无法闭环。 缺乏有效的数据管控机制，对历史数据质量检查、新增数据质量校验没有明确和有效的控制措施，出现数据质量问题无法考核。 影响数据质量的因素，可以总结为两类，客观因素和主观因素。客观因素：在数据各环节流转中，由于系统异常和流程设置不当等因素，从而引起的数据质量问题。主观因素：在数据各环节处理中，由于人员素质低和管理缺陷等因素，从而操作不当而引起的数据质量问题。 ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/:1:3","tags":["数据质量"],"title":"数据质量概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"参考： 小白入门学习数据质量 数据仓库详细介绍（九.数据质量）理论与经验 数据管理百问（第3期）：数据质量 数据治理：数据质量提升十步法（PPT） 数据治理系列5：浅谈数据质量管理 数据质量：数据治理的核心 数据仓库之数据质量建设（深度好文） ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/:1:4","tags":["数据质量"],"title":"数据质量概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"什么是数据元、元数据、主数据、参考数据？这之间有哪些相同之处和不同之处？这篇博客将以轻松简单的描述介绍这些基本概念","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/","tags":["数据元","元数据","主数据","参考数据"],"title":"【数据治理】数据元、元数据、主数据、参考数据概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"【数据治理】数据元、元数据、主数据、参考数据概述 ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/:1:0","tags":["数据元","元数据","主数据","参考数据"],"title":"【数据治理】数据元、元数据、主数据、参考数据概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"数据元 什么是数据元： 《GB/T 19488.1 电子政务数据元第1部分：设计和管理规范》 里是这样定义的： 数据元（Data element）：又称数据类型，通过定义、标识、表示以及允许值等一系列属性描述的数据单元。在特定的语义环境中被认为是不可再分的最小数据单元。 示例\r\r举例说明: 语义环境：描述员工年龄的大小 age为数据元，“18“为数据元的值。 数据元一般来说由三部分组成： 对象类：思想、概念或真实世界中的事物的集合，它们具有清晰的边界和含义，其特征和行为遵循同样的规则。 特性：对象类中的所有成员共同具有的一个有别于其它的、显著的特征。 表示：它描述了数据被表达的方式。 还是以前面的例子： 语义环境：描述员工年龄的大小 age为数据元，“18“为数据元的值。 对象是员工 ，特性是 年龄 age ,表示是 数值 语义环境：描述员工所属部门的编码 deptcode为数据元，“1001“为数据元的值。 对象是员工所属部门，特性是 编码 deptcode ,表示是 文本 \r\r ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/:1:1","tags":["数据元","元数据","主数据","参考数据"],"title":"【数据治理】数据元、元数据、主数据、参考数据概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"元数据 什么是元数据 百度百科是这样定义的： 引用\r\r元数据（Metadata），又称中介数据、中继数据，为描述数据的数据，主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。\r\r 《DAMA数据管理知识体系指南》是这样定义的： 引用\r\r 元数据最常见的定义是“关于数据的数据”。这个定义非常简单，但也容易引起误解。可以归类为元数据的信息范围很广，不仅包括技术和业务流程、数据规则和约束，还包括逻辑数据结构与物理数据结构等。它描述了数据本身（如数据库、数据元素、数据模型），数据表示的概念（如业务流程、应用系统、软件代码、技术基础设施），数据与概念之间的联系（关系）。元数据可以帮助组织理解其自身的数据、系统和流程，同时帮助用户评估数据质量，对数据库与其他应用程序的管理来说是不可或缺的。它有助于处理、维护、集成、保护和治理其他数据。 \r\r 怎么理解呢？《DAMA数据管理知识体系指南》举了一个比较好理解的例子： 示例\r\r为了理解元数据在数据管理中的重要作用，试想一个大型图书馆中有成千上万的书籍和杂志，但是没有目录卡片。没有目录卡片，读者将不知道如何寻找一本特定的书籍甚至一个特定的主题。目录卡片不仅提供了必要的信息（图书馆拥有哪些书籍和资料以及它们被存放在哪里），还帮助读者可以使用不同的方式（主题领域、作者或者书名）来查找资料。如果没有目录，寻找一本特定的书将是一件十分困难的事情。一个组织没有元数据，就如同一个图书馆没有目录卡片。 面对数据总是会有以下的一些疑问： 这个数据怎么来的？ 谁创建的，谁更新的，从哪个系统来的… 这个数据是什么？ 数据的语义环境是什么，数据怎么存储的，数据的定位是什么… 这个数据怎么用？ 数据的应用场景是什么，有没有和其他系统共享，如果丢失会造成什么影响… 这个数据怎么管理？ 谁负责这个数据，这个数据怎么评定质量，谁有权访问这个数据… 为了更好的解决这些问题，从而使用元数据来记录数据相关的信息。 \r\r 元数据的分类 元数据管理的范围将涵括数据产生、数据存储、数据加工和展现等各个环节的数据描述信息，帮助用户理解数据来龙去脉、关系及相关属性。按其描述对象的不同可以划分为三类元数据：业务元数据、技术元数据、和操作元数据。 业务元数据 业务元数据（Business Metadata）主要关注数据的内容和条件，另包括与数据治理相关的详细信息。业务元数据包括主题域、概念、实体、属性的非技术名称和定义、属性的数据类型和其他特征，如范围描述、计算公式、算法和业务规则、有效的域值及其定义。业务元数据的示例包括： 1）数据集、表和字段的定义和描述。 2）业务规则、转换规则、计算公式和推导公式。 3）数据模型。 4）数据质量规则和检核结果。 5）数据的更新计划。 6）数据标准。 7）有效值约束。 8）数据的安全/隐私级别。 技术元数据 技术元数据（Technical Metadata）又可以分成结构性技术元数据和关联性技术元数据。结构性技术元数据提供了在信息技术的基础架构中对数据的说明，如数据的存放位置、数据的存储类型、数据的血缘关系等。关联性技术元数据描述了数据之间的关联和数据在信息技术环境之中的流转情况。技术元数据的示例包括： 物理数据库表名和字段名。 字段属性（数据类型）。 访问权限。 数据CRUD（增、删、改、查）规则。 物理数据模型，包括数据表名、键和索引。 记录数据模型与实物资产之间的关系。 ETL作业详细信息。 文件格式模式定义。 源到目标的映射文档。 数据血缘文档，包括上游和下游变更影响的信息。 程序和应用的名称和描述。 周期作业（内容更新）的调度计划和依赖。 恢复和备份规则。 数据访问的权限、组、角色。 操作元数据 操作元数据（Operational Metadata）主要是指与元数据管理相关的组织、岗位、职责、流程，以及系统日常运行产生的操作数据。操作元数据管理的内容主要包括:与元数据管理相关的组织、岗位、职责、流程、项目、版本，以及系统生产运行产生的操作记录，如运行记录、应用程序、运行作业。 批处理程序的作业执行日志。 抽取历史和结果。 调度异常处理。 错误日志。 报表和查询的访问模式、频率和执行时间。 补丁和版本的维护计划和执行情况，以及当前的补丁级别。 备份、保留、创建日期、灾备恢复预案。 数据归档、保留规则和相关归档文件。 清洗标准。 数据共享规则和协议。 技术人员的角色、职责和联系信息。 元数据应用 经过前面的介绍，大概对元数据有个初步的印象，可能接下来就要问了：元数据有什么用？ 先引入一个场景： 示例\r\r假设有一天，我们需要对某一些业务信息指标做一个报表统计，用于前端的数据展示，这些业务信息可能来自于不同的表，通过不同的ETL过程到目标数据仓库，最后展示在一个报表中，如下图所示： \r\r 血缘分析 举例： 示例\r\r假设你在管理报表，有一天你发现有报表数据中 指标3 的数据异常，你需要找出错误的数据并提交流程修正，那么这个错误数据从何而来？一个个核对数据显然不够高效，那你就得知道这个报表的的指标来源，元数据的血缘分析能帮助你分析这个错误数据的上游路径。 查看元数据可以发现： ​ 指标3 是由数据集市的 B主题数据 经过ETL过程生成的 ， ​ B主题数据 又是 由 数据仓库中的table1 和 table 4经过ETL过程生成的 \r\r 血缘分析是一种技术手段，用于对数据处理过程的全面追踪，从而找到某个数据对象为起点的所有相关元数据对象以及这些元数据对象之间的关系。元数据对象之间的关系特指表示这些元数据对象的数据流输入输出关系 。 由元数据构建的血缘分析，可以快速定位数据链路，明确ETL细节，缩小数据问题的范围。 影响分析 举例： 示例\r\r 还接上面的例子，有一天你发现数据仓库的table2 数据错了，等你将table2数据更正后，此时你需要及时提醒大家这个数据的更正信息，只需要通知这个数据影响到的实体就可以了，然而整个报表流程的数据传递这么复杂，怎么判断哪些实体会受到这个数据的影响呢。 \r\r 如果没有元数据，那我们可能需要遍历所有的脚本、数据。才能得到想要的答案；而如果有成熟的元数据管理，那我们就可以直接得到答案，节省大量时间。 数据地图 数据地图是一种图形化的数据资产管理工具，它提供了多层次的图形化展示，并具备各种力度控制能力，满足业务使用、数据管理、开发运维不同应用场景的图形查询和辅助分析需求。 问题\r\r为什么有数据地图： 如果公司的数据库里只有百十来张表，那基本上不需要啥数据地图，因为靠脑子就能全记住了。 但是，如果有好几个系统、几百张表，而且在数仓里还分了好多层，之间的关系错综复杂，谁能全部记得住啊？ \r\r 这个数据地图主要解决这些问题： 平台由多少数据资源？ ​每个数据源由多少表、字段？ ​这些表、字段里面都是什么内容？ ​怎么获取这些数据？ 为啥叫“数据地图”，其实就是借用了地图“找信息”的功能，意思是在“数据地图”功能中，能找到所有的数据。 数据地图不是跟百度地图、高德地图一样，而是跟ETL流程DAG一样的，或者直接是表格展示。 更简单的表格基本上就是库名、表名、元数据代码、字段名、数仓位置、上游 、下游、管辖单位、负责人等。 ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/:1:2","tags":["数据元","元数据","主数据","参考数据"],"title":"【数据治理】数据元、元数据、主数据、参考数据概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"主数据 什么是主数据 《 主数据管理实践白皮书（1.0 版）》是这样定义的： 引用\r\r主数据（MDM：Master Data）：指满足跨部门业务协同需要的、反映核心业务实体状态属性的组织机构的基础信息。主数据相对交易数据而言，属性相对稳定，准确度要求更高，唯一识别。\r\r 《数据管理知识体系 DMBOK1.0》 对主数据的定义： 引用\r\r主数据是关于业 务实体的数据，这些实体为业务交易提供关联环境。业务规则通常规定了主数据格式和允许的取值范围。主数据是关于关键业务实体的权威的、最准确的数据，可用于建立交易数据的关联环境。\r\r 从字面意思上可以理解成主要的数据，什么是主要的数据呢？ 在整个企业业务流程中起到关键作用，而且是比较常用的数据，在核心业务流程上产生的数据都是主数据 这么一解释可以发现主数据是可以检测企业发展是否健康的一种方式，但这么理解是有些偏差的。稍微严谨一点的定义就是主数据是整个企业中使用的核心、非交易性数据。 请注意：这里指的是非交易性数据 示例\r\r举个例子，比如你在ERP系统中能够看到一些交易数据，比如订单产生的日期和编号、地点、金额、商品、用户、供货商、店铺之类的信息。那么这些信息中的产品、供货商、用户、地点这些都是主数据，也就是说参与到核心流程中的主体数据都是主数据，这些实体为业务交易和分析提供了上下文信息。 那订单交易记录又算什么呢？这里其实又扩展出来了另外一种数据类型：交易数据，也就是这些实体数据结合在一起产生了事件活动记录，那么这个记录就属于交易数据。例如通话记录、销售记录等等事件。这样看起来好像主数据是嵌入到了交易数据中了，但是主数据相对交易数据来说的话，属性是相对稳定的，而且可信度要求高，需要做到唯一识别 。 \r\r 主数据的特点 根据主数据的定义，可以总结出以下的特点： （1）共享性： 主数据满足跨部门、跨系统、业务协调需要的共享数据 （2）高价值： 因为主数据是跨部门、跨系统、多业务需要的，所以比一般的数据，价值更高 （3）变化慢： 由于主数据是跨部门、跨系统的共享数据，反映核心业务实体的基本信息，其属性是相对稳定的 （4）高质量： 主数据的重要性要求其必须保障数据质量、准确性和一致性 （5）可集成： 主数据将各个系统共享的核心实体数据进行集中管理，制定统一标准规范 主数据的价值 主数据主要有以下三点价值： 消除数据冗余：不同部门按照自身需求获取数据，容易造成数据重复 存储，形成数据冗余。而主数据打通各业务链条，统一数据语言，统一数 据标准，实现数据共享，最大化消除了数据冗余。 提升数据处理效率：各部门对于数据定义不一样，不同版本的数据不 一致，一个核心也为主体有多个版本的信息，需要大量人力成本、时间成 本去整理和统一。通过主数据管理可以实现数据动态自动整理、复制，减 少人工整理数据的时间和工作量。 提高公司战略协同力：通过主数据的一次录入、多次引用，避免一个 主数据在多个部门和线条重复录入。数据作为公司内部经营分析、决策支撑的“通行语音”，实现多个部门统一后，有助于打通部门、系统壁垒，实现 信息集成与共享，提高公司整体的战略协同力。 ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/:1:3","tags":["数据元","元数据","主数据","参考数据"],"title":"【数据治理】数据元、元数据、主数据、参考数据概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"参考数据 什么是参考数据 《DAMA数据管理知识体系指南（第2版）》是这样描述的： 引用\r\r 参考数据是指可用于描述或分类其他数据，或者将数据与组织外部的信息联系起来的任何数据（Chisholm，2001）。最基本的参考数据由代码和描述组成，但是有些参考数据可能更复杂，还包含映射和层次结构。 \r\r 怎么理解呢？参考的中文解释就是 查阅、利用有关资料帮助学习、研究或了解情况 。参照数据类比考卷对应的参考答案，是对数据内容的解释说明，也包括对数据的范围限定。 参考数据可用于描述其他数据，列举了一个服务单状态代码示例。 代码 描述 定义 1 新建 表示一个新的服务单已经创建，但还未分配人员 2 已分配 表示一个新的服务单已经分配了服务人员 3 施工中 表示分配的服务人员已经开始处理 4 已解决 表示服务人员已经处理完成 5 已取消 表示该服务单根据交互情况已经取消 6 待定 表示服务暂时无法处理 7 已完成 表示请求已经处理完成 通过上面的参考数据，可以明确知道 代码值1-7表示什么状态，这些状态又代表什么业务含义。 参考数据可用于分类其他数据，列举一个通用标准产品与服务分类示例。 代码值 描述 上一级分类 10161600 花卉植物 10160000 10161601 玫瑰 10161600 10161602 猩猩木 10161600 10161603 兰花 10161600 10161700 切花 10160000 10161705 月季切花 10161700 通过上面的参考数据，可以知道 通用标准产品与服务分类，当查找玫瑰的时候，能找到它是属于花卉植物的。 参考数据可以将数据与组织外部的信息联系起来，列举中国省市区编码对照表； 国家名称 省份名称 城市名称 区域名称 区域编码 中国 北京 110000 中国 北京 北京市 110100 中国 北京 北京市 东城区 110101 中国 北京 北京市 西城区 110102 中国 北京 北京市 崇文取 110103 中国 北京 北京市 宣武区 110104 中国 北京 北京市 朝阳区 110105 中国 北京 北京市 丰台区 110106 中国 北京 北京市 石景山区 110107 中国 北京 北京市 海淀区 110108 根据这个对照表可以和外部的地理信息或者定位信息联系起来。 参考数据是增加数据可读性、可维护性以及后续应用的重要数据。例如，你看到“性别”的这个字段，很可能是1代表男性、2代表女性。在许多企业中有这样的约定俗成，而更多的参考数据可能记录在开发人员和运营人员的大脑当中。但问题是一旦这些人离开，您系统里面的数据就成了一堆没有注释的天书。 可能会觉得这所谓参考数据不就是数据字典吗？对，在很多系统里面都会有这样和那样的数据字典。但是正是由于这些数据字典局仅限于个别系统而没有统一标准，从一个侧面间接造就了大量的数据孤岛。企业为了进行更有效率的数据整合、数据共享和数据分析应用，开始尝试对参考数据进行企业或者部门层面的整合和管理，利用参考数据集记录系统尝试为范围内的IT系统中的数据库提供统一的参考数据。 ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/:1:4","tags":["数据元","元数据","主数据","参考数据"],"title":"【数据治理】数据元、元数据、主数据、参考数据概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"参考资料 【数据治理知识】详解元数据、主数据、参考数据和数据字典 解析数据仓库里的\"元数据管理\" 元数据和数据元 换个角度认识大数据（下）——元数据管理应用 主数据的3大特征、4个超越和3个二八原则 一文理解主数据和参考数据 解析数据仓库里的\"元数据管理\" 元数据和数据元 换个角度认识大数据（下）——元数据管理应用 主数据的3大特征、4个超越和3个二八原则 一文理解主数据和参考数据 【数据治理知识】详解元数据、主数据、参考数据和数据字典 ","date":"2022/04/24","objectID":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/:1:5","tags":["数据元","元数据","主数据","参考数据"],"title":"【数据治理】数据元、元数据、主数据、参考数据概述","uri":"/posts/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%95%B0%E6%8D%AE%E5%85%83%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"表中的数据到底存到了哪里？以什么格式存放的？MySQL以什么方式来访问这些数据？","date":"2022/04/12","objectID":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/","tags":["mysql优化","索引"],"title":"sql优化(0)-表和索引结构","uri":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"},{"categories":["数据库"],"content":"前言 信息\r\r 说明：这是学习《MySQL是怎样运行的 从根儿上理解MySQL》的笔记，非商业用途，仅供学习分享 表中的数据到底存到了哪里？以什么格式存放的？MySQL 以什么方式来访问这些数据？ MySQL 务器中负责对表中的数据进行 读取和写入工作的部分是存储引擎，而服务器又支持不同类型的存储引擎 比如 lnnoDB 、MyISAM 、MEMORY 等。不同的存储引擎一般是由不同的人为实现不同的特性而开发的，真实数据在不同存储引擎 中的存放格式一般是不同的，甚至有的存储引擎（比如 EMORY） 都不用磁盘来存储数据。也就是对于使用 MEMORY 存储引擎的表来说，关闭服务器后表中的数据就消失了。由于 lnnoDB MySQL 默认的存储引擎，也是最常用到的存储引擎。本文介绍InnoDB 存储引擎的记录存储结构，其他存储引擎可以作为参照进行学习。 \r\r ","date":"2022/04/12","objectID":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:1","tags":["mysql优化","索引"],"title":"sql优化(0)-表和索引结构","uri":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"},{"categories":["数据库"],"content":"行格式 平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存放形式也被称为行格式或者记录格式。InnoDB 存储引擎有不同类型的行格式，分别是 Compact、Redundant、Dynamic和Compressed ，这些行格式在原理上大体都是相同的。 注意\r\r为了更好地理解，本文会从一些例子出发，请注意这些必不可少的步骤： 先建一个表 //设置行格式Compact，字符集ASCIICREATETABLErecord_format_demo(clVARCHAR(1O),c2VARCHAR(1O)NOTNULL,c3CHAR(1O),c4VARCHAR(1O))CHARSET=asciiROW_FORMAT=COMPACT 插入两条数据 NSERTINTOrecord_format_demo(clc2,c3,c4)VALUES('aaaa','bbb',\" CC' , 'd') , ('eeee' , 'fff', NULL ，NULL) ; \r\r 最后生成的表数据如下图所示： 信息\r\rCompact 格式示意图如下： \r\r 记录的额外信息 这部分信息是服务器为了更好地管理记录而不得不额外添加的一些信息.这些额外信息分为3个部分，分别是变长字段长度列表、 NULL 值列 和记录头信息。 （1）变长字段长度列表 我们知道， MySQL 支持一些变长的数据类型，比如 VARCHAR间\\VARBINARY(M)、 各种 TEXT 类型、各种 BLOB 类型。我们也可以把属于这些数据类型的列称为变长字段。变 长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 MySQL 服务器搞懵。也就是说这些变长字段占用的存储空间分为两部分： 真正的数据内容. 该数据占用的字节数 COMPACT 行格式中，所有变长字段的真实数据占用字节数都存放在记录的开头位置，从而形成一个变长字段长度列表，各变长字段的真实数据占用的字节数按照列的顺序逆序存放。 字节数设定：如果该变长字段允许存储的最大字节数超过 255 字节，并且真实数据占用的字节数超过 127 字节，则使用2字节来表示真实数据占用的字节数，否则使用1字节。 比如：用UTF-8作为字符集，一个字符占用1~3个字节，那么 varchar(50) 允许存储的最大字节数就是 50X3 =150字节 另外需要注意的 一点是，变长字段长度列表中只存储值为非 NULL 的列的内容长度，不存储值为 NULL 列的内容长度。 那么表record_format_demo 列 c1、c2、c4都是varchar 类型，属于变长字段。字符集ASCII是每个字符1字节，可以得出下表： 信息\r\r对应的 Compact 格式值就是： \r\r （2）NULL 列表 我们知道 一条记录中的某些列可能存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中存储会很占地方，所以COMPACT 行格式把一条记录中值为 NULL 的列统一管理起来 ，存储到 NULL 值列表中.它的处理过程如下所示： 摘要\r\r 首先统计表中允许存储 NULL 的列有哪些 如果表中没有允许存储 NULL 的列，则 NULL 值列表也就不存在了，否则将每个允许存储 NULL 的列对应一个 进制位，二进制位按照列的顺序逆序排列 。二进制值为1 时，代表该列的值为NULL;反之，代表该列的值不为NULL; MySQL 规定 NULL 值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0; \r\r 根据 record_format_demo定义，c2列设置为非空，所以允许空值的列依次为 c1、c3、c4，总共3个字段，用3位二进制表示NULL列表，因为一个字节是8位，所以不足一个字节的话高位补0。 转换成16进制，分别是 0x00、0x06,假设NULL列表后，两条记录的底层格式为如下： （3）记录头信息 除了变长字段长度列表、 NUL 值列表之外，还有一个称之为记录头信息的部分。记录头信息由固定的5字节组成，用于描述记录的一些属性。5字节也就是40个二进制位 ，不同的位代表不同的意思，如下图所示： 这些记录头信息与数据页、索引有关，这里暂且不细讲，先了解，后续的篇幅将会展开 记录真实数据 对于record_format_demo表来说，记录的真实数据除了 c1 、c2、 c3 、 c4 ，这几个我们自己定义的列的数据外. MySQL 会为每个记录默认地添加一些列(也称为隐藏列)。具体的列如表 注意\r\r拓展：InooDB 表的主键生成策略 优先使用用户自定义的主键作为主键 如果用户没有定义主键，则选取一个不允许存储 NULL 值的UNIQUE键作为主键 如果表中连非空唯一约束的键都没有定义，则InooDB会为表默认添加一个名为 row_id 隐藏列作为主键 \r\r 因为表record_format_demo 没有设置主键，索引mysql会自动生成一个主键，并且将字符串按ASCII字符集存储对应的十六进制值。像char、int、float等固定存储长度的数据类型，其如果是null值，一般都会用全是0的二进制保存。 注意\r\r拓展：对char(M)列存储格式 在COMPACT 行格式里，char(M) 是否属于变长字段取决于表使用的字符集。如果字符集中所有字符都是固定长度（比如ASCII，字符都是占一个字节），那么char(M)就属于固定长度字段；如果字符集中字符所占用的字节数据是变动的(比如gbk,一个字符占用1~2个字节，utf8，一个字符占用1~3个字节)，那么char(M)就属于变长字段。一般如果定义char(M),则MySQL至少会分配M个字节来存储char(M)数据类型的值。 \r\r ","date":"2022/04/12","objectID":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:2","tags":["mysql优化","索引"],"title":"sql优化(0)-表和索引结构","uri":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"},{"categories":["数据库"],"content":"数据页 数据页概览 页是 InnoDB 管理存储空间的基本单位， 一个页的大小一般是16KB。InnoDB 为了不同的目的而设计了多种不同类型的页，比如存放表空间头部信息的页、存放 Change Buffer 信息的页、存放的INODE 信息的页、存放 undo 日志信息的页; 现在要说的是那些存放表中记录的那种类型的页，官方称这种存放记录的页为索引 (INDEX）页。 鉴于还没有介绍过索引是什么，而这些表中的记录就是我们日常所称的数据，所以目前还是将这种存放记录的页称为数据页。 一个 InnoDB 数据 的存储空间大致被划分成 7个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。 大致描述如下图： Infimum和Supremum 我们向表中插入的记录从本质上来说都是放到数据页的 User Records 部分，这些记录一条条亲密无间地排列着，把记录一条一条亲密无间排列的结构称之为堆 (heap)。 InnoDB会自动给每个页里面加了两条记录，由于这两条记录并不是用户自己插入的，所以有时候也称为伪记录或者虚拟记录。在这两条伪记录中，一条代表页面中的最小记录(也可以写作 Infimum 记录) ，另外一条代表页面中的最大记录（也可以写作 Supremum 记录)。这两条伪记录也算作堆的一部分。 Infimum和Supremum 这两条记录的构造十分简单，都是由5字节大小的记录头信息和 8字节大小的一个固定单词组成。 信息\r\r记录也可以比大小。对于一条完整的记录来说，比较记录的大小就是比较主键的大小。InnoDB 规定任何用户记录都比Infimum 记录大 ，任何用户记录都比 Supremum记录小 。\r\r User Records（记录在页中的存储） 在页的7个组成部分中，存储的记录会按照指定的行格式存储到User Records 部分。但是在一开始生成页的时候，其实并没有 User Records 部分，每当插入一条记录时 都会从 Free Space部分(也就是尚未使用的存储空间〉申请一个记录大小的空间，并将这个空间划分到 User Records 部分。当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，此时如果还有新的记录插入，就需要去申请新的页了 。 示例\r\r那么多条记录在页中具体是怎么存储的呢？现在就以一个例子展开： 创建一个表 page_demo，主键为c1 ,字符集是ASCII CREATETABLEpage_demo(clINT,c2INT,c3VARCHAR(lOOOO),PRIMARYKEY(cl)-\u003e)CHARSET=asciiROW_FORMAT=COMPACT; 然后插入4条数据 INSERTINTOpage_demoVALUES(l,100,'aaaa'),(2,200,'bbbb'),(3,300,'cccc'),(4,400,'dddd'); 那么4条数据在页中存储如下图（之战时部分记录头信息和列值，剩余的信息都归为其他信息）： \r\r 我们先看一下头信息的详细信息： 信息\r\rdeleted_flag ：这个属性用来标记当前记录是否被删除，占用1比特。值为0时表示记录没有被删除，值为1 表示记录被删除了。被删除的记录还在页中么？是的。这些被删除的记录之所以不从磁盘上移除，是因为在移除它们之后 还需要在磁盘上重新排列其他的记录，这会带来性能消耗，所以只打一个删除标记就可以避免这个问题。所有被删除掉的记录会组成一个垃圾链表，记录在这个链表中占用的空间称为可重用空间(关于链表是怎么形成的，在介绍过 next record 属性后大家就知道了)。之后若有新记录插入到表中，它们就可能覆盖掉被删除的这些记录占用的存储空间。 min_rec_flag：B+树每层非叶子节点中的最小的目录项记录都会添加该标记。MySQL一般把真实数据记录放在B+树的叶子节点，所以数据记录这个位值一般为0。 n_owned：这个放到下面的 Page Directory 篇幅来讲。 heap_no： 我们向表中插入的记录从本质上来说都是放到数据页的 User Records 部分，这些记录一条条亲密无间地排列着，把记录一条一条亲密无间排列的结构称之为堆 (heap)。为了方便管理这个堆，他们把一条记录(这条记录的 deleted_flag可以为 1)在堆中的相对位置称之为heap_no。 在页面前边的记录 heap_no相对较小，在页面后边的记录 heap_no相对较大，每次新申请一条记录的存储空间时，该条记录比物理位置在它前边的那条记录的 heap_no 值大1。Infimum记录和Supremum 记录的 heap_no值分别是0和1，也就是说它们在堆中的相对位置最靠前。注意的一点是，堆中记录的heap_no值在分配之后就不会发生改动了，即使之后删除了堆中的某条记录，这条被删除记录的 heap_no 值也仍然保持不变。 record_type： 这个属性表示当前记录的类型。一共有4类型的记录。0表示普通记录 ，1表示B+ 树非叶子节点的目录项记录，2 表示 lnfimum 记录，3 表示 Supremum记录。 next_record：这个属性非常重要 它表示从当前记录的真实数据到下一条记录的真实数据的距离。 如果该属性值为正数，说明当前记录的下一条记录在当前记录的后面。 如果该属性值为负数，说明当前记录的下一条记录在当前记录的前面。 \r\r 前面插入的4条数据记录，每一条记录都是32个字节大小的空间。按照前面信息，分析如下： Infimum和Supremum 都是由5字节大小的记录头信息和 8字节大小的一个固定单词组成。 第 1条记录的 next_record 值为 32， 意味着从第1条记录的真实数据的地址处向后找 28字节便是下一条记录的真实数据（从infimum记录的真实值占 8字节，Sepremum记录占13字节，第一条记录的变长字段列表占1字节，NULL值列表占1字节，记录头信息占5字节，所以是8+13+1+1+5=28字节）。 第4条记录的 next_record 值为 -111，意味着从4条记录的真实数据的地址处向前找 109字节便是下一条记录的真实数据。（从第4条记录的额外信息占用7字节，第1条记录、第2条记录、第3条记录，每条记录占用32字节，Sepremum记录的真实数据占用8字节 ，所以是 7+32X3+8=111字节）。 这其实就是个链表，可以通过一条记录找到它的下一条记录。但是需要注意的一点是 下一条记录指的并不是插入顺序中的下一条记录，而是按照主键值由小到大的顺序排列的下一条记录。而且规定 Infimum 记录的下一条记录就是本页中主键值最小的用户记录，本页中主键值最大的用户记录的下一条记录就是 Supremum 记录。 问题\r\rnext_record 为什么要指向记录头信息和真实数据之间的位置？ 为什么不指向整条记录的开头位置 ，也就是记录的额外信息开头的位置呢？原因是这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。前面还说过变长字段列表、 NULL值列表中的信息都是逆序存放的， 这样可以使记录中位置靠前的字段段和它对应的字段长度信息在内存中的距离更近，这可能会提高高速缓存的命中率。 如果把page_demo中的第2条记录删除，那么对应的链表又是怎么样的呢？ DELETEFROMpage_demoWHEREcl=2; 删除第2条记录后，发送如下变化： 第2条记录并没有从存 空间中移除，而是将该条记录的deleted_flag 设置为1 ; 第2条记录的 next_record 值变为0, 意味着该记录没有下一条记录了 第1条记录的next_record 指向了第 3条记录 Supremum 记录的n_owned值从5变成4 主键值2的记录被删掉了，但是没有回收存储空间(该记录的heap_no 也未发生改变) 。再次条把这条记录插入到表中 ，则这条新插入的记录会复用被删除记录的存储空间。 INSERTINTOpage_demoVALUES(2,200,'bbbb'); \r\r Page Directory (页目录) 我们平时在一本书中查找某个内容的时候，一般会先看目录，找到该内容对应的图书页码，然后再到对应的页码去查看内容。InnoDB也为记录制作了 一个类似的目录，制作过程如下所示： 将所有正常的记录（包括 Infimum Supremum 记录，但不包括已经标记为删除的记录）划分为几个组。 每个组的最后一条记录（也就是组内主键值最大的那条记录）相当于\"带头大哥\"，组内其余的记录相当于\"小弟 ”。“带头大哥”记录的头信息中的n_owned 属性表示该组内共有几条记录 。 将每个组中最后一条记录在页面中的地址偏移量（就是该记录的真实数据与页面中第0个字节之间的距离）单独提取出来，按顺序存储到靠近页尾部的地方。这个地方就是 Page Directory 。页目录中的这些地址偏移量称为槽 (Slot) ，每个槽占用 字节。页目录就是由多个槽组成的。 信息\r\r一个正常的页面也就是 16KB 大小，即 16384 字节，而 字节可以表示的地址偏移量范围是 0-65535， 所以 用2字节表示一个槽足够了。\r\r InnoDB 对每个分组中的记录条数是有规定的: 对于Infimum 记录所在的分组只能有1条记录； Supremum 记录所在的分组拥有的记录条数只能在1~8条之间； 剩下的分组中记录的条数范围只能是在4~8条之间； 所以给记录进","date":"2022/04/12","objectID":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:3","tags":["mysql优化","索引"],"title":"sql优化(0)-表和索引结构","uri":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"},{"categories":["数据库"],"content":"索引 B+索引 在很多时候，表中存放的记录都是非常多的，需要用到好多的数据页来存储这些记录。在很多页中找记录可以分为两个步骤: 定位到记录所在的页 从所在的页内查找相应的记录 示例\r\r还是结合例子，展开说明 先建立一个表 index_demo createtableindex_demo(c1int,c2int,c3char(1),primarykey(c1))row_format=compact; 先看一下index_demo表的行格式 record_type：表示当前记录的类型， 0表示普通记录 ，1表示B+ 树非叶子节点的目录项记录，2 表示 lnfimum 记录，3 表示 Supremum记录 next_record：记录头信息的一项属性 表示从当前记录的真实数据到下一条记录的真实数据的距离。每一条记录都有next_record，通过这个属性，可以把这些记录串联在一块，形成一个链表。 c1、c2、c3列中，c1列作为主键，其他信息暂时不管，都归入其他信息。 这里做一个假设：每个数据页最多能存放3条记录（实际上个一数据页非常大，可以存放好多记录）。有了这个假设之后，向 index_demo 表插入3 条记录： INSERTINTOindex_demoVALUES(l,4,'u'),(3,9,'d'),(5,3,'a'); 每个数据页在File header（头文件）中，会在FIL_PAGE_OFFSET 属性记录每个页的专属页号。数据记录在页中的存储大致是如下（忽略很多其他信息）： 继续插入很多记录，显然是一个页是放不下的，需要分散存储在多个数据页。每个页的File Header头文件中 FIL_PAGE_PREV 和 FIL_PAGE_NEXT 分别表是前一页页号和后一页页号，构成一个双向链表。就是这个双向链表将物理地址上分散的数据串联起来。规定：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值，而数据页内的数据记录也是按主键值排序过的。整个表的记录就按照主键值进行从小到大排序。 由于这些大小为 16KB的页在磁盘上可能并不挨着，如果想从这么多页中根据主键值快速定位某些记录所在的页，就需要给它们编制一个目录，每个页对应一个目录项，每个目录项包括下面两个部分 ： 页的用户记录中最小的主键值，用 key 来表示 页号，用 page_no 表示 InnoDB 需要一种可以灵活管理所有目录项的方式。InnoDB设计人员发现这些目录项其实与用户记录长得很像，只不过目录项中的两个列是主键和页号而己 。复用了之前存储用户记录的数据页来存储目录项。为了与用户记录进行区分 ，把这些用来表示目录项的记录称为目录项记录。通过记录头信息中的 record_ type 属性来区分一条记录是普通用户记录是目录项记录（ 0表示普通记录 ，1表示B+ 树非叶子节点的目录项记录，2 表示 lnfimum 记录，3 表示 Supremum记录） \r\r 比较一下目录项记录和普通的用户记录的不同点： 目录项记录的 record_ type 值是1，普通用户记录的 record_type 值是0 目录项记录只有主键值和页的编号两个列，而普通用户记录的列是用户自己定义的 可能包含很多列，另外还有InnoDB 添加的隐藏列 只有目录项记录中最小的目录项记录的记录头信息min_rec_flag 属性值是1 ，普通用户记录的 min_rec_flag属性值都是0 除了上述几点外，这两者就没啥差别了：它们用的是一样的数据页（页面类型都是0x45BF ，这个属性在 File Heade 中）；页的组成结构也是一样的〈就是前面介绍过的7部分)；都会为主键值生成 Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。 一个B+树的节点其实可以分成好多层。InnoDB 规定：最下面的那层〈也就是存放用户记录的那层〉为第0层，之后层级依次往上加（在 Page header 中的 page_level属性会记录层数）。 在真实环境中 一个页存放的记录数量是非常大的。假设所有存放用户记录的叶子节点所代表的数据页可以存放 100 条用户记录(16kb，100条记录，每条记录大约160字节)，所有存放目录项记录的内节点所代表的数据页可以存放 1000 条目录项记录（16kb，1000条记录，每条记录大约16字节，除去记录头信息5字节，页号4字节，大约有7字节存储主键值），那么： 如果B+树只有1层 ，也就是只有1 个用于存放用户记录的节点，则最多能存放 100 条用户记录 如果B+树有2层，最多能存放 1,000 x 100 = 100,000 条用户记录 如果 B+树有3层，最多能存放 1,000 x 1,000 x 100 = 100,000,000 条用户记录 如果B+树有4层，最多能存放 1,000 x 1,000 x 1,000 x 100 = 100,000,000,000 条用户记录 在一般情况下，我们用到的 B+ 树都不会超过4层。这样一来，在通过主键值去查找某条记录时 最多只需要进行4个页面内的查找（查找3个存储目录项记录的页和1个存储用户记录的页)。又因为在每个页面内存在 Page Directory (页目录) ，所以在页面内也可以通过二分法快速定位记录。 聚簇索引和二级索引 聚簇索引的特点： 1、使用记录主键值的大小进行记录和页的排序，这包括3方面的含义： 页〈包括叶子节点和内节点〉内的记录按照主键的大小顺序排成一个单向链表，页内的记录被划分成若干个组，每个组中主键值最大的记录在页内的偏移量会被当作槽依次存放在页目录中 ，可以在页目录中通过二分法快速定位到主键列等于某个值的记录 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表 存放目录项记录的页分为不同的层级，在同一层级中的页也是根据页中目录项记录的主键大小顺序排成个双向链表 2、 B+ 树的叶子节点存储的是完整的用户记录。所谓完整的用户记录，就是这个记录中存储了所有列的值(包括隐藏列) 所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在 SQL 语句中显式地去创建， InnoDB 存储引擎会自动创建聚簇索引。在 InnoDB 存储引擎中, 聚簇索引就是数据存储方式（所有的用户记录都存储在了叶子节点) ，也就是所谓的\"索引即数据，数据即索引”。 问题\r\r聚簇索引只能在搜索条件是主键值时才能发挥作用，原因是B+中的数据都是按照主键进行排序的。如果以别的列作为搜索条件该咋办呢? 比如为 c2 建立索引， 用 c2 列的大小作为数据页、页中记录的排序规则，然后再建一棵B+树 如图 ： \r\r 二级索引的特点： 1、使用记录 索引列的大小迸行记录和页的排序，这包括3方面的含义： 页（包括叶子节点和内节点）内的记录是按照索引列的大小顺序排成一个单向链表，页内的记录被划分成若干个组，每个索引列（c2）值最大的记录在页内的偏移量会被当作槽依次存放在页目录中，可以在页目录中通过二分法快速定位到索引列（c2）等于某个值的记录 各个存放用户记录的页也是根据页中记录的索引列（c2）大小顺序排成一个双向链表 存放目录项记录的页分为不同的层级，在同一层级中的页也是根据页中目录项记录索引列（c2）大小顺序排成一个双向链表 2、树的叶子节点存储的并不是完整的用户记录，而只是 **索引列（c2）+主键 ** 这两个列的值 3、目录项记录中不再是主键+页号的搭配而变成了索引列（c2）+主键值+页号 的搭配（索引列可能有大量相同的值，为了更精确的定位，就加上主键值作为索引列值相同时第二级的比较值） 如果想查找满足搜索条件 c2=4的记录，就可以使用刚刚建好的这棵 B+。需要注意一下，因为 c2 列并没有唯一位约束，也就是说满足搜索条件 c2 的记录可能有很多条，只需要在该B+树的叶子节点处定位到第一条满足搜索条件 c2=4的那条记录，然后沿着由记录组成的单向链表一直向后扫描即可。另外，各个叶子节点组成了双向链表，搜索完了本页面的记录后可以很顺利地跳到下一个页面中的第一条记录，然后继续沿着记录组成的单向链表向后扫描。 其中比较重要的细节是：在 这个 B+ 树的叶子节点处定位到第 一条符合条件的那条用户记录之后，需要根据该记录中的主键信息到聚簇索引中查找到完整的用户记录。 这个通过携带主键信息到聚簇索引中重新定位完整的用户记录的过程也称为回表。 然后再返回到这棵B+ 树的叶子节点处，找到刚才定位到的符合条件的那条用户记录， 并沿着记录组成的单向链表向后继续搜索其他也满足 c2=4的记录，每找到一条的话就继续进行回表操作。重复这个过程，直到下 条记录不满足 c2斗的这个条件为止。 问题\r\r为什么还需要一次回表操作呢？直接把完整的用户记录放到时子节点不就好了么？ 如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方了。 相当于每建立一颗 B+ 树都需要把所有的用户记录复制一遍，这就太浪费存储空间了。 \r\r 联合索引也是二级索引，联合索引是由多个列作为索引，原理都是一样的，按照索引列的先后顺序进行排序。 拓展：MylSAM 中的索引方案简介 在 lnnoDB 中索引即数据，也就是聚簇索引的那棵 B+ 树的叶子节点中已经包含了所有完整的用户记录。MyISAM 索引方案虽然也使用树形结构，但是却将索引和数据分开存储。 将表中的记录按照记录的插入顺序单独存储在一个文件中(称之为数据文件)。这个文件并不划分为若干个数据页 ，有多少记录就往这个文件中塞多少记录。这样一来，可以通过","date":"2022/04/12","objectID":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:4","tags":["mysql优化","索引"],"title":"sql优化(0)-表和索引结构","uri":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"},{"categories":["数据库"],"content":"表空间 表空间概述 表空间中的每一个页都对应着一个页号，也就是每个页的File Header（文件头部）中的 FIL_PAGE_OFFSET 属性，可以通过这个页号在表空间中快速定位到指定的页面。这个页号由4字节组成，也就是 32 位，所以一个2的32次方个页（大约40亿的数量级），如果按照页的默认大小为 16KB来算，一个表空间最多支持 64TB 的数据。 表空间中的页实在是太多了，为了更好地管理这些页面，InnoDB 的设计者提出了区 （extent） 的概念。对于 16KB 的页来说，连续的 64 页就是一个区 ，也就是说一个区默认占 1MB 空间大小。无论是系统表空间还是独立表空间 ，都可以看成是由若干个连续的区组成的，每 256 个区被划分成一组。 信息\r\r 每向表中插入 一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的 B+ 树的节点中插入数据。而 B+ 树每一层中的页都会形成一个双向链表，如果以页为单位来分配存储空间，双向链表相邻的两个页之间的物理位置可能离得非常远。 使用 B+ 树来减少记录的扫描行数的过程是通过一些搜索条件到 B+ 树的叶子节点中定位到第一条符合该条件的记录（对于全表扫描来说就是定位到第一个叶子节点的第一条记录) 。然后沿着由记录组成的单向链表以及由数据页组成的双向链表一直向后扫描就可以了。如果双向链表中相邻的两个页的物理位置不连续，对于传统的机械硬盘来说，需要重新定位磁头位置，也就是会产生随机 I/O 。 这样会影响磁盘的性能。所以应该尽量让页面链表中相邻的页的物理位置也相邻，这样在扫描叶子节点中大量的记录时才可以使用顺序 I/O 所以才引入了区 (extent)的概念。一个区就是在物理位置上连续的 64 个页(区里页面的页号都是连续的)。在表中的数据量很大时，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位进行分配。甚至在表中的数据非常非常多的时候，可以一次性分配多个连续的区，虽然这可能造成一点点空间的浪费(数据不足以填充满整个区) 。但是从性能角度看，可以消除很多的随机 I/O \r\r 使用 B+ 树执行查询时只是在扫描叶子节点的记录 ，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中，扫描效果就大打折扣了。所以，lnnoOB存储引擎对 B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段 (segment) ，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成两个段：一个叶子节点段和一个非叶子节点段。 默认情况下，一个使用 InnoOB 存储引擎的表只有一个聚簇索引个索引会生成两个段。而段是以区为单位申请存储空间的，一个区默认占用 1MB 存储空间。所以，默认情况下一个只存放了几条记录的小表也需要 2MB 的存储空间么？以后每次添加一个索引都要多申请 2MB 的存储空间么？这对于存储记录比较少的表来说简直是天大的浪费。 这个问题的症结在于一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的。即使段的数据填不满区中所有的页面，剩下的页面也不能挪作他用。现在为了考虑\"以完整的区为单位分配给某个段时，对于数据量较小 表来说太浪费存储空间\" 这种情况，提出了**碎片 ( fragment ) **的概念。也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，碎片区中的页可以用于不同的目的，比如有些页属于段 A，有些页属于段 B，有些页甚至不属于任何段。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的： 在刚开始向表中插入数据时，段是从某个碎片区以单个页面为单位来分配存储空间的 当某个段已经占用了 32 个碎片区页面之后，就会以完整的区为单位来分配存储空间 (原先占用的碎片区页面并不会被复制到新申请完整的区中) 段现在不能仅定义为某些区的集合，更精确的来说应该是一些零散的页面以及一些完整的区的集合。除了索引的叶子节点段和非叶子节点段之外，InnoOB 中还有为存储一些特殊的数据而定义的段，比如回滚段。 区 前面介绍表空间是由若干个区组成的，这些区大致可以分为4 种类型，这4种类型的区也可以称为区的4种状态(Status)： 处于 FREE、FREE_FRAG 以及 FULL_FRAG 种状态的区都是独立的，是直属于表空间；而处于 FSEG 状态的区是附属于某个段的。 为了方便管理这些区，InnoDB 有一个称为 XDES Entry (Extent Descriptor Entry) 的结构。每一个区都对应着一个 XDES Entry 结构，这个结构记录了对应的区的一些属性 Segment ID ： 每一个段都有一个唯一的编号，用ID表示。 Segment ID 字段表示的就是该区所在的段，前提是该区已经被分配给某个段了，不然该字段的值没有意义 List Node： 这个部分可以将若干个 XDES Entry 结构串连成一个链表。如果想定位表空间内的某一个位置，只需指定页号以及该位置在指定页号中的页内偏移量。Prev Node Page Number 和 Prev Node Offset 的组合就是指向前一个 XDES Entry 的指针，Next Node Page Number 和 Next Node Offset 的组合就是指向后一个 XDES Entry 的指针 State ：这个字段表明区的状态.可边的值分别是 FREE、FREE_FRAG、 FULL_FRAG、FSEG (前面提过) Page State Bitmap，这个部分共占用16字节，也就是 128 位。一个区默认有 64 个页，这 128 位被划分为 64 个部分，每个部分有 2 位，对应区中的一个页（比如 Page State Bitmap 部分的第 1位和第 2位对应着区中的第 1个页面，第 3位和第 4位对应着区中的第 2个页面….. 127 位和 128 位对应着区中的第 64 个页面）。这 2个位中的第 1位表示对应的页是否是空闲的，第 2位还没有用到。 **区、段、碎片区、附属于段的区、 XDES Entry 结构，把事情搞得这么复杂，初心仅仅是想减少随机 I/O， 又不至于让数据量少的表浪费空间。**向表中插入数据本质上就是向表中各个索引的叶子节点段、非叶子节点段插入数据。 段中插入数据时，申请新页面的过程： 当段中数据较少时，首先会查看表空间中是否有状态为 FREE_FRAG 的区(也就是查找还有空闲页面的碎片区)。如果找到了，那么从该区中取一个零散页把数据插进去 ;否则到表空间中申请一个状态为 FREE 的区(也就是空闲的区) ，把该区的状态变为 FREE_FRAG，然后从该新申请的区中取一个零散页把数据插进去。之后 ，在不同的段使用零散页的时候都从该区中取，直至该区中没有空闲页面；然后该区的状态就变成了 FULL_FRAG。 现在的问题是知道表空间中哪些区的状态是 FREE，哪些区的状态是 FREE_FRAG，哪些区的状态是 FULL_FRAG 呢？这用到了 XDES Entry 中的 List Node部分： 通过 List Node 把状态为 FREE 的区对应的 XDES Entry 结构连接成一个链表 ，这个链表称为 FREE 链表。 通过 List Node 把状态为 FREE_FRAG 的区对应的 XDES Entry 结构连接成一个链表，这个链表称为 FREE _FRAG 链表。 通过 List Node 把状态为 FULL_FRAG 的区对应的 XDES Entry 结构连续成一个链表，这个链表称为 FULL _FRAG 链表。 每当想查找一个 FREE FRAG 状态的区时，就直接把 FREE_FRAG 链表的头节点拿出来，从这个节点对应的区中取一些零散页来插入数据。就修改它的 State 字段的值，然后将其从 FREE_FRAG 链表移到 FULL_FRAG链表中.同理 如果 FREE_FRAG 链表 一个节点都没有，那么就直接从 FREE 链表中取一个节点移动到 FREE_FRAG 链表，并修改该节点 STATE 字段值为 FREE_FRAG。 然后再从这个节点对应区获取零散页。 当段中 数据已经占满了 32 个零散的页后，就直接申请完整的区来插入数据。怎么知道哪些区属于哪个段呢？可以根据段号 (Segment ID ) 来建立链表 (不同的索引分别有对应的叶子节点段和非叶子节点段 )。 FREE链表：同一个段中，所有页面都是空闲页面的区对应的 XDES Entry 结构会被加入到这个链表中。注意这与直属于表空间的 FREE 链袭区别开了，此处的 FREE 链表是附属于某个段的链表 NOT_FULL链表：同一个段中，仍有空闲页面的区对应的 XDES Entry 结构会被加入到这个链表中 FULL链表：同一个段中，已经没有空闲页面的区对应的 XDES Entry 结构会被加入到这个链表中 怎么找到这些链表呢 或者说怎么找到某个链表的头节点或者尾节点在表空间中的位置呢？InnoDB有一个名 List Base Node 链表基节点，这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少个节点的信息。 前面介绍的每个链表都对应这么 List Base Node 结构，其中. List Length 表明该链表一共有多少个节点 First Node Page Nurnbe 和","date":"2022/04/12","objectID":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:5","tags":["mysql优化","索引"],"title":"sql优化(0)-表和索引结构","uri":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"},{"categories":["数据库"],"content":"参考 MySQL原理 - InnoDB引擎 - 行记录存储 - Compact 行格式 ","date":"2022/04/12","objectID":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:6","tags":["mysql优化","索引"],"title":"sql优化(0)-表和索引结构","uri":"/posts/sql%E4%BC%98%E5%8C%960-%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"},{"categories":["数据库"],"content":"数据库的ACID指的是什么？什么是事务？为什么需要锁机制？","date":"2022/04/12","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","tags":["数据库事务","数据库锁"],"title":"数据库事务的简单介绍","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"事务和锁 ","date":"2022/04/12","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:1:0","tags":["数据库事务","数据库锁"],"title":"数据库事务的简单介绍","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"一、什么是事务 事务是逻辑上的一组数据库操作，要么都执行，要么都不执行。 例子：假如张三要给李四转账200元，这个转账会涉及到两个关键操作就是：将张三的余额减少200元，将李四的余额增加200元。如果两个操作之间突然出现错误，例如银行系统崩溃导致张三余额减少，而李四的余额没有增加，这样的系统是有问题的。事务就是保证这两个关键操作要么都成功，要么都要失败。 事务的特性 ① 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；例如转账的这两个关键操作（将张三的余额减少200元，将李四的余额增加200元）要么全部完成，要么全部失败。 ② 一致性： 确保从一个正确的状态转换到另外一个正确的状态，这就是一致性。例如转账业务中，将张三的余额减少200元，中间发生断电情况，李四的余额没有增加200元，这个就是不正确的状态，违反一致性。又比如表更新事务，一部分数据更新了，但一部分数据没有更新，这也是违反一致性的； ③ 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； ④ 持久性：一个事务被提交之后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 ","date":"2022/04/12","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:1:1","tags":["数据库事务","数据库锁"],"title":"数据库事务的简单介绍","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"二、事务之间的相互影响 事务之间的相互影响分为几种，分别为：脏读，不可重复读，幻读，丢失更新 脏读 事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的账户，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。 当事务 T1 正在访问字段 A 并且对进行了修改，而这种修改还没有提交到数据库中。这时另外一个事务 T2 也访问和使用字段 A，但由于事务 T1 修改字段 A 后还没有提交 COMMIT，而那么事务 T2 读到的字段 A 是**“脏数据”**。 丢失更新 第一类丢失更新： 撤销一个事务的时候，把其它事务已提交的更新数据覆盖了。这是完全没有事务隔离级别造成的。如果事务1被提交，另一个事务被撤销，那么会连同事务1所做的更新也被撤销。 第二类丢失更新：当两个或多个事务查询相同的记录，然后各自基于查询的结果更新记录时会造成第二类丢失更新问题。每个事务不知道其它事务的存在，最后一个事务对记录所做的更改将覆盖其它事务之前对该记录所做的更改。 例如：事务 T1 读取 A=20，事务 T2 也读取 A=20，事务 T1 修改 A=A-1，事务 T2 也修改 A=A+1，最终结果 A=21，事务 T1 的修改被丢失。 不可重复读 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的… 不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务1在事务2的更新操作之前读取一次数据，在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的。 不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。 幻读 事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉。 在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录, 就好像发生了幻觉一样。 幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。 ","date":"2022/04/12","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:1:2","tags":["数据库事务","数据库锁"],"title":"数据库事务的简单介绍","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"三、数据库隔离级别及原理 锁类型简述 共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。 排他锁(X锁):假设事务T1对数据A加上共享锁，那么事务T2不能读数据A，不能修改数据A。 读未提交 Read Uncommitted：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。 原理： 事务对当前读取的数据不加锁； 事务对数据更新前添加 行级共享锁，直到事务结束才释放。 可能发生的情况： 事务1读取某些数据记录时，事务2也能对这些记录进行读取、更新；当事务2对这些记录进行更新时，事务1再次读取记录，能读到事务2对该记录的修改版本，即使更新尚未提交。 事务1更新某些数据记录时，事务2不能对这行记录做更新，直到事务1结束。 简单地理解就是： 允许事务同时读数据 允许一个事务读取数据同时另外一个事务修改数据 必须等更新数据的事务执行完成后，才能对执行其他的读取或者修改该数据的事务 读已提交 Read Committed：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。 原理： 事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁； 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。 可能发生的情况： 事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的只能是事务2对其更新前的版本，要不就是事务2提交后的版本。 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。 简单地理解就是： 允许事务同时读数据 必须一个事务读取完数据后，另外一个事务才能修改该数据 必须等更新数据的事务执行完成后，才能对执行其他的读取或者修改该数据的事务 可重复读 Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。 原理： 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放； 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。 可能发生的情况： 事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的仍然是第一次读取的那个版本。 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。 简单地理解就是： 允许事务同时读数据 必须等读取数据的事务执行完成后，才能对执行其他的修改该数据的事务 必须等更新数据的事务执行完成后，才能对执行其他的读取或者修改该数据的事务 可序列化 Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放； 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。 可能发生的情况： 事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的仍然是第一次读取的那个版本。 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。 简单地理解就是： 所有的事务必须等上一个事务执行完成后才开始执行 参考： 数据库的4种隔离级别 数据库隔离级别 及 其实现原理 【原创】惊！史上最全的select加锁分析(Mysql) 数据库隔离级别及原理解决方案 【原创】惊！史上最全的select加锁分析(Mysql) 数据库隔离级别及原理解决方案 ","date":"2022/04/12","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:1:3","tags":["数据库事务","数据库锁"],"title":"数据库事务的简单介绍","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"mysql有哪些数据类型？对应的计算机底层是怎么表示的？","date":"2022/04/12","objectID":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/","tags":["mysql","数据库"],"title":"mysql数据类型概述","uri":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"数据类型概述 mysql中有很多数据类型，包括整数、实数、字符串、时间、大文件存储。通过底层原理来看一下mysql数据类型的具体应用场景。 ","date":"2022/04/12","objectID":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/:1:0","tags":["mysql","数据库"],"title":"mysql数据类型概述","uri":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"整数类型 整数类型列表 数据类型 存储长度(byte) 最小值 最大值 TINYINT 1 -128 127 SMALLINT 2 -32,768 32,767 MEDIUMINT 3 -8,388,608 8,388,607 INT(INTEGER) 4 -2,147,483,648 2,147,483,647 BIGINT 8 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 整数的底层存储原理 整数的编码分为原码、反码和补码。计算机使用的是补码的存储方式。它们的定义如下： 原码：在数值前面增加了一位符号位(即最高位为符号位)，该位为0表示正数，该位为1表示负数，其余位表示数值的大小。 以-100 为例子 100=64+32+4 用1个字节 8位二进制表示 二进制位对应的大小 128 64 32 16 8 4 2 1 100对应的二进制表示 0 1 1 0 0 1 0 0 最高位是符号位 0表示正数 1表示负数 -100 的原码是 1110 0100 反码：正数的反码与其原码相同。负数的反码是对其原码逐位取反，但符号位除外。 以-100 为例子 -100 的原码是 1110 0100 -100 的反码是 1001 1011 补码：正数的补码与其原码相同，负数的补码就是对该负数的反码加1。 以 -100为例子 -100 的反码是 1001 1011 -100 的补码是 1001 1100 计算机为什么使用补码作为存储方式呢？ 如果我们用原码来储存数据，那么 0 这个数字就会有两个数字来表示 =》 原码+0 0000 0000 原码-0 1000 0000 如果我们用反码来储存数据，那么 0 这个数字也会有两个数字来表示 =》 反码+0 0000 0000 反码-0 1111 1111 这样的数据在计算机这样的精确软件中是不允许存在的，这样只有补码满足这个条件 补码+0 0000 0000 补码-0 0000 0000 机器中只有加法，减法会变成补码的加法。 1、补码加法运算： [x]补 + [y]补 = [x+y]补 2、补码减法运算： [x-y]补 = [x+(-y)]补 = [x]补 + [-y]补 下面从两个角度理解-128的补码为什么是1000 0000. 从补码的意义上去理解 因为：256-128=256+(-128) 的补码 而 256-128=128 所以 256+（-128）的补码=128 所以 （-128）的补码=256-128 =128 数学上， 128的二进制表示为 1000 0000 故规定-128的补码为 1000 0000 注意：只是规定而已，下面还有原因 8位二进制 的补码组合序列有256个 0000 0000 - 0111 1111 0 ~+127 1000 0000 用来干啥好呢？ 1000 0001 - 1111 1111 -127~-1 再看看这个规律表 原码 补码 值 0111 1111 0111 1111 +127 0111 1110 0111 1110 +126 ... 补码不断-1 ... 0000 0000 0000 0000 0 1000 0001 1111 1111 -1 1000 0010 1111 1110 -2 1000 0011 1111 1101 -3 ... 补码不断-1 ... 1111 1111 1000 0001 -127 无法表达 1000 0000 -128 于是就有了规定 1000 0000 定为 -128的补码 总结：整数在计算机都是补码形式存储的，以1个字节为例子，从 0~127 的正负两个值共255个数（0,+1,-1,+2,-2…..），因为0 没有正负的概念，就把剩余的一个补码 1000 000 规定为 -128 ，范围大小是-128~127 ","date":"2022/04/12","objectID":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/:1:1","tags":["mysql","数据库"],"title":"mysql数据类型概述","uri":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"实数类型 实数类型列表 数据类型 存储长度(byte) 最小值 最大值 FLAOT 4 10的38次方级 10的38次方级 DOUBLE 8 10的308次方级 10的308次方级 DECIMAL 对decimal(M,D) ，依赖于M,D 依赖于M,D 依赖于M,D 浮点数的底层存储原理 float的表示原理：首先我们知道常用科学计数法是将所有的数字转换成 $\\pm{a.b10^c}$ 的形式，其中a的范围是1到9共9个整数，b是小数点后的所有数字，c是10的指数。而计算机中存储的都是二进制数据，所以float存储的数字都要先转化$\\pm{a.b2^c}$由于二进制中最大的数字就是1，所以表示法可以写成 的 $\\pm{1.b*2^c}$形式，float要想存储小数就只需要存储（$\\pm$）、b 和 c 就可以了。 float的存储正是将4字节32位划分为了3部分来分别存储正负号，小数部分和指数部分的： ​ 1、Sign（1位）：用来表示浮点数是正数还是负数，0表示正数，1表示负数。 ​ 2、Exponent（8位）：指数部分。即上文提到数字c，但是这里不是直接存储c，为了同时表示正负指数以及他们的大小顺序，这里实际范围是 -127~+127 ​ 3、Mantissa（23位）：尾数部分。也就是上文中提到的数字b 比如8.25用二进制表示可表示为1000.01，转成指数的形式1.00001*2^3,在计算机中 double和float 都是一样，double 是8个字节 64位二进制。 DECIMAL类型简介 DECIMAL从MySQL 5.1引入，列的声明语法是DECIMAL(M,D)。NUMERIC与DECIMAL同义，如果字段类型定义为NUMERIC，则将自动转成DECIMAL。 对于声明语法DECIMAL(M,D)，自变量的值范围如下： M是最大位数（精度），范围是1到65。可不指定，默认值是10。 D是小数点右边的位数（小数位）。范围是0到30，并且不能大于M，可不指定，默认值是0。 例如字段 salary DECIMAL(5,2)，能够存储具有五位数字和两位小数的任何值，因此可以存储在salary列中的值的范围是从-999.99到999.99。 总结 ​ float单精度小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位 double双精度小数部分能精确到小数点后的15位，加上小数点前的一位 有效位数为16位。 ​ float 和doble 都是近似值，本身就无法保障数据就一定精准。 通常在设置小数的时候，都是用的decimal类型!! ","date":"2022/04/12","objectID":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/:1:2","tags":["mysql","数据库"],"title":"mysql数据类型概述","uri":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"字符串类型 字符串类型列表 数据类型 存储占用最大空间 CHAR 255字符 VARCHAR 65535字节或者255字符 TINYTEXT 255字节 TEXT 65,535字节 ( ~64kb） MEDIUMTEXT 16,777,215字节 (~16MB) LONGTEXT 4,294,967,295字节（~4GB） TINYBLOB 255字节 BLOB 65,535字节 ( ~64kb） MEDIUMBLOB 16,777,215字节 (~16MB) 相关拓展 varchar 长度限制因素： a) 存储限制 ​ varchar 字段是将实际内容单独存储在聚簇索引之外，内容开头用1到2个字节表示实际长度（长度超过255时需要2个字节），因此最大长度不能超过65535。 b) 编码长度限制 ​ 字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766; 　字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845。 　使用GBK英文则每个字符占用2个字节，而使用UTF－8英文却只占一个字节。 　若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。 c) 行长度限制 　MySQL要求一个行的定义长度不能超过65535。 varchar 和char 比较： **VARCHAR类型用于存储可变长字符串。**它比定长类型更节省空间，因为它仅使用必要的空间(例如，越短的字符串使用越少的空间)。有一种情况例外，如果MySQL表使用ROW_FORMAT=FIXED创建的话，每一行都会使用定长存储，这会很浪费空间。 VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。假设采用latin1字符集，一个VARCHAR(10)的列需要11个字节的存储空间。VARCHAR(1000)的列则需要1002个字节，因为需要2个字节存储长度信息。 **VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是变长的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。**如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，不同的存储引擎的处理方式是不一样的。例如，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。其他一些存储引擎也许从不在原数据位置更新数据。 下面这些情况下适用VARCHAR是合适的： 字符串列的最大长度比平均长度大很多 列的更新很少，所以碎片不是问题 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储 **CHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。**当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。 CHAR适合存储很短的字符串，或者所有值都接近同一个长度。例如，CHAR非常适合存储密码的MD5值，因为这是一个定长的值。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率。例如用CHAR(1)来存储只有Y和N的值，如果采用单字节字符集只需要一个字节，但是VARCHAR(1)却需要两个字节，因为还有一个记录长度的额外字节。 总结： 当我们为字符串类型的字段选取类型的时候，判断该选取VARCHAR还是CHAR，我们可以从以下几个方面来考虑： 该字段数据集的平均长度与最大长度是否相差很小，若相差很小优先考虑CHAR类型，反之，考虑VARCHAR类型。 若字段存储的是MD5后的哈希值，或一些定长的值，优先选取CHAR类型。 若字段经常需要更新，则优先考虑CHAR类型，由于CHAR类型为定长，因此不容易产生碎片。 对于字段值存储很小的信息，如性别等，优先选取CHAR类型，因为VARCHAR类型会占用额外的字节保存字符串长度信息。 总之一句话，当我们能够选取CHAR类型的时候，或者说空间消耗相对并不是影响因素的重点时，尽量选取CHAR类型，因为在其他方面，CHAR类型都有着或多或少的优势。而当空间消耗成为了很大的影响因素以后，我们则考虑使用VARCHAR类型。 BLOB 介绍 BLOB (binary large object)二进制大对象，是一个可以存储二进制文件的容器。在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。BLOB是一个大文件，典型的BLOB是一张图片或一个声音文件，由于它们的尺寸，必须使用特殊的方式来处理。 ","date":"2022/04/12","objectID":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/:1:3","tags":["mysql","数据库"],"title":"mysql数据类型概述","uri":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"时间类型 时间类型列表 数据类型 存储长度(byte) 最小值 最大值 YEAR 1 1001 9999 TIME 3 00:00:00 23:59:59 DATE 3 1001-01-01 9999-12-31 DATETIME 8 1001-01-01 00:00:00 9999-12-31 23:59:59 TIMESTAMP 4 1970-01-01 00:00:00 MySQL 中常见的时间类型有三种DATE, DATETIME和 TIMESTAMP，其中DATE类型用于表示日期，但是不会包含时间，格式为YYYY-MM-DD，而DATETIME和TIMESTAMP用于表示日期和时间，常见的格式为YYYY-MM-DD HH:MM:SS，也可以带6位小数来表示微秒。 不同于DATETIME，TIMESTAMP支持的时间范围从1970-01-01 00:00:01.000000到2038-01-19 03:14:07.999999，使用了TIMESTAMP的应用很有可能在2038-01-19 03:14:07.999999之后宕机，同样面临这个问题的还有所有的类Unix系统，因为他们使用了time_t这一32位数字来表示时间，这就是著名的2038年问题。 ","date":"2022/04/12","objectID":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/:1:4","tags":["mysql","数据库"],"title":"mysql数据类型概述","uri":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"参考 关于 -128 ，+128，-0，+0，-1 的反码补码 MySQL如何选择float, double, decimal MySQL数据类型（decimal的存储大小） MySQL中varchar和char类型的区别 MySQL中varchar最大长度是多少? MySQL中“诡异”的TIMESTAMP数据类型 8.5. 日期/时间类型 MySQL 尽量避免使用 TIMESTAMP Mysql varchar 最大长度是多少? MySQL中“诡异”的TIMESTAMP数据类型 8.5. 日期/时间类型 MySQL 尽量避免使用 TIMESTAMP ","date":"2022/04/12","objectID":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/:1:5","tags":["mysql","数据库"],"title":"mysql数据类型概述","uri":"/posts/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"索引是什么？为什么能加快sql查询？","date":"2022/04/12","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/","tags":["sql","索引","数据库","mysql"],"title":"mysql索引介绍","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"索引概述 ","date":"2022/04/12","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/:1:0","tags":["sql","索引","数据库","mysql"],"title":"mysql索引介绍","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"一、计算机存储原理 在理解索引这个概念之前，我们需要先了解一下计算机存储方面的基本知识。 我们知道数据持久化之后存在了数据库里,那么我现在的问题是数据库将数据存在了哪里？答案显然是存在了计算机的存储设备上。就个人电脑而言，数据被存在了我们的电脑存储设备上。 计算机的存储设备有很多种，其中速度越快的越贵，因此容量也往往越小例如我们的RAM随机存储器，也就是大家平时说的内存条，速度慢的就相对便宜例如我们的硬盘。而我们的数据往往都是被存在最慢的存储设备硬盘上的，因为存在硬盘当中的数据在断电之后依然存在。 计算机的存储介质有多种，例如硬盘，例如高速缓存，不同的存储介质的数据读取速度是不一样的。例如，像RAM这样的易失性存储设备的读写操作就非常快，访问其中的数据几乎没有延迟性。 由于这个原因，计算机操作系统的设计是这样的：数据永远不会直接从硬盘等机械设备中取出，而是首先从硬盘转移到更快的存储设备，例如RAM，从RAM当中应用程序直接按需获取数据。 计算机内部的机械硬盘是下面这样的： 在一个典型的硬盘驱动器中可以有很多个盘片，“盘片”在外观上非常类似于一个光盘（但具有很高的存储容量）。盘片又被磁道分条，同时一个盘片又可以分为扇区。 要获取数据，“盘片”需要由主轴进行旋转。大多数硬盘供应商都提到了主轴旋转的速度，例如，7200转/分和15000转/分。磁盘中的数据总是以扇区的固定大小倍数表示。因此，如果要从硬盘访问数据，需要执行以下步骤，这也是性能开销的主要来源。 1、当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间。 2、然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。 3、从扇区开始到扇区结束获取整个数据。 如果数据恰好分布在连续扇区上，那么它将提高获取数据的性能。因为主轴和磁头本身不需要移动/旋转，也就没有太多开销，但是大多数时候这种开销是存在的。 由于存在这种开销，我们不能直接从硬盘获取数据。RAM的存储器高性能的背后的主要原因是它没有像硬盘那样的机械运动部件。但是尽管RAM的性能很高，但它当中的数据却不会用作永久存储，断电之后就会消失，重新启动之后就什么都没有了，这是我们需要硬盘来进行持久化的原因所在。数据库中的数据毫无疑问就是存放在硬盘当中的，因此访问数据库中的数据不可避免的会经历磁盘操作的开销。 ","date":"2022/04/12","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/:1:1","tags":["sql","索引","数据库","mysql"],"title":"mysql索引介绍","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"二、局部性原理与磁盘预读 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 当一个数据被用到时，其附近的数据也通常会马上被使用。 程序运行期间所需要的数据通常比较集中。 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。 预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 ","date":"2022/04/12","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/:1:2","tags":["sql","索引","数据库","mysql"],"title":"mysql索引介绍","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"三、什么是索引 要想搞懂索引的本质是什么，就要先看下没有索引Msql会怎样工作？mysql数据是存储在磁盘文件中，但是磁盘的数据是随机分布的，而且数据本身写入就有先有后或删除修改，原地址在存入新的数据，所以数据在磁盘的保存不一定会落在同一个磁道上，即使在同一个磁道上也不一定就是有序的。 如上图所示，那么对于一条sql查询语句来说，就是要对磁盘文件进行扫描读取，一次读取就是一次IO操作，假设一张表有1000万的数据，一个select语句where col=998，那么就是要逐行逐行扫描磁盘文件直到读到该数据为止。很显然这种方式效率是极低的。那我们的目的就是要减少数据的查找次数，也就是减少IO，索引就帮我们解决这个问题。 那么索引是什么？索引就是帮助MySQL高效获取数据的排好序的数据结构。 ","date":"2022/04/12","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/:1:3","tags":["sql","索引","数据库","mysql"],"title":"mysql索引介绍","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"四、索引的数据结构 2.1、二叉树 搜索二叉树是按顺序排列的数据结构，如果用二叉树作为索引的数据结构，以下图为例：给列2添加索引就生成右边的二叉树。如果查询语句【select 列1，列2 from T where 列2=31】全表扫描查询，总共要访问7次，每一次访问都需要进行磁盘I / O操作，总共进行7次磁盘I / O；如果按照二叉树索引，总共访问3次节点，总共进行3次磁盘I / O。 注意：磁盘IO是机械方法读取，读写速度较内存慢几个数量级，数据查询大部分时间消耗主要是在磁盘读写数据这个步骤，有效减少磁盘IO，是优化数据查询的最直接的方式。 给列1添加索引生成右边的二叉树。查询语句【select 列1，列2 from T where 列1=7】，如果全表扫描，则访问7次，每一次访问都需要进行磁盘I / O操作，总共进行7次磁盘I / O；如果按照二叉树索引，总共访问7次，进行7次磁盘I / O。这时的索引的效率和不加索引全表扫描的效率是一样的。 对比这两种情况，可以知道如果二叉树的高度越小，那么对比次数也会越少，执行IO也会越少。 2.2、红黑树 红黑树就是在二叉树的基础上进一步优化，减少树的高度（红黑树是平衡树，可以调整树的高度）。进一步减少IO次数。例如：给列1添加红黑树索引。查询语句【select 列1，列2 from T where 列1=7】，如果全表扫描，则访问7次，每一次比较都需要进行磁盘I / O操作，总共进行7次磁盘I / O；如果按照红黑树索引，总共访问3次，总共进行3次磁盘I / O。 但有一个问题就是：当数据量变为一百万行，红黑树的高度是20，查询性能还是比较差 2.3、B-树 B-树（称为B树）是多阶树，一个节点可以存储多个索引值。还是上面的例子：给列1添加B-树索引（4阶树）。查询语句【select 列1，列2 from T where 列1=7】，如果全表扫描，则访问7个节点，每一次访问都需要进行磁盘I / O操作，总共进行7次磁盘I / O；如果B-树索引，总共访问2个节点，总共进行2次磁盘I / O。 B-树：增加了节点存储的关键字，原先二叉树结构是一个节点一个关键字，B-树是一个节点可以多个关键字。如果都是3层高度，二叉树能存7个关键字。mysql默认的一个节点16K的大小，可以通过show global status like “Innodb_page_size” 看到该值是16384，每次IO读取16K大小的数据，假设索引加指针加数据大小1k(B-树每个索引是带数据的),则 可存储16 X 16 X 16=4096 大约4000个关键字。 2.4、B+树 使用B树存放数据之后会在每个对应的索引列的值上存放上对应的数据。而B+树则不同，它只会在叶子节点上面挂载数据，非叶子节点不会存放数据，数据只会存在叶子节点上面，非叶子节点只存放索引列的数据。B+树是叶子节点之间也有双向指针连接，提高区间范围性能，范围查找。 mysql默认的一个节点16K的大小，可以通过show global status like “Innodb_page_size” 看到该值是16384，每次IO读取16K大小的数据，以索引列是bigInt类型为例，大小8字节，每一条数据还有一个指向下一层的指针6字节，16384/（8+6）=1170，一个节点就大约可以存1170条数据。 以一个层高为3的树为例，叶子节点存放数据之后大小1KB，那么这个树可以存放 1170 *1170 *16 =21,902,400,大约2200万条数据。所以在这种千万级的表中通过主键索引查找一条数据，最多3次IO就可以找到一条数据。而很多时候树的根节点基本都是在内存中，所以多数时候只需要2次IO。 B+树设计的巧妙之处，非叶子节点只放索引不放数据，可以让16kb大小的节点存储更多的索引，使得树更低。而且B+树可以更好的支持范围查询，比如要查询大于20的数据，可以很快的通过B+索引树定位到20所在的节点，然后可以根据其排好序的特点一直往右边拿数据，拿到下一页也可以根据指针快速定位到下一页的数据，顺藤摸瓜下去快速拿到所有大于20的数据。提高区间的访问性正是这个意思，而B树是没有这个指针的，跨页的时候又得从根节点往下找。 2.5、hash表 哈希索引基于哈希表实现，只有匹配所有列的查询才有效。对于每一行数据，存储引擎都会对所有索引列计算一个哈希码，哈希码是一个较小的值，不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时保存指向每个数据行的指针。 还是以前面的例子说明。对列2创建hash索引，按照对5取余数的方法计算每行的hash值，如：25%5=0,hash值对应位0。 则在 hash表（就是一个数组）根据前面计算的hash值作为下标找到arrays[0]，存储指向表第一行的指针。以此类推：表第二行列2值为12，12%5=2，则arrary[2]存储第二行指针。当发生hash值相同，但arrary数组对应位置存入其他行指针，这就需要把对应行的指针数据存入hash表链接的链表中。 如果哈希冲突比较少的情况，只需要通过计算hash值，通过下标找到对应的表数据行指针（数据存储地址），只需要一次磁盘IO，例如：【select * from T where 列2=31】，直接可以从array[1]获取指向第7行的指针并进行1次磁盘IO，获取这一行的数据。哈希冲突比较多的情况，相同hash值的数据行指针依次存到链表中，例如：【select * from T where 列2=22】，hash值为2 ，有3个列2值的hash值为2，那么就需要依次从磁盘获取 第2行、第3行、第5行的数据进行比较，总共3次磁盘IO。所以hash冲突比较影响hash索引查询性能，尽量减少hash冲突。 ","date":"2022/04/12","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/:1:4","tags":["sql","索引","数据库","mysql"],"title":"mysql索引介绍","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"五、mysql索引拓展 4.1、主键索引和非主键索引的区别 基于MySQL的InnoDB引擎，要求表必须包含一个主键列的：如果在创建表的时候创建了主键，那么主键索引值就是这个主键列值；如果没有创建主键但创建了唯一键（唯一约束的列），那么主键索引值就是唯一键；如果都没有，就会系统默认生成6字节的rowid作为主键（用户不可见，rowid 随行记录的写入而递增）。主键索引生成的B+树的叶子节点存放整行的数据，非主键索引生成的B+树的叶子节点存放主键的值。 例如：下面这个表,且ID是主键。 主键索引和非主键索引的示意图如下： 主键索引和非主键索引的区别是：非主键索引的叶子节点存放的是主键的值，而主键索引的叶子节点存放的是整行数据，其中非主键索引也被称为二级索引（非聚簇索引：是指数据和索引是分开存放），而主键索引也被称为聚簇索引。(聚簇索引：是指数据和索引是一块存放) 根据这两种结构进行下查询，看看他们在查询上有什么区别。 1、如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。 2、如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为回表。(回表就是先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树) 3、如果查询语句 select id,k from table where k = 1,根据k可直接查到id,k两个列的值，直接返回结果即可，不需要从主键索引查询任何数据，此时叫做索引覆盖。（索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做索引覆盖） 问：为什么推荐使用整型的自增主键： 1、如果表使用自增主键 那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，主键的顺序按照数据记录的插入顺序排列，自动有序。当一页写满，就会自动开辟一个新的页(与B+树结构相关，如果是主键是递增的话，每次插入新的记录时，按大小是最大的，就会匹配到B+树的最右边的节点插入，不会影响左边的节点，减少了叶子节点的移动) 2、如果使用非自增主键（如果身份证号或学号等） 由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。 问：为什么非主键索引结构叶子结点存储的是主键值： 减少了出现行移动或者数据页分裂时二级索引的维护工作（当数据需要更新的时候，二级索引不需要修改，只需要修改聚簇索引，一个表只能有一个聚簇索引，其他的都是二级索引，这样只需要修改聚簇索引就可以了，不需要重新构建二级索引） 聚簇索引也称为主键索引，其索引树的叶子节点中存的是整行数据，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。因为索引（目录）只能按照一种方法进行排序。 非聚簇索引（普通索引）的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 4.2、联合索引的最左前缀原则 通常我们在建立联合索引的时候，也就是对多个字段建立索引，相信建立过索引的同学们会发现，无论是oralce还是mysql都会让我们选择索引的顺序，比如我们想在a,b,c三个字段上建立一个联合索引，我们可以选择自己想要的优先级，a、b、c,或者是b、a、c 或者是c、a、b等顺序。为什么数据库会让我们选择字段的顺序呢？不都是三个字段的联合索引么？这里就引出了数据库索引的最左前缀原理。 先举一个例子：如下图有这么一张表，列a是自增主键，除e为varchar其余为int类型，并创建了一个联合索引idx_t1_bcd(b,c,d)。 b、c、d三列作为联合索引，在B+树上的结构正如下图所示。对 b、c、d列 按照先后顺序进行排序： （1，1，4）、（1，5，4）、（5，3，6）、（12，14，3）、（13，12，4）、 （13，16，1）、（13，16，5） 之所以会有最左前缀匹配原则和联合索引的索引构建方式及存储结构是有关系的。 首先我们创建的index_bcd(b,c,d)索引，相当于创建了(b)、（b、c）（b、c、d）三个索引，看完下面你就知道为什么相当于创建了三个索引。 我们看，联合索引是首先使用多列索引的第一列构建的索引树，用上面idx_t1_bcd(b,c,d)的例子就是优先使用b列构建，当b列值相等时再以c列排序，若c列的值也相等则以d列排序。我们可以取出索引树的叶子节点看一下。 索引的第一列也就是b列可以说是从左到右单调递增的，但我们看c列和d列并没有这个特性，它们只能在b列值相等的情况下这个小范围内递增，如第一叶子节点的第1、2个元素和第二个叶子节点的后三个元素。 由于联合索引是上述那样的索引构建方式及存储结构，所以联合索引只能从多列索引的第一列开始查找。 1、查询语句是 select * from table where b=12 ，联合索引（b,c,d）有没有生效？生效了，因为 对应联合索引生成的B+树来说，b列的值是排序过的(叶子节点b列的值从左往右是：1，1，5，12，13，13，13 是有序的)，同理(b),(b,c)、（b、c、d）的组合也是排序过的，可以根据B+树进行快速查询 2、查询语句是 select * from table where c=12 ，联合索引（b,c,d）有没有生效？没生效，可以观察上图叶子节点，对于c列来看是无序的(叶子节点c列的值从左往右是：1，5，3，14，12，16，16 是无序的)，所以没法走B+树结构进行查询，同理 (c),(d),(b,d),(c,d)都是无效的 3、查询语句是 select * from table where c=12 and b=14,联合索引(b,c,d)有没有生效?生效了，仅等值无范围查询WHERE后面的条件只要一模一样，写在哪儿都是无所谓的。mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。相同环境下，生成的执行计划也是一样的 4、查询语句是 select * from table where b\u003e5 and c =14,联合索引(b,c,d)有没有生效?只有列b走索引查询，使用范围条件的时候，也会使用到该处的索引，但后面的索引都不会用到 5、查询语句是 select * from table where b=12 or c =14,联合索引(b,c,d)有没有生效?没生效，对于or条件是满足左边b=12 或者 右边 c=14，如果是 对 b和c列都有单独的索引，才能使索引生效 6、查询语句是select c from table where b=12 group by c ，联合索引(b,c,d)有没有生效？ 生效了，group by和order by 其实一样，也是遵从最左原则，可以看做继承where的条件顺序，但需要where作为基础铺垫，即没有where语句，单纯的group by | order by 也是不会使用任何索引的，并且需要和联合索引顺序一致才会使用索引。 4.3、唯一索引和唯一约束的区别 唯一约束和唯一索引在 MySQL 数据库里区别： 概念上不同，约束是为了保证数据的完整性，索引是为了辅助查询； 创建唯一约束时，会自动的创建唯一索引； 在理论上，不一样，在实际使用时，基本没有区别。 关于第二条，MySQL 中唯一约束是通过唯一索引实现的，为了保证没有重复值，在插入新记录时会再检索一遍，怎样检索快，当然是建索引了，所以，在创建唯一约束的时候就创建了唯一索引 4.4、索引失效场景 1、对索引使用左或者左右模糊匹配 当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。原因就是：因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。 假设我们要查询 name 字段前缀为「林」的数据，也就是 name like '林%'，扫描索引的过程： 首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询； 节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4； 节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。 如果使用 name like '%林' 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。 2、对索引使用函数 有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。 比如下面这条语句查询条件中对 name 字段使用了 ","date":"2022/04/12","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/:1:5","tags":["sql","索引","数据库","mysql"],"title":"mysql索引介绍","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"六、参考资料 ​ mysql索引数据结构 ​ 哈希索引 ​ 来吧！一文彻底搞定哈希表！ ​ 腾讯三面：你换一个角度跟我讲讲MySQL的B+树 ​ 为什么索引可以让查询变快？终于有人说清楚了！ ​ mysql索引底层数据结构 ​ MySql常见的索引优化和索引设计原则 ​ 纳尼？MySQL 中 count(*) 比 count(1) 快？ ​ MVCC 水略深，但是弄懂了真的好爽！ ​ 一文彻底搞懂MySQL基础：B树和B+树的区别 ​ MySQL索引背后的数据结构及算法原理 ​ 谈谈唯一约束和唯一索引 ​ 聚簇索引和非聚簇索引(通俗易懂 言简意赅) ​ 主键索引和非主键索引的区别 ​ mysql最左匹配原则 ​ 多个单列索引和联合索引的区别详解 ​ 联合索引在B+树上的存储结构及数据查找方式 ​ 面试官：聊聊索引失效？失效的原因是什么？ ​ Mysql索引查询失效的情况 ​ mysql联合索引对于group by order by的影响 ​ mysql关于or的索引问题 ​ 面试官：聊聊索引失效？失效的原因是什么？ ​ Mysql索引查询失效的情况 ​ mysql联合索引对于group by order by的影响 ​ mysql关于or的索引问题 ","date":"2022/04/12","objectID":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/:1:6","tags":["sql","索引","数据库","mysql"],"title":"mysql索引介绍","uri":"/posts/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"},{"categories":["数据库"],"content":"一条sql查询命令，从用户按下执行到返回结果，中间发生过什么？","date":"2022/04/12","objectID":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/","tags":["sql","数据库"],"title":"sql执行流程概述","uri":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"sql执行流程 ","date":"2022/04/12","objectID":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/:1:0","tags":["sql","数据库"],"title":"sql执行流程概述","uri":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"一、sql执行流程概述 作为编程的基础，少不了和数据库打交道。一般都知道sql的基本语法，包括表查询、删除、插入、创建等语句的使用，那么从sql脚本到最终返回结果，这中间有哪些流程呢？本着好奇心，了解一下sql执行流程。 根据上图，简要描述一下sql执行流程: 1、在打开客户端后，最初需要和sql服务器建立连接，账号认证和校验权限。 2、认证后，客户端发生查询sql脚本给服务器 3、服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。 4、服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。 5、MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。 6、将结果返回给客户端。 ","date":"2022/04/12","objectID":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/:1:1","tags":["sql","数据库"],"title":"sql执行流程概述","uri":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"二、mysql 组件 2.1、连接器 连接器：Client与Server建立连接、进行鉴权、保持连接、管理连接。 1、mysql -h ip -P port -u user -p password，建立连接后，连接器会到权限表中查出user拥有的权限，之后的权限判断逻辑，都依赖此时读取到的权限。 TIPS：如果该连接权限变更，但不重新登录，依然使用此次登录时的Session（测试环境已验证）可以继续进行操作。 2、mysql\u003e SHOW PROCESSLIST;，查看当前连接，如果连接长时间处于Sleep，到达wait_timeout，连接器会自动将连接主动断开。（Info 是正在执行的sql语句） 通过mysql\u003e SHOW GLOBAL VARIABLES LIKE ‘wait_timeout’;，可以查询当前server的wait_timeout时间，默认为8小时。 如果Client在断开连接后，继续发送请求，则会收到Lost connection to MySQL serve during query返回。 3、数据库中，长连接是指连接成功后，客户端持续有请求，则一直使用同一个连接；短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立。 使用长连接，会遇到MySQL内存飞涨（临时内存管理是在连接对象中创建）；如果长连接过多，会导致内存占用过大，发生OOM（Out Of Memory），导致MySQL重启。 解决因为长连接导致的OOM： 定期断开长连接； 程序判断执行占用内存大的查询后，断开连接； \u003e=5.7版本，通过mysql_reset_connection重新初始化连接资源。 2.2、查询缓存  MySQL查询缓存保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。 查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。 MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。 当判断缓存是命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。 当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。 有一点需要注意，MySQL并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL不会解析查询语句，所以也无法知道语句中是否有不确定的函数。 事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。 MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。 所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。 MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。 2.3、解析器 1、先通过词法分析： 从左到右一个字符、一个字符地输入，然后根据构词规则识别单词。 2、接下来，进行语法解析，判断输入的这个 SQL 语句是否满足 MySQL 语法. 根据MySQL 定义的语法规则，根据SQL 语句生成一个数据结构，这个数据结构我们把它叫做解析树（select_lex）。 语法解析主要是对SQL语句的语法进行检查，看看其是否合乎语法规则。如果服务器进程认为SQL语句不符合语法规则的时候，就会把这个错误信息反馈给客户端。在这个语法检查的过程中，不会对SQL语句中所包含的表名、列名等等进行检查，只是检查语法。 3、接下来进行语义解析： 若SQL 语句符合语法上的定义的话，则服务器进程接下去会对语句中涉及的表、索引、视图等对象进行解析，并对照数据字典检查这些对象的名称以及相关结构，看看这些字段、表、视图等是否在数据库中。如果表名与列名不准确的话，则数据库会就会反馈错误信息给客户端。 所以，有时候我们写select语句的时候，若语法与表名或者列名同时写错的话，则系统是先提示说语法错误，等到语法完全正确后再提示说列名或表名错误。 2.4、预处理器 1、即时 SQL ​ 一条 SQL 在 DB 接收到最终执行完毕返回，大致的过程如下： 1. 词法和语义解析； 2. 优化 SQL 语句，制定执行计划； 3. 执行并返回结果； 如上，一条 SQL 直接是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL）。 2、预处理 SQL 　但是，绝大多数情况下，某需求某一条 SQL 语句可能会被反复调用执行，或者每次执行的时候只有个别的值不同（比如 select 的 where 子句值不同，update 的 set 子句值不同，insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。 　所谓预编译语句就是将此类 SQL 语句中的值用占位符替代，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。 　预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。 注意： 　虽然可能是通过预处理 SQL 的方式一定程度的提高了效率，但是对于优化而言，最优的执行计划不是光靠 SQL 语句的模板化来实现的，往往还是需要通过具体值来预估出成本代价。 2.5、查询优化器 优化器的目的是按照一定原则来得到她认为的目标SQL在当前情形下最有效的执行路径,优化器的目的是为了得到目标SQL的执行计划。 传统关系型数据库里面的优化器分为CBO和RBO两种。 RBO— Rule_Based Potimizer 基于规则的优化器: RBO所用的判断规则是一组内置的规则，这些规则是硬编码在数据库的编码中的，RBO会根据这些规则去从SQL诸多的路径中来选择一条作为执行计划（比如在RBO里面，有这么一条规则：有索引使用索引。那么所有带有索引的表在任何情况下都会走索引）所以，RBO现在被很多数据库抛弃（oracle默认是CBO，但是仍然保留RBO代码，MySQL只有CBO） RBO最大问题在于硬编码在数据库里面的一系列固定规则，来决定执行计划。并没有考虑目标SQL中所涉及的对象的实际数量，实际数据的分布情况，这样一旦规则不适用于该SQL，那么很可能选出来的执行计划就不是最优执行计划了。 CBO—Cost_Based Potimizer 基于成本的优化器: CBO在会从目标诸多的执行路径中选择一个成本最小的执行路径来作为执行计划。这里的成本他实际代表了MySQL根据相关统计信息计算出来目标SQL对应的步骤的IO，CPU等消耗。也就是意味着数据库里的成本实际上就是对于执行目标SQL所需要IO,CPU等资源的一个估计值。而成本值是根据索引，表，行的统计信息计算出来的。(计算过程比较复杂) 2.6、执行计划 查询语句后，经过sql的优化器，会产生一个执行计划。根据MySQL执行计划的输出，分析索引使用情况、扫描的行数可以预估查询效率；进而可以重构SQL语句、调整索引，提升查询效率。 详细请参考链接：MySQL——执行计划 2.7、查询执行引擎 开始执行的时候，首先要确认我们是否有操作这个表的权限，如果没有权限则会返回没有权限的错误 mysql\u003eselect*fromTwhereID=10;ERROR1142(42000):SELECTcommanddeniedtouser'b'@'localhost'fortable'T' 如果有权限，就打开表权限执行，打开表的时候执行器会根据表的引擎定义，去使用这个引擎提供的接口。 比如在这个例子中的表T中的ID字段时没有索引的，那么执行器的流程是这样的： 用InnoDB引擎接口去扫描这个表的第一行，判断ID是否为10，如果不是则跳过，如果是则将这行存在结果集中 调用引擎接口取下一行，重复相同的逻辑判断，直到取到这个表的最后一行 执行器将上述便利过程的所有满足条件的行组成的记录集作为结果集返回给客户端 ","date":"2022/04/12","objectID":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/:1:2","tags":["sql","数据库"],"title":"sql执行流程概述","uri":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据库"],"content":"参考 MySQL探秘(二)：SQL语句执行过程详解 一条SQL语句在MySQL中执行过程全解析 sql的语句执行过程 「MySQL」 - SQL查询语句执行流程 SQL执行过程详解 sql语句的执行流程 MySQL查询语句完整语法解析 MySQL的SQL预处理(Prepared) MySQL查询语句完整语法解析 MySQL的SQL预处理(Prepared) mysql之优化器、执行计划、简单优化 ","date":"2022/04/12","objectID":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/:1:3","tags":["sql","数据库"],"title":"sql执行流程概述","uri":"/posts/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/"},{"categories":["数据治理"],"content":"如何创建数仓架构？如何创建数据模型？","date":"2022/02/11","objectID":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/","tags":["维度建模","数仓架构"],"title":"维度建模方法论","uri":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"categories":["数据治理"],"content":"维度建模方法 ","date":"2022/02/11","objectID":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/:1:0","tags":["维度建模","数仓架构"],"title":"维度建模方法论","uri":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"categories":["数据治理"],"content":"一、前言 本人学习《数仓工具箱》的学习总结，纯学习分享，供大家参考。 ","date":"2022/02/11","objectID":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/:1:1","tags":["维度建模","数仓架构"],"title":"维度建模方法论","uri":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"categories":["数据治理"],"content":"二、经典数仓架构理论 围绕着维度建模，那就不得不了解，早期的数据仓库构架方法。这里介绍一下两个经典的数仓架构理论。 2.1、Kimball模式 Kimball 模式从流程上看是是自顶向下的，即从数据集市到数据仓库再到数据源(先有数据集市再有数据仓库)的一种敏捷开发方法。对于Kimball模式，数据源每每是给定的若干个数据库表，数据较为稳定但是数据之间的关联关系比较复杂，须要从这些OLTP中产生的事务型数据结构抽取出分析型数据结构，再放入数据集市中方便下一步的BI与决策支持。所以KimBall是根据需求来确定需要开发ETL哪些数据。 2.2、Inmon模式 Inmon 模式从流程上看是自底向上的，即从数据源到数据仓库再到数据集市的（先有数据仓库再有数据市场）一种瀑布流开发方法。对于Inmon模式，数据源每每是异构的。这里主要的数据处理工作集中在对异构数据的清洗，包括数据类型检验，数据值范围检验以及其余一些复杂规则。在这种场景下，数据没法从stage层直接输出到dm层，必须先经过ETL将数据的格式清洗后放入dw层，再从dw层选择须要的数据组合输出到dm层。在Inmon模式中，并不强调事实表和维度表的概念，由于数据源变化的可能性较大，须要更增强调数据的清洗工作，从中抽取实体-关系。immon是将整个数据仓库规划好，统一按照范式建模进行开发。 参考：深入对比数据仓库模式：Kimball vs Inmon ","date":"2022/02/11","objectID":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/:1:2","tags":["维度建模","数仓架构"],"title":"维度建模方法论","uri":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"categories":["数据治理"],"content":"三、维度建模步骤 3.1、设计企业服务总线 需要调查业务过程以及业务过程所涉及的公共维度。比如零售商从订单到库存到零售这些业务过程中所涉及到的公共维度用一个矩阵进行统计，梳理这些的过程中，也对总体业务流程有概要的了解。 3.2、选择业务过程 业务过程通常用行为动词表示，如：获取订单、开具发票、接收付款，注册账号、处理索赔等。维度建模是紧贴业务的，所以必须以业务为根基进行建模，那么选择业务过程，顾名思义就是在整个业务流程中选取我们需要建模的业务，根据运营提供的需求及日后的易扩展性等进行选择业务。比如商城，整个商城流程分为商家端，用户端，平台端，运营需求是总订单量，订单人数，及用户的购买情况等，我们选择业务过程就选择用户端的数据，商家及平台端暂不考虑。业务选择非常重要，因为后面所有的步骤都是基于此业务数据展开的。 3.3、声明粒度 先举个例子：对于用户来说，一个用户有一个身份证号，一个户籍地址，多个手机号，多张银行卡，那么与用户粒度相同的粒度属性有身份证粒度，户籍地址粒度，比用户粒度更细的粒度有手机号粒度，银行卡粒度，存在一对一的关系就是相同粒度。为什么要提相同粒度呢，因为维度建模中要求我们，在同一事实表中，必须具有相同的粒度，同一事实表中不要混用多种不同的粒度，不同的粒度数据建立不同的事实表。并且从给定的业务过程获取数据时，强烈建议从关注原子粒度开始设计，也就是从最细粒度开始，因为原子粒度能够承受无法预期的用户查询。但是上卷汇总粒度对查询性能的提升很重要的，所以对于有明确需求的数据，我们建立针对需求的上卷汇总粒度，对需求不明朗的数据我们建立原子粒度。 3.4、确认维度 维度表是作为业务分析的入口和描述性标识，所以也被称为数据仓库的“灵魂”。在一堆的数据中怎么确认哪些是维度属性呢，如果该列是对具体值的描述，是一个文本或常量，某一约束和行标识的参与者，此时该属性往往是维度属性，牢牢掌握事实表的粒度，就能将所有可能存在的维度区分开，并且要确保维度表中不能出现重复数据，应使维度主键唯一 3.5、确认事实 可以通过回答“业务过程的度量是什么？”这一问题来确定事实。事实表是用来度量的，基本上都以数量值表示，事实表每行的数据是一个特定级别的细节数据，称为粒度。维度建模的核心原则之一是同一事实表中的所有度量必须具有相同的粒度。这样能确保不会出现重复计算度量的问题。有时候往往不能确定该列数据是事实属性还是维度属性。记住最实用的事实就是数值类型和可加类事实。所以可以通过分析该列是否是一种包含多个值并作为计算的参与者的度量，这种情况下该列往往是事实。 ","date":"2022/02/11","objectID":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/:1:3","tags":["维度建模","数仓架构"],"title":"维度建模方法论","uri":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"categories":["数据治理"],"content":"四、维度建模设计技巧 4.1、使用代理键代替自然键作为维度表主键 自然键：就是充当主键的字段本身具有一定的含义，是构成记录的组成部分，比如学生的学号，除了充当主键之外，同时也是学生记录的重要组成部分。 代理键：就是充当主键的字段本身不具有业务意义，只具有主键作用，比如自动增长的ID。 使用代理键的优点： 为数据仓库缓冲源系统的变化。例如：账号闲置一年就会重新分配给新用户，如果用账号作为数据主键，则原账号数据就会被覆盖丢失；如果用代理键作为维度主键，那么可以对账号的变化赋予新的代理键以作区分。 集成多个源系统。可以通过引用映射表将多个自然键连接成一个公共的代理键。 4.2、缓慢变化维度处理方法 类型0：不做任何处理 案例：用户在使用产品之前是有注册动作的，大部分产品都会让用户填写出生年月之类的属性信息，当然用户有可能是瞎写的，在未来的某个时间点可能想把这个出生信息给重新修改，站在分析的角度上，我们通常是使用第一次注册的数据，或者是使用身份证上的信息为准。那么对于这种持久型的标识符通常是不做任何处理的。 适用场景：这种处理手段适用于我们只关心第一次维度属性值的场景下，后续变化的值都认为是无效的。 类型1：重写覆盖 案例：在实际的业务过程中，用户是会更换手机号或者更改用户名的，那么站在分析的角度上来看，通常是只关心最新的数据，所以针对这种场景，我们可以采取覆盖的方式来解决，比如小明把用户名称改为小小明，那么从数据角度上来看的就变成了如下的方式： 适用场景：这适用于只关心最新数据的场景下，不需要关心属性历史信息变化；不用投入过多的etl成本，维护也比较简单 类型2：增加新行 案例：虽然重写覆盖的手段比较简单，但是其缺点也很明显，那就是我们没有办法分析历史变化的数据了，特别是像手机号这类的数据变更，是完全有必要把每次的变更记录保留下来，特别是对于风控业务，利用手机号通过图谱关系结合欺诈规则来拦截羊毛党、团伙欺诈等黑产。针对这类场景，我们可以采用新增记录的方式来解决。如下图所示，通过增加新行并分配新的代理键来保留维度的历史变化数据。 适用场景：该方案也是比较简单的一种处理方式，而且保留了历史信息变化的数据；但是该种方式在每变更一次就会新增一条记录，整个维表就会随着时间推移其数据也会越发膨胀，只要有一个维度发生变化，都会新增一行记录（当然一个维表里可以只对某几个属性变更采用类型2） 类型3：增加新列 案例：维度属性每次发生一次变更，我们通过新增一条记录的方式来保留历史数据，但其缺点也比较明显。对于数据量比较大的维度表来说，采用类型2就有些笨拙了，特别是对于属性指标分组的分析场景下就不太适用新增行记录的方式了。比如按照性别分组来分析活跃占比的时候，如果突然有一天的占比和历史分析结果相差比较大的时候，那么就需要定位判断是否有大量的属性变更的情况存在，针对这种情况可以采用新增列的方式来保留上一个变更版本的记录。如下图所示: 适用场景：避免了因为信息变化而新增记录造成数据膨胀的情况；而且可以允许保留一部分版本的变化，很多书籍中大多是新增一个当前列和上一次变化的列值，当然也可以多搞几个字段来保存多个版本，但不会把所有版本的数据都保留下来，而且如果维度信息比较多的话，那么字段就会变得非常多（比如表里有5个维度属性，需要保留3个版本，那这个表的字段数就会扩充到15个），所以这种处理手段很少用到，只适用于可以预测到变化而且不会分析过多版本的场景下（比如本案例中的男女占比分析）。 类型4：微型维度 案例：微型维度大概意思就是说对于变化比较快的维度（这个时候已经超出了缓慢变化的定义了）抽离出来形成一张单独的维表，那么抽离出来的这个维度表就被称为“微型维度”，说白了其实就是从大维表里把几个变化比较快的维度拿出来形成一个小的维度表（相对于原有维度来说确实是一个小维表）。比如在画像的场景中，我们通常会基于用户的收入属性运用一些规则定一个收入级别，并对用户打上一些标签，比如用户是属于高收入，高消费，还是属于低收入，高消费人群。通常收入属性可以说是变化比较频繁的(不要抬扛，特别是像拿提成的岗位收入本身就不是固定的)，如果直接放在基维表（基础维度表，可以理解成主维表）的话就会不太合适了。所以采用微型维度，将收入级别这类变化比较快的维度抽离出来单独搞一个小型维。这样一搞的话，就解决了基维表数据一旦变化就会新增记录的问题了。因为微型维度是框定了范围，在范围内的变化，都对应的同一个范围值，比如小明的年龄从20岁变化到22岁对应的微型维度代理键还是03。而且将维度维度代理键代替年龄范围、收入水平、消费水平三个快速变化的维度，在原有维表上减属性。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/f8918b4397f648f7a7fb52ac03ec7e7d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riF6aOO5ZKM5pyI5piO,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center) 适用场景：维度快速变化的情况，需要维护主表中对应的微型维度代理键 参考：建模之旅：你以为的SCD 4.3、树状结构数据处理 有些涉及多层级数据处理，比如对财务各级组织的相关指标计算。这就需对多层级数据处理。如下图，模拟的是集团中的组织架构，举例：怎么计算7和7所有的下属机构对应的月营收收入？ 这里可以建立多层级组织关系桥接表，如下图。通过这个桥接表来筛选出7的所有下属机构。 ","date":"2022/02/11","objectID":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/:1:4","tags":["维度建模","数仓架构"],"title":"维度建模方法论","uri":"/posts/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"categories":["大数据技术"],"content":"全面介绍了hdfs是什么？怎么用？什么原理？","date":"2021/04/15","objectID":"/posts/hdfs/","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"HDFS ","date":"2021/04/15","objectID":"/posts/hdfs/:0:0","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"一、HDFS概述 ","date":"2021/04/15","objectID":"/posts/hdfs/:1:0","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"1.1、HDFS产生背景 随着数据量越来越大，在一个操作系统存不下所有的数据，那么就分配到更多的操作系统管理的磁盘中，但是不方便管理和维护，迫切需要==一种系统来管理多台机器上的文件==，这就是==分布式文件管理系统==。==HDFS 只是分布式文件管理系统中的一种。== ","date":"2021/04/15","objectID":"/posts/hdfs/:1:1","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"1.2、HDFS概念 HDFS（Hadoop Distributed File System），它是一个文件系统，用于存储文件，通过目录树来定位文件；其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。 HDFS 的使用场景：适合一次写入，多次读出的场景。一个文件经过创建、写入和关闭之后就不需要改变。 ","date":"2021/04/15","objectID":"/posts/hdfs/:1:2","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"1.3、HDFS优缺点 1.3.1、HDFS优点 高容错性 数据会备份多个副本（默认备份3份），当其中一份数据副本丢失，HDFS会自动恢复备份。 适合处理大数据 ​ 数据规模：能够处理数据规模达到GB、TB、甚至PB级别的数据； ​ 文件规模：能够处理百万规模以上的文件数量，数量相当之大。 ）==可构建在廉价机器上==，通过多副本机制，提高可靠性。 1.3.2、HDFS缺点 不适合低延时数据访问， 像mysql快速的增删改查 无法高效的对大量小文件进行存储。 存储大量小文件的话，它会占用NameNode大量的内存来存储文件目录和块信息。这样是不可取的，因为NameNode的内存总是有限的； 小文件存储的寻址时间会超过读取时间，它违反了HDFS的设计目标。 不支持并发写入、文件随机修改。 一个文件只能有一个写，不允许多个线程同时写； 仅支持数据append（追加），不支持文件的随机修改。 ","date":"2021/04/15","objectID":"/posts/hdfs/:1:3","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"1.4、HDFS组成架构 NameNode（nn）：就是Master，它是一个主管、管理者。 （1）管理HDFS的名称空间； （2）配置副本策略； （3）管理数据块（Block）映射信息； （4）处理客户端读写请求。 DataNode：就是Slave。NameNode下达命令，DataNode执行实际的操作。 （1）存储实际的数据块； （2）执行数据块的读/写操作。 Client：就是客户端。 （1）文件切分。文件上传HDFS的时候，Client将文件切分成一个一个的Block，然后进行上传； （2）与NameNode交互，获取文件的位置信息； （3）与DataNode交互，读取或者写入数据； （4）Client提供一些命令来管理HDFS，比如NameNode格式化； （5）Client可以通过一些命令来访问HDFS，比如对HDFS增删查改操作； Secondary NameNode（2nn）：并非NameNode的热备。当NameNode挂掉的时候，它并不能马上替换NameNode并提供服务。 （1）辅助NameNode，分担其工作量，比如定期合并Fsimage和Edits，并推送给NameNode ； （2）在紧急情况下，可辅助恢复NameNode ","date":"2021/04/15","objectID":"/posts/hdfs/:1:4","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"1.5、文件块大小 HDFS中的文件在物理上是分块存储（Block），块的大小可以通过配置参数( dfs.blocksize）来规定，默认大小在Hadoop2.x/3.x版本中是==128M==，1.x版本中是==64M==。 为什么块的大小不能设置太小，也不能设置太大？ （1）HDFS的块设置太小，会增加寻址时间，程序一直在找块的开始位置； ​ 例如：一个块1kb，一个100kb的文件需要切成100块，读取这个文件时需要找到这100个块，寻找数据块的时间大大增加 （2）如果块设置的太大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。导致程序在处理这块数据时，会非常慢 ​ 例如：一个块1GB，一个100kb的文件存储，读取文件时需要在1GB 磁盘里读取数据（相当于读取1GB的数据量）。 ","date":"2021/04/15","objectID":"/posts/hdfs/:1:5","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"二、HDFS的Shell操作（开发重点） ","date":"2021/04/15","objectID":"/posts/hdfs/:2:0","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"2.1 基本语法 ​ hadoop fs 具体命令 （或者）hdfs dfs 具体命令 ","date":"2021/04/15","objectID":"/posts/hdfs/:2:1","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"2.2、常用命令 2.2.1、上传 -moveFromLocal：从本地剪切粘贴到 HDFS hadoop fs -moveFromLocal 本地文件路径 HDFS文件路径 #举例 hadoop fs -moveFromLocal ./test1.txt /output -copyFromLocal:从本地文件系统中拷贝文件到 HDFS 路径去 hadoop fs -copyFromLocal 本地文件路径 HDFS文件路径 #举例 hadoop fs -copyFromLocal ./test2.txt /output -put：等同于 copyFromLocal，==生产环境更习惯用 put== hadoop fs -put 本地文件路径 HDFS文件路径 #举例 hadoop fs -put ./test3.txt /output -appendToFile：追加一个文件到已经存在的文件末尾 hadoop fs -appendToFile 本地文件路径 HDFS文件路径 #举例 hadoop fs -appendToFile ./test4.txt /output/test3.txt 2.2.2、下载 -copyToLocal：从 HDFS 拷贝到本地 hadoop fs -copyToLocal HDFS文件路径 本地文件路径 #举例 hadoop fs -copyToLocal /output/test3.txt ./ -get：等同于 copyToLocal，==生产环境更习惯用 get== hadoop fs -put HDFS文件路径 本地文件路径 #举例 hadoop fs -put /output/test3.txt ./ 2.2.3 HDFS直接操作 -ls: 显示目录信息 hadoop fs -ls HDFS文件路径 #举例 hadoop fs -ls / -cat：显示文件内容 hadoop fs -cat HDFS文件路径 #举例 hadoop fs -cat /output/test3.txt -chgrp、-chmod、-chown：Linux 文件系统中的用法一样，修改文件所属权限 hadoop fs -chmod 666 /output/test3.txt -mkdir：创建文件夹 hadoop fs -mkdir /output/aaa -cp：从 HDFS 的一个路径拷贝到 HDFS 的另一个路径 hadoop fs -cp /output/test3.txt /tmp -mv：在 HDFS 目录中移动文件 hadoop fs -cp /tmp/test3.txt /output/aaa -tail：显示一个文件的末尾 1kb 的数据 hadoop fs -tail /output/test3.txt -rm：删除文件或文件夹 hadoop fs -rm /tmp/test3.txt -rm -r：递归删除目录及目录里面内容 hadoop fs -rm -r /tmp -du 统计文件夹的大小信息 hadoop fs -du -h /output hadoop fs -du -s /output -setrep：设置 HDFS 中文件的副本数量 hadoop fs -setrep 10 /output/test3.txt 这里设置的副本数只是记录在 NameNode 的元数据中，是否真的会有这么多副本，还得看 DataNode 的数量。因为目前只有 3 台设备，最多也就 3 个副本，只有节点数的增加到 10台时，副本数才能达到 10 ","date":"2021/04/15","objectID":"/posts/hdfs/:2:2","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"三、HDFS读写流程 ","date":"2021/04/15","objectID":"/posts/hdfs/:3:0","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"3.1、HDFS写数据流程 客户端向NameNode 请求上传文件 /usr/data/data1 NameNode 检查客户端有没有权限写入数据，检查目录 文件是否已经存在 ，如果有权限且文件不存在，则响应客户端可以上传文件 客户端请求上传第一个block(0~128M 数据块) ，请返回DataNode NameNode 通过节点距离计算和负载均衡得出存储的节点，返回存放数据的3个DataNode 节点 dn1、dn2、dn3 客户端通过 FSDataOutputStream 模块请求 dn1 上传数据，dn1 收到请求会继续调用dn2，然后 dn2 调用 dn3，将这个通信管道建立完成。 dn1、dn2、dn3 逐级应答客户端,通知客户端可以传数据 客户端开始往 dn1 上传第一个 Block（先从磁盘读取数据放到一个本地内存缓存），以 Packet 为单位（大小64k），dn1 收到一个 Packet 就会传给 dn2，dn2 传给 dn3；dn1 每传一个 packet会放入一个应答队列等待应答 当一个 Block 传输完成之后，客户端再次请求 NameNode 上传第二个 Block 的服务器。（重复执行 3-7 步）。 ","date":"2021/04/15","objectID":"/posts/hdfs/:3:1","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"3.2、网络拓扑-节点距离计算 在 HDFS 写数据的过程中，NameNode 会选择距离待上传数据最近距离的 DataNode 接 收数据。那么这个最近距离怎么计算呢？ 节点距离：两个节点到达最近的共同祖先的距离总和。 理解： 节点1——机架1——集群1—数据总部 ，走过3个节点 ​ 节点2——机架2——集群2——数据总部 ， 走过3个节点，那么节点1和节点2距离为6 ","date":"2021/04/15","objectID":"/posts/hdfs/:3:2","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"3.3、机架感知（副本存储节点选择） 第一个副本在Client所处的节点上。如果客户端在集群外，随机选一个。 第二个副本在另一个机架的随机一个节点。 第三个副本在第二个副本所在机架的随机节点。 ","date":"2021/04/15","objectID":"/posts/hdfs/:3:3","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"3.4、HDFS读数据流程 客户端通过 DistributedFileSystem 向 NameNode 请求下载文件，NameNode 通过查询元数据，找到文件块所在的 DataNode 地址。 挑选一台 DataNode（就近原则，然后随机）服务器，请求读取数据。 DataNode 开始传输数据给客户端（从磁盘里面读取数据输入流，以 Packet 为单位来做校验）。 客户端以 Packet 为单位接收，先在本地缓存，然后写入目标文件。 ","date":"2021/04/15","objectID":"/posts/hdfs/:3:4","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"三、NameNode 和 SecondaryNameNode ","date":"2021/04/15","objectID":"/posts/hdfs/:4:0","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"3.1、NN和2NN工作机制 思考：NameNode 中的元数据是存储在哪里的？ 首先，我们做个假设，如果存储在 NameNode 节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生在磁盘中备份元数据的FsImage。 这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新 FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦 NameNode 节点断电，就会产生数据丢失。**因此，引入 Edits 文件（只进行追加操作，效率很高）。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到 Edits 中。**这样，一旦 NameNode 节点断电，可以通过 FsImage 和 Edits 的合并，合成元数据。 但是，如果长时间添加数据到 Edits 中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行 FsImage 和 Edits 的合并，如果这个操作由NameNode节点完成，又会效率过低。因此，引入一个新的节点SecondaryNamenode，专门用于 FsImage 和 Edits 的合并。 第一阶段： NameNode 启动 第一次启动 namenode 格式化后，创建 fsimage 和 edits （在 namenode 所在结点的 hadooop/data 目录下）文件。如果不是第一次启动，直接加载编辑日志edits_inprogress_001和镜像文件fsimage 到内存。 客户端对元数据进行增删改的请求 namenode 记录操作日志edits_inprogress_001 namenode 在内存中对数据进行删改 第二阶段： Secondary NameNode 工作 Secondary NameNode 询问 namenode 是否需要 checkpoint 。直接带回 namenode 是否检查结果。 Secondary NameNode 请求执行 checkpoint 。 namenode 滚动正在写的 edits 日志（将正在使用编辑的编辑日志edits_inprogress_001改名edits_001，并使用edits_inprogress_002作为记录操作新的编辑日志） 将滚动前的编辑日志edits_001和镜像文件fsimage 拷贝到 Secondary NameNode Secondary NameNode 加载编辑日志和镜像文件fsimage 到内存，并合并。 生成新的镜像文件 fsimage.chkpoint 拷贝 fsimage.chkpoint 到 namenode namenode 将 fsimage.chkpoint 重新命名成 fsimage，原先的fsimage作为历史文件保留 ","date":"2021/04/15","objectID":"/posts/hdfs/:4:1","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"3.2、Fsimage 和Edits NameNode被格式化之后，将在/opt/module/hadoop-3.1.3/data/tmp/dfs/name/current目录中产生如下文件 fsimage_0000000000000000000 fsimage_0000000000000000000.md5 seen_txid VERSION （1）Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目 ​ 录和文件inode的序列化信息。 （2）Edits文件：存放HDFS文件系统的所有更新操作的路径，文件系统客户端执行的所有写操作首先 ​ 会被记录到Edits文件中。 （3）seen_txid文件保存的是一个数字，就是最后一个edits_的数字 （4）每 次NameNode启动的时候都会将Fsimage文件读入内存，加 载Edits里面的更新操作，保证内存 中的元数据信息是最新的、同步的，可以看成NameNode启动的时候就将Fsimage和Edits文件进行了合 并。 ","date":"2021/04/15","objectID":"/posts/hdfs/:4:2","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"四、DataNode工作机制 ","date":"2021/04/15","objectID":"/posts/hdfs/:5:0","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"4.1、DataNode 工作机制 一个数据块在 DataNode 上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。 DataNode 启动后向 NameNode 注册，通过后，周期性（6 小时）的向 NameNode 上报所有的块信息。（向NameNode汇报文件状态有没有损毁） ​ DN 向 NN 汇报当前解读信息的时间间隔，默认 6 小时； ​ DN 扫描自己节点块信息列表的时间，默认 6 小时 心跳是每 3 秒一次，心跳返回结果带有 NameNode 给该 DataNode 的命令如复制块数据到另一台机器，或删除某个数据块。如果超过 10 分钟没有收到某个 DataNode 的心跳，则认为该节点不可用。（向NameNode汇报DataNode的状态，是否挂掉，如果10分钟内没有反馈，则认为DataNode 不存在，不会再和这个DataNode通信） ","date":"2021/04/15","objectID":"/posts/hdfs/:5:1","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"4.2、数据完整性 奇偶校验： 数据： 0100 0001 1的个数是2 是偶数 奇偶校验位为0 收到的传输数据进行奇偶校验，如果1的个数奇偶和奇偶校验位一致，则认为数据是完整的 hadoop 采用 crc（32），常见的校验算法还有 md5（128），sha1（160） 都是对数据按一定算法得出的结果和校验位进行比较，判断数据是否完整 ","date":"2021/04/15","objectID":"/posts/hdfs/:5:2","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"4.4、掉线时限参数设置 如果定义超时时间为TimeOut，则超时时长的计算公式为： TimeOut = 2 * dfs.namenode.heartbeat.recheck-interval + 10 * dfs.heartbeat.interval。 而默认的dfs.namenode.heartbeat.recheck-interval 大小为5分钟，dfs.heartbeat.interval默认为3秒。 hdfs-site.xml 配置文件中的 heartbeat.recheck.interval 的单位为毫秒，dfs.heartbeat.interval 的单位为秒。 \u003cproperty\u003e \u003cname\u003edfs.namenode.heartbeat.recheck-interval\u003c/name\u003e \u003cvalue\u003e300000\u003c/value\u003e \u003c/property\u003e \u003cproperty\u003e \u003cname\u003edfs.heartbeat.interval\u003c/name\u003e \u003cvalue\u003e3\u003c/value\u003e \u003c/property\u003e dfs.heartbeat.interval。 而默认的dfs.namenode.heartbeat.recheck-interval 大小为5分钟，dfs.heartbeat.interval默认为3秒。 hdfs-site.xml 配置文件中的 heartbeat.recheck.interval 的单位为毫秒，dfs.heartbeat.interval 的单位为秒。 \u003cproperty\u003e \u003cname\u003edfs.namenode.heartbeat.recheck-interval\u003c/name\u003e \u003cvalue\u003e300000\u003c/value\u003e \u003c/property\u003e \u003cproperty\u003e \u003cname\u003edfs.heartbeat.interval\u003c/name\u003e \u003cvalue\u003e3\u003c/value\u003e \u003c/property\u003e ","date":"2021/04/15","objectID":"/posts/hdfs/:5:3","tags":["hdfs"],"title":"hdfs学习文档","uri":"/posts/hdfs/"},{"categories":["大数据技术"],"content":"从如何使用虚拟机创建hadoop环境，到部署多服务器集群，是一份入门级指导文档","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"Hadoop入门 一、概念 二、环境准备 三、Hadoop生产集群搭建 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:0:0","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"一、概念 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:1:0","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"1.1、Hadoop是什么 Hadoop 是一个由Apache基金会所开发的分布式系统基础架构 。 主要解决海量数据的存储和海量数据的分析计算问题 广义上来说，Hadoop 通常是指一个更广泛的概念———Hadoop生态圈(HBase、Hive等) ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:1:1","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"1.2 、Hadoop发展历史 Hadoop创始人 Doug Cutting ，为了实现与 Google类似的全文搜索功能，在Lucene框架基础上进行优化升级，查询引擎和索引引擎。 2001年年底Lucene成为Apache基金会的一个子项目。 对于海量数据场景，Lucene框架面对与Google同样的困难，存储海量数据困难，检索海量数据慢。 学习和模仿Google解决这些问题的办法：微型版 Nutch。 参考Google在大数据的三篇论文（GFS—\u003eHDFS ，Map-Reduce—\u003eMR ，BigTable—\u003eHBase ）。 2003-2004年，Google公开了部分GFS和MapReduce思想的细节，以此为基础Doug Cutting等人用了2年业余时间实现了DFS和MapReduce机制，使Nutch性能飙升。 2005年Hadoop作为Lucene的子项目Nutch的一部分正式引入Apache基金会。 2006年3月，Map-Reduce和Nutch Distributed File System (NDFS) 分别纳入到Hadoop项目中，Hadoop就此正式诞生，标志着大数据时代来临。 logo来源于Doug Cutting儿子的玩具大象 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:1:2","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"1.3 Hadoop三大发行版本 Hadoop 三大发行版本： Apache 、Cloudera 、Hortonworks 。 Apache 版本最原始（最基础)的版本，对入门学习最好（2006年）。 Cloudera 在Apache版本基础上集成了很多大数据框架，对应的产品CDH（2008年）。 Hortonworks 文档较好，对应产品HDP（2011年）。 Hortonworks 被Cloudera 收费，推出CDP（2018年）。 两家公司都是在Apache的基础上进行集成功能，提高用户体验，借此收费，最终合并联手。 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:1:3","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"1.4、Hadoop优势 高可靠性：Hadoop 底层数据有多个备份，所以即使Hadoop某个数据存储或计算出现故障，也不会导致数据丢失。 高扩展性：动态增加、减少服务器，在集群间分配任务数据，可方面的扩展数以千计的节点。 高效性：在MapReduce 的思想下，Hadoop是==并行工作==的，加快任务处理速度。 高容错性：能自动将失败的任务重新分配。 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:1:4","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"1.5、Hadoop组成（面试重点） 1.5.1、Hadoop1.x、2.x、3.x 区别 Hadoop1.x 组成： Common(辅助工具) + HDFS（数据存储） + ==MapReduce(计算+资源调度)== Hadoop2.x 组成： Common(辅助工具) + HDFS（数据存储） + ==Yarn(资源调度) + MapReduce(计算)== Hadoop3.x 组成和Hadoop2.x 没有区别 1.5.2、HDFS架构概述 ​ Hadoop Distributed File System ， 简称HDFS，是一个分布式文件系统。 NameNode: 存储文件的元数据，如文件名、文件目录结构、文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。 DataNode：在本地文件系统存储文件块数据，以及块数据的校验和 Secondary NameNode (2NN)：每隔一段时间对NameNode元数据备份 理解：NameNode记录了数据存储信息，DataNode就是数据存储块，2NN是对NameNode的备份，以防止NameNode的丢失情况 1.5.3、YARN架构概述 YetAnother Resource Negotiator 简称YARN，另一种资源协调者，是Hadoop的资源管理器。 ResourceManager（RM）：整个集群**资源（内存、cpu等）**的管理者 NodeManager（NM）：单个节点服务器资源的管理者 ApplicationMaster（AM）：单个任务运行的管理者 Container：容器，相当于一台独立的服务器，里面封装了任务运行所需要的资源，如内存，CPU、磁盘、网络等（将一个计算资源虚拟划分多个容器，并分配好内存、CPU、磁盘、网络等） 说明：客户端可以有多个，集群上可以运行多个ApplicationMaster，每个NodeManager上可以有多个Container 理解：ApplicationMaster根据任务运行资源需要向ResourceManager申请对应的资源，ResourceManager分配一个NodeManager并在NodeManager划分出满足任务资源需要的容器，任务完成后，删除容器，释放对应资源，能灵活分配集群资源 1.5.4、MapReduce 架构概述 Map阶段：并行处理输入数据 Reduce阶段：对Map结果进行汇总 理解：将待分析的数据划分成N分，分配给多个服务器进行计算，再将各个计算结果进行汇总 1.5.5、HDFS 、YARN、MapReduce 三者关系 首先，通过数据采集获取海量数据需要HDFS来存储，当查询或计算这些海量数据时，需要先给查询或计算任务分配CPU、内存等资源，并将大量的输入数据进行拆分，分给多个服务器并行计算，最终将结果汇总。 1.6、大数据生态体系 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:1:5","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"二、Hadoop运行环境搭建 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:2:0","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"2.1、前期环境准备 VMware 虚拟机安装 CentOS7 安装（都可以百度有对应的教程） 2.1.1、配置虚拟机网络 ​ 打开 编辑–》虚拟网络编辑器 ​ 选择 删除VMnet 8 ，添加新网络VMnet2， 选择NAT模式，NET设置修改网关（不建议），DHCP设置修改分配的IP地址（虚拟机设置的IP必须要在这个范围内）一般是 xxx.xxx.xxx.3~254 在Windows下，打开网络和Internet设置—》更改网络配置—-》更改适配器选项–》找到VMnet2(刚才添加的信网络)—》点击属性—》选择Internet协议版本4（TCP\\IPv4） 设置IP地址，子网掩码，默认网关，首选DNS服务器和网关一样，备选DNS服务器国际默认8.8.8.8 在VMware ，点击网络适配器，选择自定义，选择新建的网络VMnet2 登入虚拟机，编辑网络配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33 ，内容如下，编辑后重启或 执行source /etc/sysconfig/network-scripts/ifcfg-ens33命令 TYPE=\"Ethernet\" PROXY_METHOD=\"none\" BROWSER_ONLY=\"no\" #设置为静态ip,默认是dchp,动态分配ip地址 BOOTPROTO=\"static\" DEFROUTE=\"yes\" IPV4_FAILURE_FATAL=\"no\" IPV6INIT=\"yes\" IPV6_AUTOCONF=\"yes\" IPV6_DEFROUTE=\"yes\" IPV6_FAILURE_FATAL=\"no\" IPV6_ADDR_GEN_MODE=\"stable-privacy\" NAME=\"ens33\" UUID=\"b400b844-2c25-4434-8f17-1da5faf08353\" DEVICE=\"ens33\" ONBOOT=\"yes\" #设置网络IP地址，网关，DNS服务器地址 IPADDR=\"192.168.75.100\" GATEWAY=\"192.168.75.2\" DNS1=\"192.168.75.2\" 验证是否完成配置，ping www.baidu.com ，如果能接收数据就表示成功完成网络配置 ps:不要通过克隆来创建其他虚拟机，会出现网络bug,直接从最初镜像或干净的虚拟机进行同步 2.1.2、配置主机名 登入linux，编辑主机名称，vi /etc/hostname 修改主机名称映射（在本机中自动将相应的字符转为ip地址，如localhost 对应127.0.0.0） vi /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 #添加下列信息 192.168.75.100 Hadoop100 192.168.75.101 Hadoop101 192.168.75.102 Hadoop102 192.168.75.103 Hadoop103 重启系统 （或者用source 命令） 2.1.3、安装epel-release Extra Packages for Enterprise Linux 是红帽系的操作系统提供额外的软件包，适用于RHEL 、CentOS 和 Scientific Linux。相当于是一个软件仓库，大多数rpm包在官方repository是找不到的 yum install -y epel-release 如果Linux系统安装的是最小系统版，还需要配置如下工具： net-tools:工具包集合，包含ifconfig等命令 yum install -y net-tools vim 编辑器 yum install -y vim 2.1.4 关闭防火墙、关闭防火墙开机自启 一般公司对外网的入口建防火墙，内部服务器不建防火墙 systemctl stop firewalld systemctl disable firewalld.service 2.1.5、 卸载虚拟机自带的JDK ==如果是虚拟机最小化安装不需要执行这一步== #查询所安装的所有rpm软件包 rpm -qa #忽略大小写过滤 grep -i #表示每次只传递一个参数 xargs -n1 #强制卸载软件 rpm -e --nodeps #完整命令 rpm -qa |grep -i java |xargs -n1 rpm -e --nodeps ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:2:1","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"2.2、远程访问工具 xshell+xftp （或）putty + WinSCP 安装教程自行百度 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:2:2","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"2.3、克隆虚拟机(不推荐，可以用下面的同步更新脚本) 1、打开VMware，选择要克隆的模板机，右键管理，克隆，选择创建完整性克隆 2、设置克隆机的ip地址和主机名，参考上面的方法（如果克隆的是已经配置好的linux系统，则只需修改 /etc/sysconfig/network-scripts/ifcfg-ens33 和 /etc/hostname ） ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:2:3","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"2.4、安装JDK 1、XFTP软件将JDK的压缩包传输到 /opt/software/目录下 2、解压压缩包： cd /opt/software/ tar -zxvf jdk-8u161-linux-x64.tar.gz -C /opt/module/ 3、配置环境变量 cd /etc/profile.d #创建my_env.sh 文件 vi my_env.sh 在 my_env.sh 文件添加如下内容 #JAVA_HOME export JAVA_HOME=/opt/module/jdk1.8.0_161 export CLASSPATH=$:CLASSPATH:$JAVA_HOME/lib/ export PATH=$PATH:$JAVA_HOME/bin 重新启动配置文件 source /etc/profile #验证是否配置完成 java ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:2:4","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"2.5、安装Hadoop 1、XFTP软件将Hadoop的压缩包传输到 /opt/software/目录下 2、解压压缩包： cd /opt/software/ tar -zxvf hadoop-2.7.3.tar.gz -C /opt/module/ 3、配置环境变量 cd /etc/profile.d 在 my_env.sh 文件添加如下内容 #HADOOP_HOME export HADOOP_HOME=/opt/module/hadoop-2.7.3 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 重新启动配置文件 source /etc/profile #验证是否配置完成 hadoop ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:2:5","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"2.6、Hadoop 文件目录说明 bin: 存储hdfs、yarn、mapred 相关命令 etc: 存储重要的配置文件 sbin: 集群相关命令 share: 学习资料，有一些官方的资料 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:2:6","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"三、Hadoop集群配置 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:0","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.1、Hadoop运行模式 本地模式：单台服务器，数据存储在linux本地 伪分布式：单台服务器，数据存储在HDFS 分布式： 多台服务器,数据存储在HDFS，多台服务器工作 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:1","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.2、本机模式案例–统计单词出现的个数 cd /opt/module/hadoop-2.7.3 mkdir wcinput vi word.txt #编辑输入若干个单词如下 # qtds ppx tthy # ppx qtds dmxy # qtds #调用hadoop 命令执行统计单词数量 #输出目录wcoutput 会自动生成，不需要创建 输入数据文件的目录 wcinput/ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount wcinput/ wcoutput #查看输出结果 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:2","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.3、编写集群分发脚本 xsync 3.3.1、scp (secure copy) 安全拷贝 （1）scp定义 ​ scp 可以实现服务器与服务器之间的数据拷贝 （2）基本语法 ​ scp -r 要拷贝的文件路径/名称 目的地用户@主机：目的地路径/名称 ​ -r 文件递归 在hadoop100 机器上将文件拷贝给hadoop102 scp -r /opt/software/hadoop-2.7.3.tar.gz root@hadoop102:/opt/module/ 在hadoop102机器上从hadoop100拿取文件 scp -r root@hadoop100:/opt/software/hadoop-2.7.3.tar.gz /opt/software/ 在hadoop102机器上从hadoop100机器传输文件到hadoop103机器 scp -r root@hadoop100:/opt/software/* root@hadoop103:/opt/software/ 3.3.2、rsync 远程同步工具 rsync主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。 rsync和scp区别：用rsync做文件的复制要比scp速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。 （1）rsync 基本语法 **rsync -av 要拷贝的文件路径/名称 目的地用户@主机：目的地路径/名称** **-a 归档拷贝** **-v 显示复制过程** 如果没有rsync 命令，则需下载 yum -y install rsync 在hadoop102删除部分文件 从hadoop100机器同步Hadoop-2.7.3文件到hadoop102机器 rsync -a root@hadoop100:/opt/module/hadoop-2.7.3/* /opt/module/hadoop-2.7.3/ 3.3.3、 xsync 集群分发脚本 需求：循环复制文件到所有节点的目录下 需求分析： rsync 原始拷贝文件 脚本要同步文件名 脚本要在任何地方都能使用（脚本放在了声明全局变量的路径） 在 /etc/profile.d/my_env.sh 编辑添加脚本的全局路径，编辑好后，执行 source /etc/profile 命令 #XSYNC_HOME export XSYNC_HOME=/root export PATH=$PATH:$XSYNC_HOME/bin 实现脚本xsync： #!/bin/bash #1. 判断参数个数 if [ $# -lt 1 ] then echo Not Enough Arguement! exit; fi #2. 遍历集群所有机器 for host in hadoop102 hadoop103 hadoop104 do echo ==================== $host ==================== #3. 遍历所有目录，挨个发送 for file in $@ do #4. 判断文件是否存在 if [ -e $file ] then #5. 获取父目录 pdir=$(cd -P $(dirname $file); pwd) #6. 获取当前文件的名称 fname=$(basename $file) ssh $host \"mkdir -p $pdir\" rsync -av $pdir/$fname $host:$pdir else echo $file does not exists! fi done done 示例，将hadoop100机器 /etc/profile.d/ 下的文件进行同步到hadoop102上 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:3","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.4、SSH免密登录 3.4.1、原理 有两台服务器A和B ，在A服务器上创建一对密钥（公钥和私钥），注意：私钥始终掌握在本机手中，不能传给其他服务器，否则会将服务器完全暴露给其他机器 把公钥拷贝给服务器B，服务器B将公钥放在授权文件里 当服务器A ssh 访问服务器B时(数据用私钥加密) 服务器B 接收到数据后，去授权文件中查找服务器A的公钥，并解密数据 服务器B用服务器A的公钥加密数据返回给服务器A 用服务A公钥加密的数据，只能通过服务器A的私钥解密 3.4.2 、举例 在hadoop102机器上生成密钥对 #切换到用户目录下的.ssh目录 #如果没有.ssh目录，则需要用ssh 命令登入一下其他机器 cd /root/.ssh/ #生成密钥对 ssh-keygen -t rsa #然后敲（三个回车），就会生成两个文件 id_rsa（私钥）、id_rsa.pub（公钥） 将hadoop102机器的公钥 拷贝给hadoop100 ssh-copy-id hadoop100 在hadoop102就可以免密登入hadoop100了 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:4","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.5、集群配置 3.5.1、配置方案 hadoop100 Hadoop102 hadoop103 HDFS ==NameNode== DataNode DataNode ==2NN== DataNode YARN NodeManager ==ResourceManger== NodeManager NodeManager ​ 备注：1、NameNode 和 2NN ，不要安装在同一台服务器 ​ 2、ResourceManager也很消耗内存，不要和NameNode 和 2NN 配置在同一服务器 3.5.2、配置文件说明 ​ Hadoop 配置文件分两类，默认配置文件和自定义配置文件，==只有用户想修改某一默认配置时才需要修改自定义配置文件== 默认配置文件 /opt/module/hadoop-2.7.3/share/hadoop 目录下 要获取的默认文件 文件存放在 Hadoop 的 jar 包中的位置 core-default.xml hadoop-common-2.7.3.jar/core-default.xml hdfs-default.xml hadoop-hdfs-2.7.3.jar/hdfs-default.xml yarn-default.xml hadoop-yarn-common-2.7.3.jar/yarn-default.xml mapred-default.xml hadoop-mapreduce-client-core-2.7.3.jar/mapred-default.xml 自定义配置文件 /opt/module/hadoop-2.7.3/etc/hadoop 目录下 core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml 四个配置文件 3.5.3、配置集群 配置 core-site.xml，添加如下内容 vi /opt/module/hadoop-2.7.3/etc/hadoop/core-site.xml \u003cconfiguration\u003e \u003c!-- 指定 NameNode 的地址 --\u003e \u003cproperty\u003e \u003cname\u003efs.defaultFS\u003c/name\u003e \u003cvalue\u003ehdfs://hadoop100:8020\u003c/value\u003e \u003c/property\u003e \u003c!-- 指定 hadoop 数据的存储目录 --\u003e \u003cproperty\u003e \u003cname\u003ehadoop.tmp.dir\u003c/name\u003e \u003cvalue\u003e/opt/module/hadoop-2.7.3/data\u003c/value\u003e \u003c/property\u003e \u003c/configuration\u003e 配置hdfs-site.xml，添加如下内容 vi /opt/module/hadoop-2.7.3/etc/hadoop/hdfs-site.xml \u003cconfiguration\u003e \u003c!-- nn web 端访问地址--\u003e \u003cproperty\u003e \u003cname\u003edfs.namenode.http-address\u003c/name\u003e \u003cvalue\u003ehadoop100:9870\u003c/value\u003e \u003c/property\u003e \u003c!-- 2nn web 端访问地址--\u003e \u003cproperty\u003e \u003cname\u003edfs.namenode.secondary.http-address\u003c/name\u003e \u003cvalue\u003ehadoop103:9868\u003c/value\u003e \u003c/property\u003e \u003c/configuration\u003e 配置 yarn-site.xml，添加如下内容 vi /opt/module/hadoop-2.7.3/etc/hadoop/yarn-site.xml \u003cconfiguration\u003e \u003c!-- 指定 MR 走 shuffle --\u003e \u003cproperty\u003e \u003cname\u003eyarn.nodemanager.aux-services\u003c/name\u003e \u003cvalue\u003emapreduce_shuffle\u003c/value\u003e \u003c/property\u003e \u003c!-- 指定 ResourceManager 的地址--\u003e \u003cproperty\u003e \u003cname\u003eyarn.resourcemanager.hostname\u003c/name\u003e \u003cvalue\u003ehadoop102\u003c/value\u003e \u003c/property\u003e \u003c!-- 环境变量的继承 --\u003e \u003cproperty\u003e \u003cname\u003eyarn.nodemanager.env-whitelist\u003c/name\u003e \u003cvalue\u003eJAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CO NF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAP RED_HOME\u003c/value\u003e \u003c/property\u003e \u003c/configuration\u003e 配置 mapred-site.xml，添加如下内容 \u003cconfiguration\u003e \u003c!-- 指定 MapReduce 程序运行在 Yarn 上 --\u003e \u003cproperty\u003e \u003cname\u003emapreduce.framework.name\u003c/name\u003e \u003cvalue\u003eyarn\u003c/value\u003e \u003c/property\u003e \u003cproperty\u003e \u003cname\u003eyarn.app.mapreduce.am.env\u003c/name\u003e \u003cvalue\u003eHADOOP_MAPRED_HOME=/opt/module/hadoop-2.7.3\u003c/value\u003e \u003c/property\u003e \u003cproperty\u003e \u003cname\u003emapreduce.map.env\u003c/name\u003e \u003cvalue\u003eHADOOP_MAPRED_HOME=/opt/module/hadoop-2.7.3\u003c/value\u003e \u003c/property\u003e \u003cproperty\u003e \u003cname\u003emapreduce.reduce.env\u003c/name\u003e \u003cvalue\u003eHADOOP_MAPRED_HOME=/opt/module/hadoop-2.7.3\u003c/value\u003e \u003c/property\u003e \u003c/configuration\u003e 3.5.4、同步配置文件 执行脚本 xsync /opt/module/hadoop-2.7.3/etc/hadoop/ 3.5.5、启动集群 配置workers vim /opt/module/hadoop-2.7.3/etc/hadoop/workers 在该文件中增加如下内容： ==注意：该文件中添加的内容结尾不允许有空格，文件中不允许有空行。== hadoop100 hadoop102 hadoop103 同步所有节点配置文件 xsync /opt/module/hadoop-2.7.3/etc/ 启动集群 如果集群是第一次启动，需要在 hadoop102 节点格式化 NameNode（注意：格式化 NameNode，会产生新的集群 id，导致 NameNode 和 DataNode 的集群 id 不一致，集群找不到已往数据。如果集群在运行过程中报错，需要重新格式化 NameNode 的话，一定要先停 止 namenode 和 datanode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化。） 在hadoop100机器上格式化NameNode 执行命令： hdfs namenode -format 启动 HDFS 在各个机器上启动HDFS执行(==在hadoop目录下执行下面命令==) sbin/start-dfs.sh 在各个机器上启动 YARN (==在hadoop目录下执行下面命令==) sbin/start-yarn.sh 执行 jps 查看启动的服务是否与配置方案一样 Web 端查看 HDFS 的 NameNode 浏览器中输入：http://192.168.75.100:9870/ 如果是核心最小版的需要下载 httpd，并且关闭防火墙 yum install -y httpd 在启动http服务 /bin/systemctl start httpd.service 设置http服务开机自启： systemctl enable httpd.service 查询服务是否自启 systemctl is-enabled httpd.service 查询服务是否运行 systemctl status httpd.service Web 端查看 YARN 的 ResourceManager http://192.168.75.102:8088 3.5.6、HDFS测试 上传文件到集群 #创建目录input hadoop fs -mkdir /wcinput #上传文件 fs -put /opt/module/hadoop-2.7.3/wcinput/word.txt /input 查看 HDFS 文件存储路径 根据 core-site.xml 的配置 ,查看 HDFS 在磁盘存储文件内容 \u003c!-- 指定 hadoop 数据的存储目录 --\u003e \u003cproperty\u003e \u003cname\u003ehadoop.tmp.dir\u003c/name\u003e \u003cvalue\u003e/opt/module/hadoop-2.7.3/data\u003c/value\u003e \u003c/property\u003e 在 /opt/module/hadoop-2.7.3/data 目录下 能找到对应上传的word.txt 数据 复制的三份分别存在hadoop100、hadoop102、hadoop103,在hadoop102、","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:5","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.6、配置历史服务器 为了查看程序的历史运行情况，需要配置一下历史服务器。具体配置步骤如下： 3.6.1、配置 mapred-site.xml 在hadoop100机器上编辑 mapred-site.xml vim /opt/module/hadoop-2.7.3/etc/hadoop/mapred-site.xml 添加如下内容 \u003c!-- 历史服务器端地址 --\u003e \u003cproperty\u003e \u003cname\u003emapreduce.jobhistory.address\u003c/name\u003e \u003cvalue\u003ehadoop100:10020\u003c/value\u003e \u003c/property\u003e \u003c!-- 历史服务器 web 端地址 --\u003e \u003cproperty\u003e \u003cname\u003emapreduce.jobhistory.webapp.address\u003c/name\u003e \u003cvalue\u003ehadoop100:19888\u003c/value\u003e \u003c/property\u003e 3.6.2、同步mapred-site.xml文件 xsync /opt/module/hadoop-2.7.3/etc/hadoop/mapred-site.xml 3.6.3、启动历史服务器 本文配置在hadoop100机器上，所有在hadoop100执行 /opt/module/hadoop-2.7.3/sbin/mr-jobhistory-daemon.sh start historyserver 3.6.4、查看历史服务器是否启动 3.6.5、查看jobhistory http://192.168.75.100:19888/jobhistory ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:6","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.7、配置日志的聚集 日志聚集概念：应用运行完成以后，将程序运行日志信息上传到 HDFS 系统上。 日志聚集功能好处：可以方便的查看到程序运行详情，方便开发调试。 ==注意：开启日志聚集功能，需要重新启动 NodeManager 、ResourceManager 和HistoryServer。== 3.7.1、配置 yarn-site.xml 在hadoop100机器上编辑 yarn-site.xml vim /opt/module/hadoop-2.7.3/etc/hadoop/yarn-site.xml 添加如下内容 \u003c!-- 开启日志聚集功能 --\u003e \u003cproperty\u003e \u003cname\u003eyarn.log-aggregation-enable\u003c/name\u003e \u003cvalue\u003etrue\u003c/value\u003e \u003c/property\u003e \u003c!-- 设置日志聚集服务器地址 --\u003e \u003cproperty\u003e \u003cname\u003eyarn.log.server.url\u003c/name\u003e \u003cvalue\u003ehttp://hadoop100:19888/jobhistory/logs\u003c/value\u003e \u003c/property\u003e \u003c!-- 设置日志保留时间为 7 天 --\u003e \u003cproperty\u003e \u003cname\u003eyarn.log-aggregation.retain-seconds\u003c/name\u003e \u003cvalue\u003e604800\u003c/value\u003e \u003c/property\u003e 3.7.2、同步mapred-site.xml文件 xsync /opt/module/hadoop-2.7.3/etc/hadoop/yarn-site.xml 3.7.3、关闭YARN和HistoryServer jps #查看启动的服务 /opt/module/hadoop-2.7.3/sbin/stop-yarn.sh #hadoop102 /opt/module/hadoop-2.7.3/sbin/mr-jobhistory-daemon.sh stop historyserver #hadoop100 3.7.4、启动YARN和HistoryServer #hadoop102(ResourceManager 配置在hadoop102) /opt/module/hadoop-2.7.3/sbin/start-yarn.sh #hadoop100(historyserver配置在hadoop100) /opt/module/hadoop-2.7.3/sbin/mr-jobhistory-daemon.sh start historyserver jps 3.7.5 查看jobhistory 网页：http://192.168.75.100:19888/jobhistory 删除前面单词统计生成的目录(输出目录不能存在，执行wordcount 程序会自行创建) hadoop fs -rm -r /output 执行WordCount 程序 hadoop jar /opt/module/hadoop-2.7.3/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount /input /output 通过网页查看任务执行日志 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:7","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.8、编写脚本启动/关闭集群 3.8.1 、启动/关闭集群脚本 进入 /root/bin/ 编辑 myhadoop.sh 脚本 #!/bin/bash if [ $# -lt 1 ] then echo \"No Args Input...\" exit ; fi case $1 in \"start\") echo \" =================== 启动 hadoop 集群 ===================\" echo \" --------------- 启动 hdfs ---------------\" ssh hadoop100 \"/opt/module/hadoop-2.7.3/sbin/start-dfs.sh\" ssh hadoop102 \"/opt/module/hadoop-2.7.3/sbin/start-dfs.sh\" ssh hadoop103 \"/opt/module/hadoop-2.7.3/sbin/start-dfs.sh\" echo \" --------------- 启动 yarn ---------------\" ssh hadoop100 \"/opt/module/hadoop-2.7.3/sbin/start-yarn.sh\" ssh hadoop102 \"/opt/module/hadoop-2.7.3/sbin/start-yarn.sh\" ssh hadoop103 \"/opt/module/hadoop-2.7.3/sbin/start-yarn.sh\" echo \" --------------- 启动 historyserver ---------------\" ssh hadoop100 \"/opt/module/hadoop-2.7.3/sbin/mr-jobhistory-daemon.sh start historyserver\" ;; \"stop\") echo \" =================== 关闭 hadoop 集群 ===================\" echo \" --------------- 关闭 historyserver ---------------\" ssh hadoop100 \"/opt/module/hadoop-2.7.3/sbin/mr-jobhistory-daemon.sh stop historyserver\" echo \" --------------- 关闭 yarn ---------------\" ssh hadoop100 \"/opt/module/hadoop-2.7.3/sbin/stop-yarn.sh\" ssh hadoop102 \"/opt/module/hadoop-2.7.3/sbin/stop-yarn.sh\" ssh hadoop103 \"/opt/module/hadoop-2.7.3/sbin/stop-yarn.sh\" echo \" --------------- 关闭 hdfs ---------------\" ssh hadoop100 \"/opt/module/hadoop-2.7.3/sbin/stop-dfs.sh\" ssh hadoop102 \"/opt/module/hadoop-2.7.3/sbin/stop-dfs.sh\" ssh hadoop103 \"/opt/module/hadoop-2.7.3/sbin/stop-dfs.sh\" ;; *) echo \"Input Args Error...\" ;; esac 赋予可执行权限 chmod +x myhadoop.sh 3.8.2 查看hadoop 服务状态脚本 /root/bin/ 目录下，创建脚本 jpsall ，赋予可执行权限 #!/bin/bash for host in hadoop100 hadoop102 hadoop103 do echo =============== $host =============== ssh $host jps done 将以上脚本同步到其他集群机器上 xsync /root/bin/ ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:8","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.9、 两个面试题 常用端口号 端口名称 hadoop.2.x hadoop.3.x NameNode内部通信端口 8020 / 9000 8020 / 9000/9820 NameNode HTTP UI 50070 9870 MapReduce 查看执行任务端口 8088 8088 历史服务器 19888 19888 常用的配置文件 hadoop3.x core-site.xml hdfs-site.xml yarn-site.xml mapred-site.xml works hadoop2.x core-site.xml hdfs-site.xml yarn-site.xml mapred-site.xml slaves ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:9","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["大数据技术"],"content":"3.10、集群时间同步 ==如果服务器在公网环境（能连接外网）==，可以不采用集群时间同步，因为服务器会定期和公网时间进行校准；如果服务器在内网环境，必须要配置集群时间同步，否则时间久了，会产生时间偏差，导致集群执行任务时间不同步。 doop103 do echo =============== $host =============== ssh $host jps done 将以上脚本同步到其他集群机器上 xsync /root/bin/ ### 3.9、 两个面试题 常用端口号 | 端口名称 | hadoop.2.x | hadoop.3.x | | -------------------------- | ----------- | ---------------- | | NameNode内部通信端口 | 8020 / 9000 | 8020 / 9000/9820 | | NameNode HTTP UI | 50070 | 9870 | | MapReduce 查看执行任务端口 | 8088 | 8088 | | 历史服务器 | 19888 | 19888 | 常用的配置文件 | hadoop3.x | core-site.xml hdfs-site.xml yarn-site.xml mapred-site.xml works | | ------------- | ------------------------------------------------------------ | | **hadoop2.x** | **core-site.xml hdfs-site.xml yarn-site.xml mapred-site.xml slaves** | ### 3.10、集群时间同步 ==如果服务器在公网环境（能连接外网）==，可以不采用集群时间同步，因为服务器会定期和公网时间进行校准；如果服务器在内网环境，必须要配置集群时间同步，否则时间久了，会产生时间偏差，导致集群执行任务时间不同步。 ","date":"2021/04/12","objectID":"/posts/hadoop%E5%85%A5%E9%97%A8/:3:10","tags":["hadoop"],"title":"hadoop入门文档","uri":"/posts/hadoop%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"linux命令使用文档","date":"2021/04/01","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0/","tags":["linux"],"title":"linux命令使用文档","uri":"/posts/linux%E5%AD%A6%E4%B9%A0/"},{"categories":["linux"],"content":"Linux 命令使用文档 1、环境：虚拟机+centOS7 开机关机 //1、保存数据后关机 sync //将数据由内存同步到硬盘中 shutdown //关机 //2、重启 reboot //reboot 系统的目录结构 / 根目录 bin : 存放经常使用的命令 boot: 存放启动linux时使用的一些核心文件，包括一些连接文件及镜像文件（不要动） etc: 存放所有的系统管理所需要的配置文件和子目录 home: 用户的主目录，在linux，每一个用户都有一个自己的目录，一般该目录是以用户的账号命名的 lib: 存放系统最基本的动态连接共享库，其作用类似于Windows里的dll文件（不要动） media: linux系统会自动识别一些设备，例如U盘、光驱等，当识别后，linux会把识别的设置挂载到这个目录 mmt : 为了让用户临时挂载别的文件系统的，可以把光驱挂载mmt上，然后进入该目录查看光驱里的内容 opt : 给主机额外安装软件所摆放的目录，比如安装一个oracle数据库 proc : 是一个虚拟的目录，它是系统内存的映射，可以通过访问这个目录来获取系统信息（不用管） root : 系统管理员的用户目录 sbin : s是super user，这里存放系统管理员使用的系统管理程序 srv : 存放一些服务服务启动后需要提取的数据 sys : 安装了linux2.6内核中新出现的一个文件系统sysfs tmp : 用来存放一些临时文件。用完就丢的文件可以放在这个目录 usr : 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个文件下，类似于Windows下的programfiles目录 usr/bin : 系统用户使用的应用程序 lost+found : 这个目录一般是空的，当系统非法关机后，这里就存放了一些文件（存放突然关机的一些文件） var ：存放不断扩充的东西，习惯将那些经常被修改的文件放到这个目录，包括各种日志 run : 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除 www : 存放服务器网站相关的资源，环境，网站的项目 目录管理 cd cd //切换目录 cd .. //返回上一级目录 cd / //切换到指定文件路径（分相对路径和绝对路径） ls ls //列出子目录清单 -a参数 //all ，查看全部的文件，包含隐藏文件 -l参数 //列出所有的文件，包含文件的属性和权限，没有隐藏文件 //所有的参数都可以组合 pwd pwd //显示当前用户所在目录 mkdir mkdir //创建文件目录 mkdir test //创建一个名为test的文件夹 mkidr -p test1/test2/test3 //递归创建文件夹test1,test2,test3(创建多级目录) rmdir rmdir test// 删除test文件夹 rmdir -p test1/test2/test3 //递归删除多个目录 //rmdir 只能删除空的目录，如果目录非空，需要先删除文件 cp cp test1 test //复制test1文件到test/目录下 //cp 原来的地方 新的地方 rm rm 移除文件或目录 -f参数 强制删除，忽略不存在的文件，不会出现告警 -r参数 递归删除目录 -i参数 询问是否删除 mv mv 移动文件或目录 -f参数 强制 -u参数 只替换已经更新过的文件 mv test1 test2 //如果是test1是文件夹，可以重命名为test2 touch touch 创建文件 文件属性查看及修改 查看文件属性 通过 ls -l 可以查看文件属性，如 dr-xr-xr-x. 5 root root 4096 Feb 20 11:10 boot 第一个字符表示这个是文件，目录，链接文件等等 d //表示是一个目录 - //表示是一个文件 l //表示是一个链接文件（类别Windows的快捷键） b //表示为装置文件里面的可供存储的接口设备（可随机存储装置） c //表示装置文件里的串行设置，例如键盘，鼠标（一次性读取装置） 接下来的字符，以三个为一组，且均为【rwx】的三个参数的组合，rwx先后顺序固定的，如果没有对应的权限则为 - r //表示可读 w //表示可写 x //表示可执行 - //表示无权限 //三种用户组：owner , group ,ohter 5 表示文件的个数 root 文件的归属者 root 文件所属的用户组 4096 表示文件的大小 Feb 20 11:10 时间 boot 文件名（如果是连接文件则会知名链接的谁 如 lib -\u003e usr/lib） chgrp chgrp //更改文件所属的用户组 chgrp [-R] 文件所属的用户组 文件名 chown chown //更改文件所属的用户（文件的归属者） chown [-R] 文件的归属者 文件名 chown [-R] 文件的归属者:文件所属的用户组 文件名 chmod chmod //更改文件的权限设置 //三种用户权限设置：owner , group ,ohter //rwx 对应 相应的二进制，有相应的权限为在对应的位置上为1（反之，则为0） 如拥有rwx权限，则111 ,十进制为7 chmod 770 文件名 查看文件内容 cat //由第一行开始显示文件内容 tac //从最后一行开始显示，可以看出tac,是cat的倒写 nl //显示的时候，顺便输出行号 more //一页一页的显示文件内容（空格键翻页，enter向下翻一行） less //与more类似，但比more更好的是，可以往前翻页（空格键翻页，上下键表示前后翻页，q退出，/要查询的字符串，向下查询文件中符合的字符串 ，?要查询的字符串，向上查询文件中符合的字符串） head //只看头部几行, -n 行数 查看显示指定行数 tail //只看尾巴几行, -n 行数 查看显示指定行数 硬链接和软连接 硬链接 假设A是B的硬链接，那么将B删除后，仍然可以通过A来访问原先B的内容。可以理解为A和B都指向同一个文件或目录，可以用这种方式，链接到一些重要的文件上，防止误删。 软链接 假设A是B的软链接，A就是类似于windows下的快捷方式，依附于B 创建链接 ln ln f1 f2 //创建f1的硬链接f2 ln -s f1 f3 //创建f1的软链接f3 vim编辑器 三种模式 命令模式— i,a—\u003e输入模式 输入模式–esc–\u003e命令模式 命令模式– : （输入冒号）–\u003e底线命令模式 底线命令模式–回车键–\u003e命令模式 账号管理 创建用户 useradd //添加用户 -m参数 //自动创建这个用户的主目录如/home/zhangsan useradd -m zhangsan //linux中，一切皆文件，添加用户就是往某个文件写入用户信息，/etc/passwd ，用户加密后的口令：/etc/shadow -G参数 //分配用户组 删除用户 userdel //删除用户 -r参数 //删除用户时并把它的目录页一块删掉 userdel -r zhangsan 修改用户 usermod //修改用户 切换用户 su //切换用户 su zhangsan //切换到张三用户 exit //退出登录，退回原来用户 修改主机名 hostname //查看当前主机名 hostname 新的主机名 //重启后就可以了（临时的） 修改密码 passwd username//root设置其他用户密码 passwd //普通用户得验证旧密码 锁定账号（冻结账号） passwd -l zhangsan //锁定用户 passwd -d zhangsan //清空用户密码，没有密码也不能登入 passwd -u zhangsan //解锁 用户组管理 创建用户组 groupadd //创建用户组 //用户组的添加、删除、修改实际上就是对/etc/group 文件的更新 groupadd student //创建学生组 groupadd -g 520 student //创建指定id的用户组 删除用户组 groupdel //删除用户组 groupdel student //删除学生组 修改用户组 groupmod //修改用户组 磁盘管理 df df //列出文件系统整体的磁盘使用量（字节单位） df -h //（M或G为单位） du du //检查磁盘空间的使用量 du -a du -sm /* //检查根目录下每个目录所占用的容量 挂载磁盘或文件 mount //挂载磁盘 mont /dev/U /mnt/U //将外部设置U挂载到mnt目录下，实现访问 卸载挂载 umount -f [挂载位置] //强制卸载挂载的文件或磁盘 进程管理 1、在linux中，每个程序都有自己的一个进程，每一个进程都有一个id号 2、每一个进程都有一个父进程 3、进程可以有两种存在方式：前台，后台运行 4、一般情况服务都是后台运行的，基本的程序是前台运行的 查看进程 ps //查看当前系统中正在执行的各种进程信息 -a //显示当前终端所有的进程信息 -u //以用户的信息显示进程 -x //显示后台运行进程 ps -aux|grep mysql //查看mysql 相关的进程 ps -ef //可以查到父进程的信息 ps -ef|grep mysql pstree //看父进程可以通过目录树结构来查看 -p //显示父id -u //显示用","date":"2021/04/01","objectID":"/posts/linux%E5%AD%A6%E4%B9%A0/:0:0","tags":["linux"],"title":"linux命令使用文档","uri":"/posts/linux%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"介绍juqery的基本语法，作为简单的文档","date":"2021/01/24","objectID":"/posts/juqery/","tags":["前端","juqery"],"title":"Juqery笔记","uri":"/posts/juqery/"},{"categories":["前端"],"content":"一、Jquery对象 1.1 对象类型 DOM对象 HTMLCollection [] Jquery包装集对象 jQuery.fn.init(0) 1.2对象转换 //通过$(DOM对象）转为Jquery对象 console.log($(document.getElementsByClassName(“mainTable”))); //通过 Jquery对象.属性 转为DOM对象 console.log($(\".mainTable\").context); ","date":"2021/01/24","objectID":"/posts/juqery/:0:1","tags":["前端","juqery"],"title":"Juqery笔记","uri":"/posts/juqery/"},{"categories":["前端"],"content":"二、Jquery 选择器 2.1、Jquery 基础选择器 选择器 名称 示例 id选择器 #id $(\"#idtest\") 获取id 为 idtest 的元素 元素名称选择器 element $(“div”) 获取所有div元素 类选择器 .class $(\".className\")获取class=“className” 的元素 选择所有元素 * $(\"*\") 选择页面所有元素 组合选择器 $(\"#idtest,div,.className\") 同时选取多个元素 2.2 Jquery 层次选择器 选择器 名称 示例 后代选择器 ancestor descendant $(\"#parent div\") 选择id为parent的元素的所有div元素 子代选择器 parent \u003e child $(\"#parent \u003e div\")选择id为parent的元素的直接div子元素 相邻选择器 prev + next $(\"#parent + div\")选择id为parent的元素的下一个div元素 同辈选择器 prev ~ sibling $(\"#parent ~ div\")选择id为parent的元素之后的div元素 2.3 Jquery 表单选择器 选择器 名称 示例 表单选择器 :input $(\":input\")查找所有input元素 注意：会匹配所有的input、textarea、select和button元素 文本框选择器 :text $(\":text\") 查找所有文本框 密码框选择器 :password $(\":password\") 查找所有密码框 单选按钮选择器 :radio $(\":radio\")查找所有单选按钮 复选框选择器 :checkbox $(\":checkbox\") 查找所有复选框 提交按钮选择器 :submit $(\":submit\")查找所有提交按钮 图像域选择器 :image $(\":image\")查找所有图像域 重置按钮选择器 :reset $(\":reset\")查找所有重置按钮 按钮选择器 :button $(\":button\") 查找所有按钮 文件域选择器 :file $(\":file\")查找所有文件域 ","date":"2021/01/24","objectID":"/posts/juqery/:0:2","tags":["前端","juqery"],"title":"Juqery笔记","uri":"/posts/juqery/"},{"categories":["前端"],"content":"三、Jquery 操作元素 3.1 、操作元素的属性 属性的分类： 固有属性：元素本身有的属性（id、class、style) 返回boolean的属性：如checked,selected,disabled 自定义属性：用户自定义属性 获取属性的方法： ​ attr(“属性”) ​ prop(“属性”) ​ $(spreadsheetReport.elem_content).attr(“style”); 两者之间的区别： 如果是固有属性，attr 和 prop 方法都可以操作 如果是自定义属性，attr 可以操作 ，prop不可以操作 如果是boolean值属性， ​ 如果设置了属性值，attr 获取返回属性值，prop 获取返回 true ​ 如果没有设置属性值，attr 获取返回undefined, prop 获取返回false 设置属性的方法： ​ attr(“属性”,“属性值”) ​ prop(“属性”,“属性值”) 移除属性的方法： ​ removeAttr(“属性名”) 总结： ==如果属性的类型为boolean，则用prop()方法，否则使用attr()方法== 3.2 、 操作元素的样式 结合css ,操作元素的样式 attr(“class”) 获取元素的样式名 attr(“class”,“样式名”) 设置元素的样式（会覆盖原本的样式） addClass(“样式名”) 添加样式（在原本的样式基础上添加样式，如果样式名中属性如background发生冲突， 则按css中定义的顺序，后定义的样式覆盖前定义的样式） removeClass(“样式名”) 移除样式 /*css 定义文件*/ .green { background:green; } .pink { background:pink; } //获取元素的样式名 $('input').attr(\"class\"); //设置元素的样式 $('input').attr(\"class\",\".pink\"); //添加样式 //在css文件中pink样式名定义在green样式名后，所有pink会覆盖掉green的背景色 $('input').attr(\"green\"); //移除样式 $('input').removeClass(\"pink\"); 操作元素的css样式中的具体内容 css() 添加具体的样式（添加行内样式） //获取color属性值 $(\"div\").css(\"color\") //设置单个样式 $(\"div\").css(\"color\",\"red\") //设置多个样式 $(\"div\").css({fontSize:\"30px\",color:\"red\"}) 3.3 、操作元素的内容 操作表单元素内容 表单元素：文本框text 、密码框input、单选框radio、复选框checkbox、文本域textarea、下拉框select ​ val() 获取表单元素的值 ​ val(“值”) 设置表单元素的值 操作非表单元素的内容 ​ html() 获取元素的内容 ​ html(“内容”) 设置元素的内容（会覆盖原本的内容） $(spreadsheetReport.elem_content).html( ) $(spreadsheetReport.elem_content).html(\"1234\") ","date":"2021/01/24","objectID":"/posts/juqery/:0:3","tags":["前端","juqery"],"title":"Juqery笔记","uri":"/posts/juqery/"},{"categories":["前端"],"content":"四、Jquery 创建、添加、删除、遍历元素 4.1 、 创建元素 //$(\"元素\") ,通过$将元素转为Jquery对象 var p=\"\u003cp\u003e这是一个p标签\u003c/p\u003e\" $(p) 4.2 、添加元素 方法 说明 prepend(content) 在元素内部开头插入元素或者内容==content参数可以是字符串、html元素、JQuery对象== $(content).prependTo(selector) 把content元素或内容加入selector 元素内部开头 append(content) 在元素内部尾部插入元素或内容 $(content).appendTo(selector) 把content元素或内容加入selector 元素内部结尾 before(content) 在元素前插入元素或内容 after(content) 在元素后插入元素或内容 // 添加元素：内容可以是字符串、html元素、JQuery对象 ，指定元素必须是Jquery对象 /* 1、前追加子元素 指定元素.prepend(内容) 在指定元素内部的最前面追加内容 $(内容).prependTo(指定元素) 2、后追加子元素 指定元素.append(内容) 在指定元素内部的最后面追加内容 $(内容).appendTo(指定元素) 3、前追加同级元素 指定元素.before(内容) 在指定元素相邻的前面位置追加内容 4、后追加同级元素 指定元素.after(内容) 在指定元素相邻的后面位置追加内容 */ var p = \"\u003ch1\u003e这是一个p标签\u003c/h1\u003e\"; var p1 = \"\u003ch1\u003e这是一个p1标签\u003c/h1\u003e\"; var c = $(spreadsheetReport.elem_content); c.before($(p)); c.before($(p1)); 4.3 、删除元素 方法 说明 remove() 删除所选元素或指定的子元素，包括整个标签和内容都删除 empty() 清空所有内容，保留标签 4.4 、遍历元素 each() 使用方法： ​ $(selector).each(function(index,element)) ; 遍历元素 ​ 参数 function 为遍历时的回调函数 ​ index 为遍历的序列号，从0开始 ​ element是当前的元素 //可以不需要index、element参数，直接用this获取当前的子元素 var c = $(spreadsheetReport.elem_content); c.each(function(index,element){ console.log(index); console.log(element); console.log(this); }); ","date":"2021/01/24","objectID":"/posts/juqery/:0:4","tags":["前端","juqery"],"title":"Juqery笔记","uri":"/posts/juqery/"},{"categories":["前端"],"content":"五 、Jquery 事件 5.1 、预加载事件 ready 当前的DOM结构加载完毕后执行，类似于js的load事件，ready事件可以写多个 使用语法： $(document).ready(function(){ //要执行的代码 }); 简写： $(function(){ // }); 5.2 、绑定事件 为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数 bind绑定事件 /* $(selector).bind(eventType[,evevtData],handler(eventObject)); selector: 被选元素 eventType:所需要绑定的事件 [,evevtData]:传递的参数，格式{名：值；名1：值1;...} handler(eventObject) 该事件触发执行的函数 */ 绑定单个事件 $(\"元素\").blind(\"事件类型\",function(){ // }); 绑定多个事件 1、同时为多个事件绑定同一个函数 $(\"元素\").blind(\"事件类型1，事件类型2，事件类型3...\",function(){ // }); 2、为元素绑定多个事件，并设置对应的函数 $(\"元素\").blind(\"事件类型1\",function(){ // }).blind(\"事件类型2\",function(){ // }).blind(\"事件类型3\",function(){ // }); 3、为元素绑定多个事件，并设置对应的函数 $(\"元素\").blind({} \"事件类型1\"：function({}), \"事件类型2\"：function({}), \"事件类型3\"：function({}) }); 直接绑定(建议使用) 绑定单个事件 $(\"元素\").事件名(function(){ // }); 绑定多个事件 $(\"元素\").事件名1(function(){ }).事件名2(function(){ }).事件名3(function(){ }); var c = $(spreadsheetReport.elem_content); c.after(\"\u003ch1\u003eclick here\u003c/h1\u003e\"); //设置\u003ch1\u003e鼠标样式 $(\"h1\").css(\"cursor\",\"pointer\"); $(\"h1\").click(function(){ alert(\"你好\"); }).mouseover(function(){ console.log(\"aaaa\"); }); ","date":"2021/01/24","objectID":"/posts/juqery/:0:5","tags":["前端","juqery"],"title":"Juqery笔记","uri":"/posts/juqery/"},{"categories":["前端"],"content":"六 、Ajax 6.1、简介： Ajax 异步局部刷新技术 ​ 异步：发送请求后不需要等待服务器返回结果后再去执行其他操作 局部刷新：发送请求后不会刷新整个页面，只会刷新部分页面 6.2、Jquery 调用ajax方法： ​ 格式：$.ajax({}) ​ 参数说明： ​ type:请求方式 get/post ​ url：请求地址url ​ async:是否异步，默认是true表示异步 ​ data:发送到服务器的数据 ​ dataType:预期服务器返回的数据类型 ​ contentType:设置请求头部 ​ success:请求成功时调用此函数 ​ error:请求失败时，调用此函数 ​ ​ ","date":"2021/01/24","objectID":"/posts/juqery/:0:6","tags":["前端","juqery"],"title":"Juqery笔记","uri":"/posts/juqery/"},{"categories":["JavaWeb"],"content":"javaweb实例-订单管理系统（7）验证密码模块","date":"2021/01/12","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/","tags":["javaweb实例","AJAX","JavaWeb"],"title":"javaweb实例-订单管理系统（7）验证密码模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/"},{"categories":["JavaWeb"],"content":"web1.0时代 早期网站，登入，如果失败，需要刷新页面，才能重新登入；不点击提交按钮不知道自己密码输错了。 现在大多数的网站，都是局部刷新，不刷新整个页面的情况下，实现页面更新。 像百度搜索框，当年输入字进去就会在下方出现提示选项 ","date":"2021/01/12","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/:0:1","tags":["javaweb实例","AJAX","JavaWeb"],"title":"javaweb实例-订单管理系统（7）验证密码模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/"},{"categories":["JavaWeb"],"content":"什么是json JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。 ","date":"2021/01/12","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/:0:2","tags":["javaweb实例","AJAX","JavaWeb"],"title":"javaweb实例-订单管理系统（7）验证密码模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/"},{"categories":["JavaWeb"],"content":"json格式 {\"name\",\"zhangsan\"} //用{} 表示一个对象 [{\"name\",\"张三\"},{\"name\",\"李四\"}] //用[]表示一个数组 json字符串：指的是符合json格式要求的js字符串。 例如：var jsonStr = “{StudentID:‘100’,Name:’tmac’,Hometown:‘usa’}”; json对象：指符合json格式要求的js对象。 例如：var jsonObj = { StudentID: “100”, Name: “tmac”, Hometown: “usa” }; ","date":"2021/01/12","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/:0:3","tags":["javaweb实例","AJAX","JavaWeb"],"title":"javaweb实例-订单管理系统（7）验证密码模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/"},{"categories":["JavaWeb"],"content":"什么是AJAX ajax一个前后台配合的技术，它可以让javascript发送http请求，与后台通信，获取数据和信息。ajax技术的原理是实例化xmlhttp对象，使用此对象与后台通信。jquery将它封装成了一个函数$.ajax()，我们可以直接用这个函数来执行ajax请求。 ","date":"2021/01/12","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/:0:4","tags":["javaweb实例","AJAX","JavaWeb"],"title":"javaweb实例-订单管理系统（7）验证密码模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/"},{"categories":["JavaWeb"],"content":"AJAX的使用 常用参数： 1、url 请求地址 2、type 请求方式，默认是’GET’，常用的还有’POST’ 3、dataType 设置返回的数据格式，常用的是’json’格式，也可以设置为’html’ 4、data 设置发送给服务器的数据 5、success 设置请求成功后的回调函数 6、error 设置请求失败后的回调函数 7、async 设置是否异步，默认值是’true’，表示异步 ","date":"2021/01/12","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/:0:5","tags":["javaweb实例","AJAX","JavaWeb"],"title":"javaweb实例-订单管理系统（7）验证密码模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/"},{"categories":["JavaWeb"],"content":"json和AJAX实现验证密码 首先是jsp \u003cdiv class=\"right\"\u003e \u003cdiv class=\"location\"\u003e \u003cstrong\u003e你现在所在的位置是:\u003c/strong\u003e \u003cspan\u003e密码修改页面\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"providerAdd\"\u003e \u003cform id=\"userForm\" name=\"userForm\" method=\"post\" action=\"${pageContext.request.contextPath }/jsp/user.do\"\u003e \u003cinput type=\"hidden\" name=\"method\" value=\"savepwd\"\u003e \u003c!--div的class 为error是验证错误，ok是验证成功--\u003e \u003cdiv class=\"info\"\u003e${message}\u003c/div\u003e \u003cdiv class=\"\"\u003e \u003clabel for=\"oldPassword\"\u003e旧密码：\u003c/label\u003e \u003cinput type=\"password\" name=\"oldpassword\" id=\"oldpassword\" value=\"\"\u003e \u003cfont color=\"red\"\u003e\u003c/font\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"newPassword\"\u003e新密码：\u003c/label\u003e \u003cinput type=\"password\" name=\"newpassword\" id=\"newpassword\" value=\"\"\u003e \u003cfont color=\"red\"\u003e\u003c/font\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"newPassword\"\u003e确认新密码：\u003c/label\u003e \u003cinput type=\"password\" name=\"rnewpassword\" id=\"rnewpassword\" value=\"\"\u003e \u003cfont color=\"red\"\u003e\u003c/font\u003e \u003c/div\u003e \u003cdiv class=\"providerAddBtn\"\u003e \u003c!--\u003ca href=\"#\"\u003e保存\u003c/a\u003e--\u003e \u003cinput type=\"button\" name=\"save\" id=\"save\" value=\"保存\" class=\"input-button\"\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e 用AJAX 传递数据到后台 前提，引入jquery \u003cscript type=\"text/javascript\" src=\"${pageContext.request.contextPath }/js/jquery-1.8.3.min.js\"\u003e\u003c/script\u003e jsp var oldpassword = null; var newpassword = null; var rnewpassword = null; var saveBtn = null; $(function(){ oldpassword = $(\"#oldpassword\"); newpassword = $(\"#newpassword\"); rnewpassword = $(\"#rnewpassword\"); saveBtn = $(\"#save\"); oldpassword.next().html(\"*\"); newpassword.next().html(\"*\"); rnewpassword.next().html(\"*\"); //blur 当鼠标移出输入框时触发事件 //当输入旧密码后，失去聚焦事件触发，发出url:path+\"/jsp/user.do\"请求 //在servlet 获取method 和 oldpassword //接收返回的json oldpassword.on(\"blur\",function(){ $.ajax({ type:\"GET\", url:path+\"/jsp/user.do\", data:{method:\"pwdmodify\",oldpassword:oldpassword.val()}, dataType:\"json\", success:function(data){ if(data.result == \"true\"){//旧密码正确 // validateTip(oldpassword.next(),{\"color\":\"green\"},imgYes,true); }else if(data.result == \"false\"){//旧密码输入不正确 validateTip(oldpassword.next(),{\"color\":\"red\"},imgNo + \" 原密码输入不正确\",false); }else if(data.result == \"sessionerror\"){//当前用户session过期，请重新登录 validateTip(oldpassword.next(),{\"color\":\"red\"},imgNo + \" 当前用户session过期，请重新登录\",false); }else if(data.result == \"error\"){//旧密码输入为空 validateTip(oldpassword.next(),{\"color\":\"red\"},imgNo + \" 请输入旧密码\",false); } }, error:function(data){ //请求出错 validateTip(oldpassword.next(),{\"color\":\"red\"},imgNo + \" 请求错误\",false); } }); //当鼠标移入输入框，聚焦事件 }).on(\"focus\",function(){ validateTip(oldpassword.next(),{\"color\":\"#666666\"},\"* 请输入原密码\",false); }); newpassword.on(\"focus\",function(){ validateTip(newpassword.next(),{\"color\":\"#666666\"},\"* 密码长度必须是大于6小于20\",false); }).on(\"blur\",function(){ if(newpassword.val() != null \u0026\u0026 newpassword.val().length \u003e 5 \u0026\u0026 newpassword.val().length \u003c 20 ){ validateTip(newpassword.next(),{\"color\":\"green\"},imgYes,true); }else{ validateTip(newpassword.next(),{\"color\":\"red\"},imgNo + \" 密码输入不符合规范，请重新输入\",false); } }); rnewpassword.on(\"focus\",function(){ validateTip(rnewpassword.next(),{\"color\":\"#666666\"},\"* 请输入与上面一致的密码\",false); }).on(\"blur\",function(){ if(rnewpassword.val() != null \u0026\u0026 rnewpassword.val().length \u003e 5 \u0026\u0026 rnewpassword.val().length \u003c 20 \u0026\u0026 newpassword.val() == rnewpassword.val()){ validateTip(rnewpassword.next(),{\"color\":\"green\"},imgYes,true); }else{ validateTip(rnewpassword.next(),{\"color\":\"red\"},imgNo + \" 两次密码输入不一致，请重新输入\",false); } }); //点击保存事件 saveBtn.on(\"click\",function(){ oldpassword.blur(); newpassword.blur(); rnewpassword.blur(); if(oldpassword.attr(\"validateStatus\") == \"true\" \u0026\u0026 newpassword.attr(\"validateStatus\") == \"true\" \u0026\u0026 rnewpassword.attr(\"validateStatus\") == \"true\"){ if(confirm(\"确定要修改密码？\")){ $(\"#userForm\").submit(); } } }); }); servlet protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //根据method 传的值不同来判断 String method=req.getParameter(\"method\"); if(method.equals(\"savepwd\")\u0026\u0026method!=null){ //点击保存按钮，响应更新密码操作 this.updatePwd(req,resp); }else if(method.equals(\"pwdmodify\")\u0026\u0026method!=null){ //鼠标移出原密码的输入框，响应返回原密码和输入的原密码是否相同的结果true or false this.pwdModify(req,resp); } } //原密码的比较 /","date":"2021/01/12","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/:0:6","tags":["javaweb实例","AJAX","JavaWeb"],"title":"javaweb实例-订单管理系统（7）验证密码模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--json%E5%92%8Cajax%E9%AA%8C%E8%AF%81%E5%AF%86%E7%A0%81/"},{"categories":["JavaWeb"],"content":"javaweb实例-订单管理系统（6）修改密码模块","date":"2021/01/12","objectID":"/posts/javaweb%E5%AE%9E%E8%B7%B5--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（6）修改密码模块","uri":"/posts/javaweb%E5%AE%9E%E8%B7%B5--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"},{"categories":["JavaWeb"],"content":"修改密码流程 1、BaseDao 工具类 //编写增删改公共方法 public static int excuteUpdate(Connection connection,String sql,Object[] parms) throws Exception { int updateRows; preparedStatement = connection.prepareStatement(sql); for (int i = 0; i \u003c parms.length; i++) { preparedStatement.setObject(i+1,parms[i]); } updateRows = preparedStatement.executeUpdate(); return updateRows; } 2、UserDao //修改用户密码 public int updatePwd( Connection connection,String newPassword,int userId) throws Exception{ String sql=\"update userinfo set userPassword = ? where userID = ? \"; Object[] parms={newPassword,userId}; int updateRow = BaseDao.excuteUpdate(connection, sql, parms); return updateRow; } 3、UserService //用户修改密码,失败返回false ，成功为true public boolean updatePwd(String newPassword, int userID) throws Exception { boolean flag=false; Connection connection = BaseDao.getconnection(); if(connection!=null){ int i = userDao.updatePwd(connection, newPassword, userID); if(i\u003e0){ flag=true; } } BaseDao.closeResource(connection,null); return flag; } 4、UserServlet package com.tin.servlet.user; import com.alibaba.fastjson.JSONArray; import com.tin.pojo.UserInfo; import com.tin.service.user.UserService; import com.tin.service.user.UserServiceImpl; import com.tin.util.Constants; import javafx.application.Application; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; import java.util.HashMap; import java.util.Map; public class UserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //点击前端提交按钮，传递了参数method String method=req.getParameter(\"method\"); if(method.equals(\"savepwd\")\u0026\u0026method!=null){ this.updatePwd(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } //修改密码 public void updatePwd(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{ //从session 中拿userid UserInfo user =(UserInfo) req.getSession().getAttribute(Constants.USER_SESSION); //拿到重置的密码,input 的name属性 String newPwd=req.getParameter(\"newpassword\"); boolean flag=false; //如果新密码获取成功 if(newPwd!=null){ UserService userService=new UserServiceImpl(); try { flag = userService.updatePwd(newPwd, user.getUserID()); if(flag){ req.setAttribute(\"message\",\"密码修改成功，请退出重新登入\"); //密码修改成功，移除当前session req.getSession().removeAttribute(Constants.USER_SESSION); }else{ req.setAttribute(\"message\",\"密码修改失败\"); } }catch (Exception e){ e.printStackTrace(); } }else{ req.setAttribute(\"message\",\"新密码有问题\"); } req.getRequestDispatcher(\"pwdmodify.jsp\").forward(req,resp); } } 5、前端接口： \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%\u003e \u003c%@include file=\"/jsp/common/head.jsp\"%\u003e \u003cdiv class=\"right\"\u003e \u003cdiv class=\"location\"\u003e \u003cstrong\u003e你现在所在的位置是:\u003c/strong\u003e \u003cspan\u003e密码修改页面\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"providerAdd\"\u003e \u003cform id=\"userForm\" name=\"userForm\" method=\"post\" action=\"${pageContext.request.contextPath }/jsp/user.do\"\u003e \u003cinput type=\"hidden\" name=\"method\" value=\"savepwd\"\u003e \u003c!--div的class 为error是验证错误，ok是验证成功--\u003e \u003cdiv class=\"info\"\u003e${message}\u003c/div\u003e \u003cdiv class=\"\"\u003e \u003clabel for=\"oldPassword\"\u003e旧密码：\u003c/label\u003e \u003cinput type=\"password\" name=\"oldpassword\" id=\"oldpassword\" value=\"\"\u003e \u003cfont color=\"red\"\u003e\u003c/font\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"newPassword\"\u003e新密码：\u003c/label\u003e \u003cinput type=\"password\" name=\"newpassword\" id=\"newpassword\" value=\"\"\u003e \u003cfont color=\"red\"\u003e\u003c/font\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"newPassword\"\u003e确认新密码：\u003c/label\u003e \u003cinput type=\"password\" name=\"rnewpassword\" id=\"rnewpassword\" value=\"\"\u003e \u003cfont color=\"red\"\u003e\u003c/font\u003e \u003c/div\u003e \u003cdiv class=\"providerAddBtn\"\u003e \u003c!--\u003ca href=\"#\"\u003e保存\u003c/a\u003e--\u003e \u003cinput type=\"button\" name=\"save\" id=\"save\" value=\"保存\" class=\"input-button\"\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e \u003c/section\u003e \u003c%@include file=\"/jsp/common/foot.jsp\" %\u003e \u003cscript type=\"text/javascript\" src=\"${pageContext.request.con","date":"2021/01/12","objectID":"/posts/javaweb%E5%AE%9E%E8%B7%B5--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/:0:1","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（6）修改密码模块","uri":"/posts/javaweb%E5%AE%9E%E8%B7%B5--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"},{"categories":["JavaWeb"],"content":"javaweb实例-订单管理系统（5）用户退出登入模块","date":"2021/01/10","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（5）用户退出登入模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/"},{"categories":["JavaWeb"],"content":"用户退出登入流程 用户点击主页中的退出–》/jsp/logout.do 请求–》LogoutServlet 移除session用户信息 优化：当用户退出登入后不能再访问主页等资源页面，实现权限控制 访问主页等资源页面的请求–》过滤器–》判断用户信息是否存在–》存在就能访问–》不存在就跳转到error.jsp ","date":"2021/01/10","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/:0:1","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（5）用户退出登入模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/"},{"categories":["JavaWeb"],"content":"Logoutservlet package com.tin.servlet; import com.tin.util.Constants; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class LogoutServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //移除session存储的用户信息 req.getSession().removeAttribute(Constants.USER_SESSION); req.getRequestDispatcher(\"../login.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ","date":"2021/01/10","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/:0:2","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（5）用户退出登入模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/"},{"categories":["JavaWeb"],"content":"SysFilter package com.tin.filter; import com.tin.pojo.UserInfo; import com.tin.util.Constants; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class SysFilter implements Filter { public void init(FilterConfig filterConfig) throws ServletException { } public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request=(HttpServletRequest) servletRequest; HttpServletResponse response=(HttpServletResponse) servletResponse; UserInfo user = (UserInfo) request.getSession().getAttribute(Constants.USER_SESSION); //如果用户信息为空则转发到error.jsp if(user!=null){ filterChain.doFilter(servletRequest,servletResponse); }else{ //这里是全路径 response.sendRedirect(\"/ManageSystem_war/error.jsp\"); } } public void destroy() { } } ","date":"2021/01/10","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/:0:3","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（5）用户退出登入模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/"},{"categories":["JavaWeb"],"content":"在web.xml 注册 \u003c!--监听用户是否登录过滤器--\u003e \u003cfilter\u003e \u003cfilter-name\u003esysFilter\u003c/filter-name\u003e \u003cfilter-class\u003ecom.tin.filter.SysFilter\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003esysFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/jsp/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c!--注册注销的logoutServlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003elogout\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.tin.servlet.LogoutServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003elogout\u003c/servlet-name\u003e \u003curl-pattern\u003e/jsp/logout.do\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e ","date":"2021/01/10","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/:0:4","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（5）用户退出登入模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5/"},{"categories":["JavaWeb"],"content":"javaweb实例-订单管理系统（4）用户登入模块","date":"2021/01/09","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E7%99%BB%E5%85%A5%E6%A8%A1%E5%9D%97/","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（4）用户登入模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E7%99%BB%E5%85%A5%E6%A8%A1%E5%9D%97/"},{"categories":["JavaWeb"],"content":"前言 本来想尝试一下自己做demo，但弄起来很麻烦，javaweb所学部分就是看了B站up主遇见狂神说的教学视频，详细资源自己在b站搜索一下 ","date":"2021/01/09","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E7%99%BB%E5%85%A5%E6%A8%A1%E5%9D%97/:0:1","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（4）用户登入模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E7%99%BB%E5%85%A5%E6%A8%A1%E5%9D%97/"},{"categories":["JavaWeb"],"content":"前端页面 资源链接： 网站链接 获取到login.jsp 和 对应的images、css 、jsp资源 文件位置如图放置 2、在web.xml设置login.jsp为服务器首页 \u003c!--设置网站首页--\u003e \u003cwelcome-file-list\u003e \u003cwelcome-file\u003elogin.jsp\u003c/welcome-file\u003e \u003c/welcome-file-list\u003e ","date":"2021/01/09","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E7%99%BB%E5%85%A5%E6%A8%A1%E5%9D%97/:0:2","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（4）用户登入模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E7%99%BB%E5%85%A5%E6%A8%A1%E5%9D%97/"},{"categories":["JavaWeb"],"content":"登入模块流程 1、数据库中存储用户信息的表 2、JavaBean 对应这个表的实体类（加无参构造，get/set方法） package com.tin.pojo; public class UserInfo { private int userID; private String userName; private String userPassword; private int roleID; private String phone; private String address; //通过联合查询获取用户的角色名称 private String userRoleName; //再添加get/set属性的方法和无参构造 } 3、构建java 加载mysql 的共有方法的工具类BaseDao 获取mysql 加载需要的配置信息 private static String driver;//mysql 驱动包 private static String url; private static String userName; private static String password; private static PreparedStatement preparedStatement; //静态代码块类加载的时候就执行,获取数据库配置信息 static { //通过类加载器读取对应的资源 InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(\"db.properties\"); Properties properties = new Properties(); try { properties.load(is); } catch (IOException e) { e.printStackTrace(); } driver=properties.getProperty(\"a\"); url=properties.getProperty(\"url\"); userName=properties.getProperty(\"userName\"); password=properties.getProperty(\"password\"); try { is.close(); } catch (IOException e) { e.printStackTrace(); } } 获取操作数据库的connection 对象 //获取数据库链接 public static Connection getconnection() throws Exception { Connection connection=null; //加载驱动 Class.forName(driver); //获取数据库连接 connection= DriverManager.getConnection(url,userName,password); return connection; } 封装SQL查询的类方法 //编写查询公共方法 //connecton 操作数据库对象 //sql 要执行的SQL语句 // parms SQL预编译待填的参数 // resultSet 存储返回的结果，类似一张数据表 public static ResultSet excuteQuery(Connection connection,String sql,Object[] parms) throws Exception { ResultSet resultSet=null; preparedStatement = connection.prepareStatement(sql); for (int i = 0; i \u003c parms.length; i++) { preparedStatement.setObject(i+1,parms[i]); } resultSet = preparedStatement.executeQuery(); return resultSet; } 封装增删改查的类方法 //编写增删改公共方法 //返回影响的数据表行数 public static int excuteUpdate(Connection connection,String sql,Object[] parms) throws Exception { int updateRows; preparedStatement = connection.prepareStatement(sql); for (int i = 0; i \u003c parms.length; i++) { preparedStatement.setObject(i+1,parms[i]); } updateRows = preparedStatement.executeUpdate(); return updateRows; } 封装关闭资源的类方法 //关闭资源 //基本原则：谁打开资源就由谁来关闭 public static boolean closeResource(Connection connection,ResultSet resultSet){ boolean flag=true; if(connection!=null){ try { connection.close(); connection=null; }catch (Exception e){ e.printStackTrace(); flag=false; } } if(preparedStatement!=null){ try { preparedStatement.close(); preparedStatement=null; }catch (Exception e){ e.printStackTrace(); flag=false; } } if(resultSet!=null){ try { resultSet.close(); resultSet=null; }catch (Exception e){ e.printStackTrace(); flag=false; } } return flag; } 4、定义获取用户信息的接口 package com.tin.Dao.user; import com.tin.pojo.UserInfo; public interface UserDao { //得到登入的用户对象（前面说的对应userinfo表对应的实体类） public UserInfo getLoginUser( String userName,String password); } 5、接口的实现类 package com.tin.Dao.user; import com.tin.pojo.UserInfo; import com.tin.util.BaseDao; import org.junit.jupiter.api.Test; import java.sql.Connection; import java.sql.ResultSet; public class UserDaoImpl implements UserDao{ public UserInfo getLoginUser(String userName, String password) throws Exception { Connection connection = BaseDao.getconnection(); String sql = \"select * from userInfo where userName = ? and userPassword = ?\"; Object[] params={userName,password}; ResultSet resultSet = BaseDao.excuteQuery(connection, sql, params); UserInfo userInfo = new UserInfo(); if(resultSet.next()){ userInfo.setUserID(resultSet.getInt(\"userID\")); userInfo.setUserName(resultSet.getString(\"userName\")); userInfo.setUserPassword(resultSet.getString(\"userPassword\")); userInfo.setPhone(resultSet.getString(\"phone\")); userInfo.setAddress(resultSet.getString(\"address\")); userInfo.setRoleID(resultSet.getInt(\"roleID\")); } BaseDao.closeResource(connection,resultSet); return userInfo; } } 6、定义login业务处理的接口 package com.tin.service; import com.tin.pojo.UserInfo; public interface LoginService { //获取用户登入的对象，如果用户或密码不正确就返回null public UserInfo login(String userName,String passwo","date":"2021/01/09","objectID":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E7%99%BB%E5%85%A5%E6%A8%A1%E5%9D%97/:0:3","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（4）用户登入模块","uri":"/posts/javaweb%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E7%94%A8%E6%88%B7%E7%99%BB%E5%85%A5%E6%A8%A1%E5%9D%97/"},{"categories":["JavaWeb"],"content":"javaweb实例-订单管理系统（3）公共配置","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE/","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（3）公共配置","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE/"},{"categories":["JavaWeb"],"content":"设置数据库配置信息 在resource 目录下编写数据库配置文件 db.properties drive=com.mysql.jdbc.Driver url=jdbc:mysql://127.0.0.1:3306/smbms?characterEncoding=UTF-8 userName=root password=root ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE/:0:1","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（3）公共配置","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE/"},{"categories":["JavaWeb"],"content":"创建操作数据库的工具类 package com.tin.util; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; //操作数据库的公共类 public class BaseDao { private static String driver; private static String url; private static String userName; private static String password; //静态代码块类加载的时候就执行,获取数据库配置信息 static { //通过类加载器读取对应的资源 InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(\"db.properties\"); Properties properties = new Properties(); try { properties.load(is); } catch (IOException e) { e.printStackTrace(); } driver=properties.getProperty(\"driver\"); url=properties.getProperty(\"url\"); userName=properties.getProperty(\"userName\"); password=properties.getProperty(\"password\"); try { is.close(); } catch (IOException e) { e.printStackTrace(); } } //获取数据库链接 public static Connection getconnection() throws Exception { Connection connection=null; //加载驱动 Class.forName(driver); //获取数据库连接 connection= DriverManager.getConnection(url,userName,password); return connection; } //编写查询公共方法 public static ResultSet excuteQuery(Connection connection,String sql,Object[] parms) throws Exception { ResultSet resultSet=null; PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i \u003c parms.length; i++) { preparedStatement.setObject(i+1,parms[i]); } resultSet=preparedStatement.executeQuery(sql); return resultSet; } //编写增删改公共方法 public static int excuteUpdate(Connection connection,String sql,Object[] parms) throws Exception { int updateRows; PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i \u003c parms.length; i++) { preparedStatement.setObject(i+1,parms[i]); } updateRows=preparedStatement.executeUpdate(sql); return updateRows; } //关闭资源 public static boolean closeResource(Connection connection,PreparedStatement preparedStatement,ResultSet resultSet){ boolean flag=true; if(connection!=null){ try { connection.close(); connection=null; }catch (Exception e){ e.printStackTrace(); flag=false; } } if(connection!=preparedStatement){ try { preparedStatement.close(); preparedStatement=null; }catch (Exception e){ e.printStackTrace(); flag=false; } } if(resultSet!=null){ try { resultSet.close(); resultSet=null; }catch (Exception e){ e.printStackTrace(); flag=false; } } return flag; } } ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE/:0:2","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（3）公共配置","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE/"},{"categories":["JavaWeb"],"content":"用过滤器Filter 设置网页中文编码 package com.tin.filter; import javax.servlet.*; import java.io.IOException; public class EncodingFilter implements Filter { public void init(FilterConfig filterConfig) throws ServletException { } public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //设置中文编码 servletRequest.setCharacterEncoding(\"utf-8\"); servletResponse.setContentType(\"text/html\"); servletResponse.setCharacterEncoding(\"utf-8\"); filterChain.doFilter(servletRequest,servletResponse); } public void destroy() { } } 注册过滤器 \u003cfilter\u003e \u003cfilter-name\u003eEncoding\u003c/filter-name\u003e \u003cfilter-class\u003ecom.tin.filter.EncodingFilter\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eEncoding\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE/:0:3","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（3）公共配置","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE/"},{"categories":["JavaWeb"],"content":"javaweb实例-订单管理系统（2）设计数据库","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93/","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（2）设计数据库","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb"],"content":"订单管理系统E-R图 ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（2）设计数据库","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb"],"content":"创建表 根据简略的ER图创建六个表 1、用户表 用户id、用户姓名、用户密码、用户权限，手机号码、地址 CREATETABLEUSER(idINTPRIMARYKEY,userNameVARCHAR(50),userPasswordVARCHAR(50),roleIDINT,phoneVARCHAR(11),addressVARCHAR(50)); 2、商品表 商品id、商品名称、价格、计量单位、库存、商品信息（商品介绍） createtableproduct{productIDintprimarykey,productNameVARCHAR(50),pricefloat,unitVARCHAR(50),inventoryint,productInfoVARCHAR(100)} 3、供应商 供应商id、供应商名称、供应商地址、手机 createtablesupplier(supplierIDINTPRIMARYKEY,supplierNameVARCHAR(50),phoneVARCHAR(11),addressVARCHAR(50)); 4、订单表 用户id 、商品id 、购买数量、下单日期 CREATETABLEorders(userIDINT,productIDINT,quantityINT,createDateDATE,PRIMARYKEY(userID,productID)); 5、采购表 供应商id、商品id、采购数量、采购日期 createtablepurchase(supplierIDINT,productIDINT,quantityINT,createDateDATE,PRIMARYKEY(supplierID,productID)); 6、权限表 角色id、角色名称、角色权限说明 CREATETABLErole(roleIdINTPRIMARYKEY,roleNameVARCHAR(50),roleInfoVARCHAR(100)); ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93/:1:1","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（2）设计数据库","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb"],"content":"创建实体类 必须有一个无参数构造 属性必须私有化 必须有对应的get/set方法 一般用来和数据库字段作映射 表—\u003e类 字段—\u003e属性 行记录—\u003e对象 以用userInfo 表为例 在实体类包里创建UserInfo 类 package com.tin.pojo; public class UserInfo { private int userID; private String userName; private String userPassword; private int roleID; private String phone; private String address; //通过联合查询获取用户的角色名称 private String userRoleName; public UserInfo() { } public int getUserID() { return userID; } public String getUserName() { return userName; } public String getUserPassword() { return userPassword; } public int getRoleID() { return roleID; } public String getPhone() { return phone; } public String getAddress() { return address; } public void setUserID(int userID) { this.userID = userID; } public void setUserName(String userName) { this.userName = userName; } public void setUserPassword(String userPassword) { this.userPassword = userPassword; } public void setRoleID(int roleID) { this.roleID = roleID; } public void setPhone(String phone) { this.phone = phone; } public void setAddress(String address) { this.address = address; } } ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93/:1:2","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（2）设计数据库","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["JavaWeb"],"content":"javaweb实例-订单管理系统（1）项目搭建","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（1）项目搭建","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":["JavaWeb"],"content":"一、 搭建一个maven web项目 选择maven,然后勾选，选择webapp模板 只需设置项目名称 选好Maven路径、maven\\conf\\setting 路径、maven仓库 （可以选择idea自带的maven，则不需要修改），点击完成 ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:0:1","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（1）项目搭建","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":["JavaWeb"],"content":"二、配置tomcat 服务器 说明：专业版的idea才自带tomcat的服务，如果不是请自行百度解决 配置tomcat 添加tomcat 运行的web项目（war 包就是web 的压缩文件），点下面的+号 配置完成后，测试运行javaweb ,能访问这个页面就代表项目配置成功 ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:0:2","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（1）项目搭建","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":["JavaWeb"],"content":"三、导入项目依赖的jar 包 打开pom.xml 文件添加项目所需的依赖 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.tin\u003c/groupId\u003e \u003cartifactId\u003eManageSystem\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003ewar\u003c/packaging\u003e \u003cdependencies\u003e \u003c!--单元测试--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.11\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!--导入servlet--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--导入jsp--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet.jsp\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet.jsp-api\u003c/artifactId\u003e \u003cversion\u003e2.3.3\u003c/version\u003e \u003c/dependency\u003e \u003c!--导入jstl表达式的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejstl\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--导入standard标签库--\u003e \u003cdependency\u003e \u003cgroupId\u003etaglibs\u003c/groupId\u003e \u003cartifactId\u003estandard\u003c/artifactId\u003e \u003cversion\u003e1.1.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--导入mysql驱动--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.25\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:0:3","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（1）项目搭建","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":["JavaWeb"],"content":"创建项目包结构 按图创建文件结构 ","date":"2021/01/03","objectID":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:0:4","tags":["javaweb实例","JavaWeb"],"title":"javaweb实例-订单管理系统（1）项目搭建","uri":"/posts/javaweb%E7%9A%84%E5%AE%9E%E4%BE%8B--%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F--%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":["JavaWeb"],"content":"javaweb中jdbc使用方法","date":"2021/01/03","objectID":"/posts/javaweb%E4%B8%ADjdbc%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","tags":["jdbc","JavaWeb"],"title":"javaweb中jdbc使用方法","uri":"/posts/javaweb%E4%B8%ADjdbc%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"categories":["JavaWeb"],"content":"什么是jdbc jdbc: java database connect java数据库连接 在pom.xml配置文件中导入jar 包 \u003c!--导入mysql驱动--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.25\u003c/version\u003e \u003c/dependency\u003e idea连接数据库 配置数据连接信息 设置时区 Asia/Shanghai ","date":"2021/01/03","objectID":"/posts/javaweb%E4%B8%ADjdbc%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/:0:0","tags":["jdbc","JavaWeb"],"title":"javaweb中jdbc使用方法","uri":"/posts/javaweb%E4%B8%ADjdbc%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"categories":["JavaWeb"],"content":"用java 连接数据库 jdbc 固定步骤： 加载驱动 连接数据库 获取向数据库发送SQL语句的对象 编写Sql 语句 执行SQL语句 获取SQL执行结果 关闭连接 package com.tin.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class MysqlJDBC { // Class.forName() 要抛出ClassNotFoundException //DriverManager.getConnection() 要抛出SQLException public static void main(String[] args) throws Exception { //设置配置信息 String url=\"jdbc:mysql://127.0.0.1:3306/smbms?characterEncoding=UTF-8\"; String user=\"root\"; String password=\"root\"; //1、加载驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、连接数据库，connection 代表数据库，DriverManager驱动管理 Connection connection = DriverManager.getConnection(url, user, password); //3、向数据库发送SQL的对象，用它进行增删改查 Statement statement = connection.createStatement(); //4、编写查询SQL语句 String sql=\"select * from smbms_user\"; //5、执行查询SQL，返回一个ResultSet 结果集，是一个链表 ResultSet resultSet = statement.executeQuery(sql); //6、获取查询结果 while(resultSet.next()){ //通过列名获取值resultSet.getObject System.out.println(\"id:\"+resultSet.getObject(\"id\")); System.out.println(\"userName:\"+resultSet.getObject(\"userName\")); System.out.println(\"userRole:\"+resultSet.getObject(\"userRole\")); } //7、关闭连接，释放资源 resultSet.close(); statement.close(); connection.close(); } } 预编译SQL package com.tin.jdbc; import java.sql.*; public class MysqlJDBC { // Class.forName() 要抛出ClassNotFoundException 否则报错 //DriverManager.getConnection() 要抛出SQLException public static void main(String[] args) throws Exception { //设置配置信息 String url=\"jdbc:mysql://127.0.0.1:3306/smbms?characterEncoding=UTF-8\"; String user=\"root\"; String password=\"root\"; //1、加载驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2、连接数据库 Connection connection = DriverManager.getConnection(url, user, password); //3、编写查询SQL语句，？占位符 String sql=\"INSERT INTO test (id,userName) VALUES (?,?);\"; //4、预编译sql PreparedStatement preparedStatement = connection.prepareStatement(sql); //5、插入多行数据，给？赋值 for(int i=0;i\u003c10;i++){ // 给第一个占位符 ？ 赋值 preparedStatement.setInt(1,i); //给第二个占位符 ？ 赋值 preparedStatement.setString(2,\"测试\"); //6、执行SQL int res = preparedStatement.executeUpdate(); if(res==1){ System.out.println(\"插入成功\"); }else{ break; } } //7、关闭连接 preparedStatement.close(); connection.close(); } } jdbc事务 事务可以理解为一段SQL语句，事务要么都成功，要么都失败 开启事务 事务提交 commit() 事务回滚 rockback() 关闭事务 比如 A 给B转账100元 1、A的钱-100元 2、B的钱+100元 步骤1和2就必须同时成功或者同时失败 一旦步骤1执行步骤2没执行就会出现业务错误 ","date":"2021/01/03","objectID":"/posts/javaweb%E4%B8%ADjdbc%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/:0:1","tags":["jdbc","JavaWeb"],"title":"javaweb中jdbc使用方法","uri":"/posts/javaweb%E4%B8%ADjdbc%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"categories":["JavaWeb"],"content":"简单理解Filter过滤器","date":"2021/01/03","objectID":"/posts/filter-%E8%BF%87%E6%BB%A4%E5%99%A8/","tags":["Filter","JavaWeb"],"title":"简单理解Filter过滤器","uri":"/posts/filter-%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"categories":["JavaWeb"],"content":"什么是过滤器 Filter :过滤器，用来过滤网站数据 处理中文乱码 拦截不需要的请求 ","date":"2021/01/03","objectID":"/posts/filter-%E8%BF%87%E6%BB%A4%E5%99%A8/:0:0","tags":["Filter","JavaWeb"],"title":"简单理解Filter过滤器","uri":"/posts/filter-%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"categories":["JavaWeb"],"content":"创建一个过滤器 注意要先导入servlet 依赖，选对Filter 接口 创建过滤器实现中文编码 package com.tin.filter; import javax.servlet.*; import java.io.IOException; public class CharacterEncodingFilter implements Filter { @Override //初始化，服务器启动时就完成初始化 public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //设置中文编码 servletRequest.setCharacterEncoding(\"utf-8\"); servletResponse.setContentType(\"text/html\"); servletResponse.setCharacterEncoding(\"utf-8\"); //chain:链 过滤器的代码在过滤特定请求时都会执行（满足filter注册映射的url请求路径时） //必须执行下面这条代码，让请求转接到servlet，否则就会拦截这个请求 filterChain.doFilter(servletRequest,servletResponse); } @Override //销毁 服务器关闭时执行 public void destroy() { } } 在web.xml注册过滤器 \u003cfilter\u003e \u003cfilter-name\u003eEncoding\u003c/filter-name\u003e \u003cfilter-class\u003ecom.tin.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eEncoding\u003c/filter-name\u003e \u003c!--设置过滤器适用的请求路径--\u003e \u003curl-pattern\u003e/session/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2021/01/03","objectID":"/posts/filter-%E8%BF%87%E6%BB%A4%E5%99%A8/:0:1","tags":["Filter","JavaWeb"],"title":"简单理解Filter过滤器","uri":"/posts/filter-%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"categories":["JavaWeb"],"content":"简单理解MVC三层模型","date":"2021/01/02","objectID":"/posts/%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%9D%E7%90%86%E8%A7%A3mvc%E4%B8%89%E5%B1%82%E6%A8%A1%E5%9E%8B/","tags":["MVC","JavaWeb"],"title":"简单理解MVC三层模型","uri":"/posts/%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%9D%E7%90%86%E8%A7%A3mvc%E4%B8%89%E5%B1%82%E6%A8%A1%E5%9E%8B/"},{"categories":["JavaWeb"],"content":"什么是MVC三层模型 Model 模型、View 视图、Controller 控制器 前期模型：客户端直接访问控制层，控制层可以直接操作数据库 servlet—\u003ejdbc—\u003e数据库 不足之处：程序耦合度高，不利于维护 servlet代码中需要处理： 请求、响应、视图跳转、JDBC、业务代码、逻辑代码（功能复杂） 改进： 架构：将业务逻辑处理封装成模块（多加一层来实现JDBC、业务代码、逻辑代码），控制层servlet 只需要调用这个模块 拓展：架构的基本思想就是将功能拆分模块化，例如JDBC,我们不需要去掌握如何用java驱动mysql、oracle、sqlserver等各种不同服务器的底层实现方法，只需要去调用JDBC这一层模块 Model 业务处理：业务逻辑service 数据持久层：数据的增删改查 Dao View 展示数据; 提供链接发起Servlet请求;如超链接、表单提交、鼠标点击跳转等 Controller 接收用户的请求（req:请求参数、Session信息） 交给业务层处理对应的请求 控制视图的跳转 用户登入—\u003e接收用户的登入请求—\u003e处理用户的请求（获取用户登入的账号和密码）—\u003e交给业务层处理登入业务（判断用户密码是否正确）—\u003eDao层查询用户名和密码是否正确—\u003e访问数据库的数据 ","date":"2021/01/02","objectID":"/posts/%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%9D%E7%90%86%E8%A7%A3mvc%E4%B8%89%E5%B1%82%E6%A8%A1%E5%9E%8B/:0:0","tags":["MVC","JavaWeb"],"title":"简单理解MVC三层模型","uri":"/posts/%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%9D%E7%90%86%E8%A7%A3mvc%E4%B8%89%E5%B1%82%E6%A8%A1%E5%9E%8B/"},{"categories":["JavaWeb"],"content":"一个 javabean 的简单例子","date":"2021/01/02","objectID":"/posts/javabean%E7%9A%84%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/","tags":["javabean","JavaWeb"],"title":"一个 javabean 的简单例子","uri":"/posts/javabean%E7%9A%84%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/"},{"categories":["JavaWeb"],"content":"javaBean javaBean 特定写法 必须有一个无参数构造 属性必须私有化 必须有对应的get/set方法 == 一般用来和数据库字段作映射== 表—\u003e类 字段—\u003e属性 行记录—\u003e对象 模拟一张student 表 构造对应的类 package com.tin.pojo; public class Student { private int id; private String name; private int age; public Student(int id, String name, int age) { this.id = id; this.name = name; this.age = age; } public Student() { } public void setId(int id) { this.id = id; } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public int getId() { return id; } public String getName() { return name; } public int getAge() { return age; } } 在jsp使用JavaBean \u003c%@ page import=\"com.tin.pojo.Student\" %\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 等同于： Student student = new Student(); student.setName(\"张三\"); student.setAge(22); student.getName(); student.getAge(); !--\u003e \u003cjsp:useBean id=\"student\" class=\"com.tin.pojo.Student\" scope=\"page\" /\u003e \u003cjsp:setProperty name=\"student\" property=\"id\" value=\"1\" /\u003e \u003cjsp:setProperty name=\"student\" property=\"name\" value=\"张三\" /\u003e \u003cjsp:setProperty name=\"student\" property=\"age\" value=\"22\" /\u003e 姓名：\u003cjsp:getProperty name=\"student\" property=\"name\"/\u003e 年龄：\u003cjsp:getProperty name=\"student\" property=\"age\"/\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021/01/02","objectID":"/posts/javabean%E7%9A%84%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/:0:1","tags":["javabean","JavaWeb"],"title":"一个 javabean 的简单例子","uri":"/posts/javabean%E7%9A%84%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/"},{"categories":["JavaWeb"],"content":"jsp基础语法和指令","date":"2021/01/02","objectID":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/","tags":["jsp","JavaWeb"],"title":"jsp基础语法和指令","uri":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/"},{"categories":["JavaWeb"],"content":"Maven导入jsp依赖jar包 \u003c!-- Servlet依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c/dependency\u003e \u003c!-- JSP依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet.jsp\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet.jsp-api\u003c/artifactId\u003e \u003cversion\u003e2.3.3\u003c/version\u003e \u003c/dependency\u003e \u003c!--引入Javaee7开始--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax\u003c/groupId\u003e \u003cartifactId\u003ejavaee-api\u003c/artifactId\u003e \u003cversion\u003e7.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--引入Javaee7结束--\u003e \u003c!--引入JSTL开始--\u003e \u003cdependency\u003e \u003cgroupId\u003ejstl\u003c/groupId\u003e \u003cartifactId\u003ejstl\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2021/01/02","objectID":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/:0:1","tags":["jsp","JavaWeb"],"title":"jsp基础语法和指令","uri":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/"},{"categories":["JavaWeb"],"content":"jsp 基础语法 jsp 表达式 \u003c%-- jsp 表达式 作用：用来将程序的输出，输出到客户端 格式：\u003c%=变量或者表达式%\u003e --%\u003e \u003c%=new java.util.Date()%\u003e jsp 脚本片段,可以和html任意嵌套 \u003c%-- jsp 脚本片段 作用：就是一段java程序 格式：\u003c%一段java程序%\u003e --%\u003e \u003c% int sum=0; for(int i=0;i\u003c10;i++){ \u003e% \u003ch2\u003e循环\u003c/h2\u003e \u003c% sum+=i; } out.println(\"\u003ch1\u003eSum=\"+sum+\"\u003c/h1\u003e\"); %\u003e jsp 声明 \u003c%! //jsp 声明，定义全局变量（类变量） int a=0; %\u003e 本质上就是通过\u003c%!java声明代码%\u003e是放在XXX_jsp.java的类中，是全局的作用域 \u003c%java代码%\u003e是放在XXX_jsp.java下的_jspService方法中，是局部的作用域 ","date":"2021/01/02","objectID":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/:0:2","tags":["jsp","JavaWeb"],"title":"jsp基础语法和指令","uri":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/"},{"categories":["JavaWeb"],"content":"jsp指令 \u003c%--指定页面格式--%\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%--指定发生错误时跳转的页面--%\u003e \u003c%@ page errorPage=\"/WEB-INF/500.jsp\" %\u003e \u003c%--加载其他jsp的资源--%\u003e \u003c%@ include file=\"hello.jsp\"%\u003e ","date":"2021/01/02","objectID":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/:0:3","tags":["jsp","JavaWeb"],"title":"jsp基础语法和指令","uri":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/"},{"categories":["JavaWeb"],"content":"jsp 内置对象和作用域 PageContext Request Response Session Application 【ServletContext】 config 【Servletconfig】 out page exception PageContext：一般不用这个保存数据 Request:客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻 Session:客户端向服务器发送请求，产生的数据，用户看完后还可能用到，比如：购物车 Application:客户端向服务器发送请求，产生的数据，用户看完后其他用户还可能用到，比如：游戏中的聊天信息 \u003c% //保存的数据只在一个页面中有效 pageContext.setAttribute(\"num1\",\"1\"); //保存的数据只在一次请求中有效，请求转发会携带这个信息 request.setAttribute(\"num2\",\"2\"); //保存的数据只在服务器有效，从打开服务器到关闭服务器 application.setAttribute(\"num3\",\"3\"); //保存的数据只在一次会话有效，从打开浏览器到关闭浏览器 session.setAttribute(\"num4\",\"4\"); //从底层到高层的作用域：page--\u003erequest--\u003esession--\u003eapplication //从底层往高层找所需要的数据 String num3 =(String) pageContext.findAttribute(\"num3\"); %\u003e ","date":"2021/01/02","objectID":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/:0:4","tags":["jsp","JavaWeb"],"title":"jsp基础语法和指令","uri":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/"},{"categories":["JavaWeb"],"content":"EL表达式 格式：${ } 获取数据 执行运算 获取web常用对象 ","date":"2021/01/02","objectID":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/:0:5","tags":["jsp","JavaWeb"],"title":"jsp基础语法和指令","uri":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/"},{"categories":["JavaWeb"],"content":"jsp标签 \u003c!--添加hello.jsp的内容--\u003e \u003cjsp:include page=\"hello.jsp\"\u003e\u003c/jsp:include\u003e \u003c!--转发到hello.jsp--\u003e \u003cjsp:forward page=\"/hello.jsp\"\u003e \u003c!--设置跳转链接参数--\u003e \u003cjsp:param name=\"name\" value=\"小明\"/\u003e \u003c/jsp:forward\u003e ","date":"2021/01/02","objectID":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/:0:6","tags":["jsp","JavaWeb"],"title":"jsp基础语法和指令","uri":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/"},{"categories":["JavaWeb"],"content":"jstl标签 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c!-- 引用jstl核心标签库 --\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform\u003e \u003cinput type=\"text\" name=\"user\" value=\"${param.user}\"\u003e \u003cinput type=\"submit\" value=\"登入\"\u003e \u003c/form\u003e \u003c！-- 测试登入的是否是admin c:if 就是java中的if逻辑判断如果为true，则执行 c:out 输出内容 --\u003e \u003cc:if test=\"${param.user=='admin'}\" var=\"isAdmin\"\u003e \u003cc:out value=\" Welcome Admin \"\u003e\u003c/c:out\u003e \u003c/c:if\u003e \u003cc:out value=\"${isAdmin}\"\u003e\u003c/c:out\u003e \u003c！-- c:forEach 遍历数组 var 遍历的变量名 等同于int item=list[i]; items 遍历的对象 就是list 从0 开始计数 begin end step 开始位置 结束位置 步长 --\u003e \u003c% ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"张三\"); list.add(\"李四\"); list.add(\"王五\"); list.add(\"赵六\"); list.add(\"宋七\"); request.setAttribute(\"list\",list); %\u003e \u003cc:forEach items=\"${list}\" var=\"item\" begin=\"1\" end=\"3\" step=\"2\" \u003e \u003cc:out value=\"${item}\"\u003e\u003c/c:out\u003e \u003c/c:forEach\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021/01/02","objectID":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/:1:0","tags":["jsp","JavaWeb"],"title":"jsp基础语法和指令","uri":"/posts/jsp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%92%8C%E6%8C%87%E4%BB%A4/"},{"categories":["JavaWeb"],"content":"从源码角度了解jsp本质","date":"2020/12/31","objectID":"/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E4%BA%86%E8%A7%A3jsp%E6%9C%AC%E8%B4%A8/","tags":["jsp","JavaWeb"],"title":"从源码角度了解jsp本质","uri":"/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E4%BA%86%E8%A7%A3jsp%E6%9C%AC%E8%B4%A8/"},{"categories":["JavaWeb"],"content":"什么是JSP java server pages:java服务端页面，和servlet一样，用于动态web技术。 最大的特点： ==完全兼容Html和嵌入java代码== ","date":"2020/12/31","objectID":"/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E4%BA%86%E8%A7%A3jsp%E6%9C%AC%E8%B4%A8/:0:1","tags":["jsp","JavaWeb"],"title":"从源码角度了解jsp本质","uri":"/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E4%BA%86%E8%A7%A3jsp%E6%9C%AC%E8%B4%A8/"},{"categories":["JavaWeb"],"content":"JSP原理 jsp在服务器内部运行（以tomcat为例）： index.jsp \u003chtml\u003e \u003cbody\u003e \u003ch2\u003eHello World!\u003c/h2\u003e \u003c/body\u003e \u003c/html\u003e 在idea 运行javaweb程序，会在Output输出中找到==jsp==转为==.java==的文件路径 找到javaweb在idea运行生成的项目文件后，在下面这个路径可以找到javaweb的jsp转java文件 ==\\work\\Catalina\\localhost\\Servlet_war\\org\\apache\\jsp== 先观察hello.jsp文件 \u003c%-- Created by IntelliJ IDEA. User: admin Date: 2020/12/28 Time: 23:13 To change this template use File | Settings | File Templates. --%\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch2\u003eHello World!\u003c/h2\u003e \u003c/body\u003e \u003c/html\u003e hello_jsp.java public final class hello_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports public abstract class HttpJspBase extends HttpServlet implements HttpJspPage hello_jsp的父类是HttpJspBase，HttpJspBase又是继承 HttpServlet ==jsp文件本质上就是Servlet== hello_jsp.java主要方法 //初始化 public void _jspInit() { } //销毁 public void _jspDestroy() { } //jsp服务，参数为request、response public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {} hello_jsp.java 的_jspService方法 //参数是request和response public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException { //判断请求方法 final java.lang.String _jspx_method = request.getMethod(); if (!\"GET\".equals(_jspx_method) \u0026\u0026 !\"POST\".equals(_jspx_method) \u0026\u0026 !\"HEAD\".equals(_jspx_method) \u0026\u0026 !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) { response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, \"JSPs only permit GET POST or HEAD\"); return; } //内置了多个对象 // pageContext 页面上下文 final javax.servlet.jsp.PageContext pageContext; // session 会话信息 javax.servlet.http.HttpSession session = null; // application 就是ServletContext final javax.servlet.ServletContext application; //config 配置 final javax.servlet.ServletConfig config; //out 输出对象 等同于response.getWriter() javax.servlet.jsp.JspWriter out = null; // page 当前页面 final java.lang.Object page = this; //加上方法参数总共九大对象 //final javax.servlet.http.HttpServletRequest request //final javax.servlet.http.HttpServletResponse response //下面不需要了解 javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try { //设置响应的页面类型 response.setContentType(\"text/html;charset=UTF-8\"); //以下这些对象我们可以在jsp java 代码中直接使用 pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; //输出jsp内容 out.write(\"\\r\\n\"); out.write(\"\\r\\n\"); out.write(\"\u003chtml\u003e\\r\\n\"); out.write(\"\u003chead\u003e\\r\\n\"); out.write(\" \u003ctitle\u003eTitle\u003c/title\u003e\\r\\n\"); out.write(\"\u003c/head\u003e\\r\\n\"); out.write(\"\u003cbody\u003e\\r\\n\"); out.write(\"\u003ch2\u003eHello World!\u003c/h2\u003e\\r\\n\"); out.write(\"\u003c/body\u003e\\r\\n\"); out.write(\"\u003c/html\u003e\\r\\n\"); //异常处理 } catch (java.lang.Throwable t) { if (!(t instanceof javax.servlet.jsp.SkipPageException)){ out = _jspx_out; if (out != null \u0026\u0026 out.getBufferSize() != 0) try { if (response.isCommitted()) { out.flush(); } else { out.clearBuffer(); } } catch (java.io.IOException e) {} if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); } } finally { _jspxFactory.releasePageContext(_jspx_page_context); } } } ","date":"2020/12/31","objectID":"/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E4%BA%86%E8%A7%A3jsp%E6%9C%AC%E8%B4%A8/:0:2","tags":["jsp","JavaWeb"],"title":"从源码角度了解jsp本质","uri":"/posts/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E4%BA%86%E8%A7%A3jsp%E6%9C%AC%E8%B4%A8/"},{"categories":["网络编程"],"content":"通过Java源码理解cookie 和 ssesion","date":"2020/12/28","objectID":"/posts/%E9%80%9A%E8%BF%87java%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3cookie%E5%92%8Cssesion/","tags":["cookie","ssesion","网络编程"],"title":"通过Java源码理解cookie 和 ssesion","uri":"/posts/%E9%80%9A%E8%BF%87java%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3cookie%E5%92%8Cssesion/"},{"categories":["网络编程"],"content":"一个网站怎么辨别你是否来过？ 1、服务器给客户端一个特定cookie(存有身份认证信息的一个对象) 2、客户端下次浏览这个网站时，就会将这个cookie随请求发送到服务器。服务器就会根据cookie携带的信息来辨别你是否登入过这个网站 简单的理解就是： ==cookie就是存储信息的一个容器。== 抓取百度的包： ","date":"2020/12/28","objectID":"/posts/%E9%80%9A%E8%BF%87java%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3cookie%E5%92%8Cssesion/:0:1","tags":["cookie","ssesion","网络编程"],"title":"通过Java源码理解cookie 和 ssesion","uri":"/posts/%E9%80%9A%E8%BF%87java%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3cookie%E5%92%8Cssesion/"},{"categories":["网络编程"],"content":"会话 1、什么是会话？ 打开会话：用户打开一个浏览器，进入一个网站如bilibili 结束会话：离开网站或退出登入 会话：就是你访问一个网站和它的网页的过程。 2、cookie保存会话 客户端技术（响应，请求），保存信息 package com.tin.servlet; import javax.servlet.ServletException; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; public class CookieServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置中文编码 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); PrintWriter out = resp.getWriter(); Cookie user = new Cookie(\"username\", \"123456\"); //获取浏览器的cookies(有多个cookie) Cookie[] cookies = req.getCookies(); //如果是第一次进入网站就会给浏览器一个带有（username,123456）键值对信息的cookie //如果不是就输出网站所给的特殊标记 //这里是通过判断cookie的name来进行区分用户身份 int count; for(count=0;count\u003ccookies.length;count++){ //用cookie携带信息认证你是否是网站用户 if(cookies[count].getName().equals(user.getName()) \u0026\u0026cookies[count].getValue().equals(user.getValue())){ out.println(user.getName()+\"\"+user.getValue()); break; } } if(count==cookies.length){ resp.addCookie(user); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 3、session保存会话 服务端技术，保存信息 ==Session==是唯一的 package com.tin.servlet; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; public class SessionServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html\"); //得到Sesion HttpSession session = req.getSession(); Object attribute = session.getAttribute(\"user\"); if(attribute==null){ resp.getWriter().println(\"第一次登入\"); //用session存储用户信息 session.setAttribute(\"user\",\"123456\"); }else{ resp.getWriter().println(\"欢迎再次浏览\"); } } } cookie和session区别 cookie是把用户的数据写给用户浏览器，浏览器可以保存==多个cookie==，浏览器关闭，cookie就失效了 session是一个特殊的cookie,==一个浏览器只能保存一个==，服务端保存（保存重要信息，减少服务器资源的浪费），session是服务器创建的，当服务器关闭或者手动设置session的失效时间才能使session失效 session 应用场景： 保存用户登入信息 购物车信息 在整个网站中经常会使用的数据 ","date":"2020/12/28","objectID":"/posts/%E9%80%9A%E8%BF%87java%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3cookie%E5%92%8Cssesion/:0:2","tags":["cookie","ssesion","网络编程"],"title":"通过Java源码理解cookie 和 ssesion","uri":"/posts/%E9%80%9A%E8%BF%87java%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3cookie%E5%92%8Cssesion/"},{"categories":["网络编程"],"content":"http的简单介绍","date":"2020/12/23","objectID":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/","tags":["http","网络编程"],"title":"http的简单介绍","uri":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/"},{"categories":["网络编程"],"content":"http ","date":"2020/12/23","objectID":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/:1:0","tags":["http","网络编程"],"title":"http的简单介绍","uri":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/"},{"categories":["网络编程"],"content":"什么是HTTP HTTP：超文本传输协议 是一个简单的==请求-响应==协议，通常运行在==tcp==上。 超文本：图片、音频、视频、定位、地图。。。 端口号：80 HTTPS：传输层加密协议 和HTTPS区别不大，https更安全 端口号：443 ","date":"2020/12/23","objectID":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/:2:0","tags":["http","网络编程"],"title":"http的简单介绍","uri":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/"},{"categories":["网络编程"],"content":"HTTP发展 http1.0 客户端与web服务器连接后，只能获得一个web资源 http1.1 客户端与web服务器连接后，可以获得多个web资源 ","date":"2020/12/23","objectID":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/:3:0","tags":["http","网络编程"],"title":"http的简单介绍","uri":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/"},{"categories":["网络编程"],"content":"http请求 客户端 –\u003e发送请求 –\u003e服务器 百度为例：（在百度网站下打开开发者工具 Network ） ","date":"2020/12/23","objectID":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/:4:0","tags":["http","网络编程"],"title":"http的简单介绍","uri":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/"},{"categories":["网络编程"],"content":"Http基本信息 状态码： 响应成功 200 请求重定向 3XX 找不到资源 404 服务器代码错误 500 网关错误502 百度为例：（在百度网站下打开开发者工具 Network ） ","date":"2020/12/23","objectID":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/:5:0","tags":["http","网络编程"],"title":"http的简单介绍","uri":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/"},{"categories":["网络编程"],"content":"http响应头部信息 服务器–\u003e响应–\u003e客户端 http请求头部信息： ==这些信息都可以通过HttpServletResponse 和 HttpServletRequest对象进行修改==（博客的javaWeb文章会涉及） ","date":"2020/12/23","objectID":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/:6:0","tags":["http","网络编程"],"title":"http的简单介绍","uri":"/posts/http%E7%9A%84%E7%AE%80%E6%98%93%E7%90%86%E8%A7%A3/"},{"categories":["JavaWeb"],"content":"HttpServletResponse和HttpServletRequest常见应用","date":"2020/12/23","objectID":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/","tags":["servlet","JavaWeb"],"title":"HttpServletResponse和HttpServletRequest常见应用","uri":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/"},{"categories":["JavaWeb"],"content":"HttpServletResponse和HttpServletRequest web服务器接收到客户端请求，针对这个请求，分别创建一个代表请求的HttpServletRequest，代表响应的HttpServletResponse 如果要获取客户端请求过来的参数，就用HttpServletRequest对象 如果要给客户端响应一些信息，就用HttpServletResponse对象 ","date":"2020/12/23","objectID":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/:0:1","tags":["servlet","JavaWeb"],"title":"HttpServletResponse和HttpServletRequest常见应用","uri":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/"},{"categories":["JavaWeb"],"content":"HttpServletResponse的接口 1、向浏览器发送数据的方法 ServletOutputStream getOutputStream() throws IOException; PrintWriter getWriter() throws IOException; 2、负责向浏览器发送响应头的方法 void setCharacterEncoding(String var1); void setContentType(String var1); void setHeader(String var1, String var2); void addHeader(String var1, String var2); 3、响应状态码： //响应成功 200 int SC_OK = 200; //请求重定向 3XX int SC_MULTIPLE_CHOICES = 300; //找不到资源 404 int SC_NOT_FOUND = 404; //服务器代码错误 500 int SC_INTERNAL_SERVER_ERROR = 500; //网关错误 int SC_BAD_GATEWAY = 502; ","date":"2020/12/23","objectID":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/:0:2","tags":["servlet","JavaWeb"],"title":"HttpServletResponse和HttpServletRequest常见应用","uri":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/"},{"categories":["JavaWeb"],"content":"HttpServletResponse的常见应用 1、向浏览器输出消息 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); resp.getWriter().print(\"你好，小明\"); } 2、下载文件 package com.tin.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.FileInputStream; import java.io.IOException; import java.net.URLEncoder; public class Servlet_1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取下载文件的路径 String realPath = \"E:\\\\javaWebTest\\\\Servlet\\\\src\\\\main\\\\resources\\\\风景.png\"; //System.out.print(realPath); //获取下载文件名 String filename = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); //设置响应的消息头 resp.setContentType(\"text/html;charset=UTF-8\"); //设置响应类型中包含文件附件 resp.setHeader(\"Content-Disposition\", \"attachment; \" + \"filename=\"+URLEncoder.encode(filename,\"UTF-8\")); //设置文件流 FileInputStream fis=new FileInputStream(realPath); //创建缓存区 int len; byte[] buff=new byte[1024]; //获取outputStream对象 ServletOutputStream outputStream = resp.getOutputStream(); //IO流,下载文件 while((len=fis.read())!=-1){ outputStream.write(buff,0,len); } outputStream.close(); fis.close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 3、重定向 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // '/'表示根目录，如localhost：8080,需要加入具体的项目名和请求 resp.sendRedirect(\"/Servlet_war/test\"); } 等同于 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置路径和状态码 // '/'表示根目录，如localhost：8080,需要加入具体的项目名和请求 resp.setHeader(\"location\",\"/Servlet_war/test\"); resp.setStatus(302); } 重定向和请求转发的区别： 相同点： 1、 都实现页面跳转 不同点： 1、请求转发，url地址栏不会改变 2、重定向，url地址栏会发生改变 ","date":"2020/12/23","objectID":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/:0:3","tags":["servlet","JavaWeb"],"title":"HttpServletResponse和HttpServletRequest常见应用","uri":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/"},{"categories":["JavaWeb"],"content":"HttpServletRequest常见应用 获取参数 login.jsp 模拟用户登入页面 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"\u003e \u003ctitle\u003elogin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv style=\"text-align: center;\"\u003e \u003c%--${pageContext.request.contextPath} 表示webapp运行的路径，如：http://localhost:8080/Servlet_war --%\u003e \u003cform action=\"${pageContext.request.contextPath}/login\" method=\"post\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\"\u003e\u003cbr\u003e 密码：\u003cinput type=\"password\" name=\"password\"\u003e\u003cbr\u003e 爱好： \u003cinput type=\"checkbox\" name=\"hobby\" value=\"运动\"\u003e运动 \u003cinput type=\"checkbox\" name=\"hobby\" value=\"美食\"\u003e美食 \u003cinput type=\"checkbox\" name=\"hobby\" value=\"电影\"\u003e电影 \u003cinput type=\"checkbox\" name=\"hobby\" value=\"电子游戏\"\u003e电子游戏 \u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e LoginServlet 对login.jsp提交的信息进行处理，然后跳转到index.jsp package com.tin.servlet; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.lang.reflect.Array; import java.util.Arrays; public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"UTF-8\"); //获取单个参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //获取参数数组 String[] hobbies = req.getParameterValues(\"hobby\"); //在这里可以进行用户登入判断，用户是否存在，密码是否正确 //输出参数信息 System.out.println(username+\":\"+password+ Arrays.toString(hobbies)); //设置客户端浏览器以UTF-8编码解析数据 //resp.setCharacterEncoding(\"UTF-8\"); //resp.setContentType(\"text/html;charset=UTF-8\"); //resp.getWriter().print(username+\":\"+password+ Arrays.toString(hobbies)); //重定向到index.jsp resp.sendRedirect(\"/Servlet_war/index.jsp\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ","date":"2020/12/23","objectID":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/:0:4","tags":["servlet","JavaWeb"],"title":"HttpServletResponse和HttpServletRequest常见应用","uri":"/posts/httpservletresponse%E5%92%8Chttpservletrequest%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/"},{"categories":["JavaWeb"],"content":"ServletContext详解","date":"2020/12/22","objectID":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/","tags":["servlet","JavaWeb"],"title":"ServletContext详解","uri":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/"},{"categories":["JavaWeb"],"content":"一、ServletContext介绍 ServletContext官方叫servlet上下文。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象。 ","date":"2020/12/22","objectID":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/:1:0","tags":["servlet","JavaWeb"],"title":"ServletContext详解","uri":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/"},{"categories":["JavaWeb"],"content":"功能介绍 ","date":"2020/12/22","objectID":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/:2:0","tags":["servlet","JavaWeb"],"title":"ServletContext详解","uri":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/"},{"categories":["JavaWeb"],"content":"1、共享数据 在Servlet_1中上传数据 package com.tin.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class Servlet_1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //ServletContext 上下文 ServletContext context = this.getServletContext(); //数据 String username=\"小明\"; //将数据保存在ServletContext中，参数为键值对(名，对象） context.setAttribute(\"username\",username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 在Servlet_2中读数据 package com.tin.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class Servlet_2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); //获取数据，类似键值对，需要通过键名获取 String username=(String) context.getAttribute(\"username\"); //设置编码格式 resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); //输出数据 resp.getWriter().print(username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 需要在web.xml文件注册servlet和servlet-mapping \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003cservlet\u003e \u003cservlet-name\u003etest\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.tin.servlet.Servlet_1\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003etest\u003c/servlet-name\u003e \u003curl-pattern\u003e/test\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003etest1\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.tin.servlet.Servlet_2\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003etest1\u003c/servlet-name\u003e \u003curl-pattern\u003e/test1\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e 测试结果： ","date":"2020/12/22","objectID":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/:2:1","tags":["servlet","JavaWeb"],"title":"ServletContext详解","uri":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/"},{"categories":["JavaWeb"],"content":"2、获取初始化参数 在web.xml设置参数 \u003ccontext-param\u003e \u003cparam-name\u003eurl\u003c/param-name\u003e \u003cparam-value\u003ejdbc:mysql://localhost:3306\u003c/param-value\u003e \u003c/context-param\u003e 在java程序中获取参数 package com.tin.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class Servlet_1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //ServletContext 上下文 ServletContext context = this.getServletContext(); //获取初始化参数 String url = context.getInitParameter(\"url\"); //设置编码格式 resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); //输出参数值 resp.getWriter().print(url); } } ","date":"2020/12/22","objectID":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/:2:2","tags":["servlet","JavaWeb"],"title":"ServletContext详解","uri":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/"},{"categories":["JavaWeb"],"content":"3、请求转发 在web客户端发出请求，ServletB收到请求后转发给ServletC,将ServletC处理后的响应传给ServletB,ServletB再响应web客户端的请求。web客户端始终是与ServletB进行交互。 将原来servlet_1的请求是/test1，但转发得到请求路径 /test 的结果 package com.tin.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class Servlet_2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); //获取数据，类似键值对，需要通过键名获取 String username=(String) context.getAttribute(\"username\"); // ‘/’表示web的根目录 ,修改转发的请求路径 //forward()实现请求转发 context.getRequestDispatcher(\"/test\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ","date":"2020/12/22","objectID":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/:2:3","tags":["servlet","JavaWeb"],"title":"ServletContext详解","uri":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/"},{"categories":["JavaWeb"],"content":"读取资源文件 资源无法导出解决方案： \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003c!--添加java文件夹下的xml和properties文件资源--\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 在resource创建一个资源文件，如test.properties 所以的资源都会放在classes文件夹下 在test.properties 中写入 username=rootpassword=123456 在Servlet 中读取资源文件内容 package com.tin.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.InputStream; import java.util.Properties; public class Servlet_2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); //用相对资源定位，获取文件流 InputStream is=context.getResourceAsStream(\"/WEB-INF/classes/test.properties\"); //加载配置文件 Properties properties = new Properties(); properties.load(is); //获取配置值 String username = properties.getProperty(\"username\"); String password = properties.getProperty(\"password\"); //设置编码格式 resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); resp.getWriter().print(username+\":\"+password); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 运行后，测试： ","date":"2020/12/22","objectID":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/:2:4","tags":["servlet","JavaWeb"],"title":"ServletContext详解","uri":"/posts/servletcontext%E8%AF%A6%E8%A7%A3/"},{"categories":["JavaWeb"],"content":"用maven创建一个简单的servlet例子","date":"2020/12/19","objectID":"/posts/%E7%94%A8maven%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84servlet%E4%BE%8B%E5%AD%90/","tags":["servlet","JavaWeb"],"title":"初识servlet","uri":"/posts/%E7%94%A8maven%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84servlet%E4%BE%8B%E5%AD%90/"},{"categories":["JavaWeb"],"content":"一、 Servlet介绍 servlet就是Sun公司开发动态网站的一门技术 Sun公司在这些API中提供一个接口叫做：servlet 开发servlet程序步骤： 1、编写一个类，实现servlet接口 2 、把开发好的类部署到web服务器中 ","date":"2020/12/19","objectID":"/posts/%E7%94%A8maven%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84servlet%E4%BE%8B%E5%AD%90/:0:1","tags":["servlet","JavaWeb"],"title":"初识servlet","uri":"/posts/%E7%94%A8maven%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84servlet%E4%BE%8B%E5%AD%90/"},{"categories":["JavaWeb"],"content":"二、创建一个servlet实例 IDEA创建一个空的Maven工程（==用专业版Idea==,如何破解自行百度） File-\u003enew-\u003eproject 选择maven工程，这里不勾选模板 设置文件名，文件路径 GroupID是项目组织唯一的标识符，实际对应JAVA的包的结构，是main目录里java的目录结构。 ArtifactID就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。 一般GroupID就是填com.test这样子 Maven 空项目文件结构如下，删除src (==作为父项目管理依赖，具体功能由子模块实现==) 在Maven项目中添加webapp模块 选择项目的根目录-\u003enew -\u003eModule 创建webapp子模块 设置子模块的文件名和文件路径 配置Maven和Maven仓库（可以自己建，也可以使用idea自带的Maven2或Maven3） 完成后，父项目的pom.xml文件下会生成： \u003cmodules\u003e \u003cmodule\u003eservlet\u003c/module\u003e \u003c/modules\u003e 子模块的pom.xml会生成： \u003cparent\u003e \u003cgroupId\u003ecom.test\u003c/groupId\u003e \u003cartifactId\u003eTest\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e ==如果没有需要手动添加，子模块能使用父项目导入的依赖（jar包），不需要再配置pom.xml文件== 在父项目的pom.xml导入JSP、Servlet依赖 \u003cdependencies\u003e \u003c!--Servlet依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--JSP依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet.jsp\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet.jsp-api\u003c/artifactId\u003e \u003cversion\u003e2.3.3\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 在子模块中添加java文件和resource文件，java文件鼠标右键，将java设置为Source文件（这样才可以添加java代码） 在java文件下创建com.test.servlet包，在这个包下创建HelloServlet类 编写HelloServlet类 package com.tin.servlet; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //输出流 PrintWriter writer = resp.getWriter(); writer.print(\"hello,welcome to servlet\"); } } 编写servlet映射 servlet写的java程序，但是需要通过浏览器访问，而浏览器需要连接web服务器，所以需要在web服务中注册编写的servlet，还需要给一个浏览器能访问的路径： 在web.xml添加servlet信息 \u003c!--注册servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.tin.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003c!--servlet 请求路径--\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 配置tomcat server 然后添加需要执行的webapp压缩包 完成配置后就可以执行项目 ","date":"2020/12/19","objectID":"/posts/%E7%94%A8maven%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84servlet%E4%BE%8B%E5%AD%90/:0:2","tags":["servlet","JavaWeb"],"title":"初识servlet","uri":"/posts/%E7%94%A8maven%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84servlet%E4%BE%8B%E5%AD%90/"},{"categories":["JavaWeb"],"content":"tomcat 有哪些基本组成？如何启动？如何配置端口？","date":"2020/12/15","objectID":"/posts/%E5%88%9D%E8%AF%86tomcat/","tags":["Tomcat"],"title":"初识Tomcat","uri":"/posts/%E5%88%9D%E8%AF%86tomcat/"},{"categories":["JavaWeb"],"content":"Tomcat组成 ","date":"2020/12/15","objectID":"/posts/%E5%88%9D%E8%AF%86tomcat/:0:1","tags":["Tomcat"],"title":"初识Tomcat","uri":"/posts/%E5%88%9D%E8%AF%86tomcat/"},{"categories":["JavaWeb"],"content":"启动Tomcat ","date":"2020/12/15","objectID":"/posts/%E5%88%9D%E8%AF%86tomcat/:0:2","tags":["Tomcat"],"title":"初识Tomcat","uri":"/posts/%E5%88%9D%E8%AF%86tomcat/"},{"categories":["JavaWeb"],"content":"修改配置 ","date":"2020/12/15","objectID":"/posts/%E5%88%9D%E8%AF%86tomcat/:1:0","tags":["Tomcat"],"title":"初识Tomcat","uri":"/posts/%E5%88%9D%E8%AF%86tomcat/"},{"categories":["JavaWeb"],"content":"网站资源 通过url 协议（http/https/ftp） IP（可以是域名，然后域名解析为ip地址） 端口号 项目名（也就是文件夹名） 资源 http://localhost:8080/examples/ ，通过这个url访问examples文件夹下的资源 ","date":"2020/12/15","objectID":"/posts/%E5%88%9D%E8%AF%86tomcat/:1:1","tags":["Tomcat"],"title":"初识Tomcat","uri":"/posts/%E5%88%9D%E8%AF%86tomcat/"},{"categories":["网络编程"],"content":"利用URL下载资源","date":"2020/12/15","objectID":"/posts/%E5%88%A9%E7%94%A8url%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/","tags":["URL","网络编程"],"title":"利用URL下载资源","uri":"/posts/%E5%88%A9%E7%94%A8url%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/"},{"categories":["网络编程"],"content":"URL概念 URL：统一资源定位符 作用：定位互联网上的某一资源 ==DNS 域名解析== 将域名转为ip DNS域名解析过程： 1.输入域名 2.检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名 映射 如果找到了就返回对应的IP地址 如果没有找到，就去DNS服务器找，找到返回，找不到则表示找不到资源 ==协议==：//==ip地址==：==端口==/==项目名==/==资源== 五部分组成 ","date":"2020/12/15","objectID":"/posts/%E5%88%A9%E7%94%A8url%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/:0:1","tags":["URL","网络编程"],"title":"利用URL下载资源","uri":"/posts/%E5%88%A9%E7%94%A8url%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/"},{"categories":["网络编程"],"content":"获取资源URL 打开浏览器开发者工具，选择Network 在左下角选择所需要的资源（以图片为例） 在右下角的Preview 查看是否是所需资源 在Header中找到URL地址 ","date":"2020/12/15","objectID":"/posts/%E5%88%A9%E7%94%A8url%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/:0:2","tags":["URL","网络编程"],"title":"利用URL下载资源","uri":"/posts/%E5%88%A9%E7%94%A8url%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/"},{"categories":["网络编程"],"content":"java程序利用url下载资源 package test04; import java.io.FileOutputStream; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; public class URLDemo { public static void main(String[] args) throws Exception { //下载地址 URL url=new URL(\"https://goss.veer.com/creative/vcg/veer/800water/veer-171142505.jpg\"); //连接到这个资源 HttpURLConnection urlConnection=(HttpURLConnection) url.openConnection(); //输入流 InputStream inputStream=urlConnection.getInputStream(); //复制到本地文件夹下 FileOutputStream fos=new FileOutputStream(\"E:/download.jpg\"); byte[] buff=new byte[1024]; int len; while((len=inputStream.read(buff))!=-1){ fos.write(buff,0,len); } fos.close(); inputStream.close(); urlConnection.disconnect();//断开连接 } } ","date":"2020/12/15","objectID":"/posts/%E5%88%A9%E7%94%A8url%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/:0:3","tags":["URL","网络编程"],"title":"利用URL下载资源","uri":"/posts/%E5%88%A9%E7%94%A8url%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90/"},{"categories":["网络编程"],"content":"TCP实现多线程聊天","date":"2020/12/14","objectID":"/posts/udp%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%81%8A%E5%A4%A9/","tags":["java","TCP","网络编程"],"title":"TCP实现多线程聊天","uri":"/posts/udp%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%81%8A%E5%A4%A9/"},{"categories":["网络编程"],"content":"接收线程 创建套接字Socket ,监听端口 等待并接收数据包 读取数据包的数据 判断是否结束 package test03; import java.io.BufferedReader; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class Receiver implements Runnable{ DatagramSocket socket=null; private int port; private String msgFrom; Receiver(int port,String msgFrom){ this.port=port; this.msgFrom=msgFrom; try { //创建socke，监测端口 socket=new DatagramSocket(port); } catch (SocketException e) { e.printStackTrace(); } } @Override public void run() { while(true){ try { //准备接收数据包 byte[] buff=new byte[1024]; DatagramPacket packet=new DatagramPacket(buff,0,buff.length); socket.receive(packet); //读取数据包的数据 byte[] data=packet.getData(); String receiveData=new String(data,0,data.length); System.out.println(msgFrom+\": \"+receiveData); //如果是bye 则停止接收 if(receiveData.equals(\"bye\")){ break; } } catch (IOException e) { e.printStackTrace(); } } socket.close(); } } ","date":"2020/12/14","objectID":"/posts/udp%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%81%8A%E5%A4%A9/:0:1","tags":["java","TCP","网络编程"],"title":"TCP实现多线程聊天","uri":"/posts/udp%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%81%8A%E5%A4%A9/"},{"categories":["网络编程"],"content":"发送线程 创建套接字Socket（和接收方的socket监测的端口号不同） 读取键盘输入字符串 创建数据包 发送数据包 判断是否结束 package test03; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; public class Sender implements Runnable{ DatagramSocket socket=null; BufferedReader reader=null; private int fromPort; private String toIP; private int toPort; Sender(int formPort,String toIP,int toPort){ this.fromPort=formPort; this.toIP=toIP; this.toPort=toPort; try { //创建对象 , 该 Socket 会监听固定端口 ; 注意该端口是用于监听数据接收的 ; 发送数据使用的不是该端口号 ; socket = new DatagramSocket(fromPort); //读取键盘输入 reader=new BufferedReader(new InputStreamReader(System.in)); }catch (Exception e){ } } @Override public void run() { while (true) { try { //读取键盘输入一行信息 String data=reader.readLine(); //将字符流转为字节流 byte[] datas=data.getBytes(); //创建数据包 //参数 ：数据、数据开始和结束的位置、接收方的ip和端口号 DatagramPacket packet=new DatagramPacket(datas,0,datas.length, new InetSocketAddress(this.toIP,this.toPort)); //发送数据包 socket.send(packet); //输入bye结束 if(data.equals(\"bye\")){ break; } } catch (Exception e) { } } socket.close(); } } ","date":"2020/12/14","objectID":"/posts/udp%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%81%8A%E5%A4%A9/:0:2","tags":["java","TCP","网络编程"],"title":"TCP实现多线程聊天","uri":"/posts/udp%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%81%8A%E5%A4%A9/"},{"categories":["网络编程"],"content":"用户 创建发送线程和接收线程 package test03; public class UserA { public static void main(String[] args) { //开启两个线程 //己方发送套接字监听的端口号7777，对方接收套接字的IP和端口号9999 Sender sender=new Sender(7777,\"127.0.0.1\",9999); //己方接收套接字端口8888 Receiver receiver=new Receiver(8888,\"学生\"); new Thread(sender).start(); new Thread(receiver).start(); } } package test03; public class UseB { public static void main(String[] args) { //开启两个线程 Sender sender=new Sender(5555,\"127.0.0.1\",8888); Receiver receiver=new Receiver(9999,\"老师\"); new Thread(sender).start(); new Thread(receiver).start(); } } ","date":"2020/12/14","objectID":"/posts/udp%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%81%8A%E5%A4%A9/:0:3","tags":["java","TCP","网络编程"],"title":"TCP实现多线程聊天","uri":"/posts/udp%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%81%8A%E5%A4%A9/"},{"categories":["网络编程"],"content":"利用TCP实现文件上传","date":"2020/12/12","objectID":"/posts/tcp%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","tags":["java","TCP","网络编程"],"title":"利用TCP实现文件上传","uri":"/posts/tcp%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["网络编程"],"content":"服务端 创建服务器 监听客户连接 接收文件 返回提示信息 package test02; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; import java.io.File; public class TcpServerDemo { public static void main(String[] args) { try{ //创建服务器 ServerSocket serverSocket=new ServerSocket(9999); //监听客户端连接 Socket socket=serverSocket.accept(); //获取输入流 InputStream is=socket.getInputStream(); //文件输出 File f=new File(\"E:/b.txt\"); FileOutputStream fos=new FileOutputStream(f); byte[] buffer=new byte[1024]; int len; while((len=is.read(buffer))!=-1){ fos.write(buffer,0,len); } //通知客户端接收完毕 OutputStream os=socket.getOutputStream(); os.write(\"文件上传完毕\".getBytes()); os.close(); //关闭通道 fos.close(); is.close(); socket.close(); serverSocket.close(); }catch (Exception e){ } } } ","date":"2020/12/12","objectID":"/posts/tcp%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:0","tags":["java","TCP","网络编程"],"title":"利用TCP实现文件上传","uri":"/posts/tcp%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["网络编程"],"content":"客户端 获取服务器IP和端口号 创建socket连接 上传文件 通知服务器上传完毕 接收提示信息 package test02; import java.io.*; import java.net.InetAddress; import java.net.Socket; public class TcpClientDemo { public static void main(String[] args) { try { //获取IP和端口号 InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; //创建一个socket连接 Socket socket=new Socket(serverIP,port); //创建输出流 OutputStream os=socket.getOutputStream(); //读取文件 File f=new File(\"E:/a.txt\"); FileInputStream fis=new FileInputStream(f); //读出文件内容 byte[] buffer=new byte[1024]; int len; while((len=fis.read(buffer))!=-1){ os.write(buffer,0,len); } //通知服务器端文件传输完毕 socket.shutdownOutput(); //接收服务端返回信息 InputStream is=socket.getInputStream(); ByteArrayOutputStream baos= new ByteArrayOutputStream(); byte[] buffer2=new byte[1024]; int len2; while((len2=is.read(buffer2))!=-1){ baos.write(buffer2,0,len2); } System.out.println(baos.toString()); //关闭通道 fis.close(); os.close(); socket.close(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2020/12/12","objectID":"/posts/tcp%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:0","tags":["java","TCP","网络编程"],"title":"利用TCP实现文件上传","uri":"/posts/tcp%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["网络编程"],"content":"TCP实现简单聊天","date":"2020/12/12","objectID":"/posts/tcp%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9/","tags":["java","TCP","网络编程"],"title":"TCP实现简单聊天","uri":"/posts/tcp%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9/"},{"categories":["网络编程"],"content":"##客户端 获取IP地址和端口 创建socket连接 输入发送信息 关闭管道 package test01; import java.io.OutputStream; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; //客户端 public class TcpClientDemo { public static void main(String[] args) { try{ //知道服务器地址和端口 InetAddress serverIP=InetAddress.getByName(\"127.0.0.1\"); int port=9999; //创建一个socket连接 Socket socket=new Socket(serverIP,port); //发送消息 OutputStream os=socket.getOutputStream(); os.write(\"你好，我是XXX\".getBytes()); os.close(); socket.close(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"2020/12/12","objectID":"/posts/tcp%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9/:0:0","tags":["java","TCP","网络编程"],"title":"TCP实现简单聊天","uri":"/posts/tcp%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9/"},{"categories":["网络编程"],"content":"服务端 创建服务器 等待客户端连接 读取客户端信息 关闭管道 package test01; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TcpSeriverDemo { public static void main(String[] args) { ServerSocket serverSocket=null; Socket socket=null; InputStream is=null; ByteArrayOutputStream baos=null; try{ //建立服务端口 serverSocket=new ServerSocket(9999); //等待客户端连接 socket=serverSocket.accept(); //读取客户端消息 is=socket.getInputStream(); //管道流 baos=new ByteArrayOutputStream(); byte[] buffer=new byte[1024]; int len; while((len=is.read(buffer))!=-1){ baos.write(buffer,0,len); } System.out.println(baos.toString()); baos.close(); is.close(); socket.close(); serverSocket.close(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"2020/12/12","objectID":"/posts/tcp%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9/:1:0","tags":["java","TCP","网络编程"],"title":"TCP实现简单聊天","uri":"/posts/tcp%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9/"},{"categories":["网络编程"],"content":"计算机网络编程--基础概念","date":"2020/12/10","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/","tags":["网络模型","IP","端口","通信协议","网络编程"],"title":"计算机网络编程--基础概念","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/"},{"categories":["网络编程"],"content":"网络编程 ","date":"2020/12/10","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/:0:0","tags":["网络模型","IP","端口","通信协议","网络编程"],"title":"计算机网络编程--基础概念","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/"},{"categories":["网络编程"],"content":"一、概述 网络编程的目的：传播信息、数据交换 实现条件： 如何准确的定位网络上的一台主机，利用==ip:端口== 找到了这个主机，如何传输数据： 传输协议：==tcp\\udp\\ftp==等 ","date":"2020/12/10","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/:0:1","tags":["网络模型","IP","端口","通信协议","网络编程"],"title":"计算机网络编程--基础概念","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/"},{"categories":["网络编程"],"content":"二、网络模型 ","date":"2020/12/10","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/:0:2","tags":["网络模型","IP","端口","通信协议","网络编程"],"title":"计算机网络编程--基础概念","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/"},{"categories":["网络编程"],"content":"三、IP地址 IP地址：唯一定位一台网络上计算机 IP地址分类： IP私有地址： 在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下： A类地址：10.0.0.0～10.255.255.255 B类地址：172.16.0.0～172.31.255.255 C类地址：192.168.0.0～192.168.255.255 ","date":"2020/12/10","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/:0:3","tags":["网络模型","IP","端口","通信协议","网络编程"],"title":"计算机网络编程--基础概念","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/"},{"categories":["网络编程"],"content":"四、端口 端口：表示计算机一个程序的进程 ==不同的进程有不同的端口，用来区分软件== netstat -a -n //window查看端口信息 ​ 被规定 0-65535，==TCP、UDP各有65535个==，单个协议下，端口号不能冲突 端口划分： 公有端口：0-1023 ，==不建议占用== http:80 https:443 ftp:21 Telent:23 程序注册端口：1024-49151，分配给用户或者程序 Tomcat:8080 MySql:3306 Oracle:1521 动态、私有端口：49152-65535 ，==不建议使用== ","date":"2020/12/10","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/:0:4","tags":["网络模型","IP","端口","通信协议","网络编程"],"title":"计算机网络编程--基础概念","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/"},{"categories":["网络编程"],"content":"五、通信协议 协议：数据传输约定 思路：以大化小，分层 TCP 建立可靠连接，确定双方都建立连接后数据传输，可靠 ==三次握手，四次挥手== 效率低 UDP 不建立连接，数据发送方只需发送数据，不可靠 效率高 ","date":"2020/12/10","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/:0:5","tags":["网络模型","IP","端口","通信协议","网络编程"],"title":"计算机网络编程--基础概念","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B--%E5%9F%BA%E7%A1%80/"},{"categories":["leetcode"],"content":"leetcode题集--链表","date":"2020/12/09","objectID":"/posts/leetcode%E9%A2%98%E9%9B%86--%E9%93%BE%E8%A1%A8/","tags":["leetcode","链表","数据结构"],"title":"leetcode题集--链表","uri":"/posts/leetcode%E9%A2%98%E9%9B%86--%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":"题目 ","date":"2020/12/09","objectID":"/posts/leetcode%E9%A2%98%E9%9B%86--%E9%93%BE%E8%A1%A8/:1:0","tags":["leetcode","链表","数据结构"],"title":"leetcode题集--链表","uri":"/posts/leetcode%E9%A2%98%E9%9B%86--%E9%93%BE%E8%A1%A8/"},{"categories":["leetcode"],"content":"思路 1、用List集合 先将一个链表headA的节点都存入集合list中，然后遍历另一个链表headB时，比较headB的每个节点是否存在集合list中，如果存在，就返回这个节点；如果不存在，返回空节点 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { //链表为空的情况 if(headA==null||headB==null){ return null; } //定义集合list ArrayList list=new ArrayList(); ListNode p=headA; //遍历链表headA,将链表节点存入集合list while(p!=null){ list.add(p); p=p.next; } //遍历链表headB ListNode q=headB; while(q!=null){ //比较每个节点是否存在集合list中 if(list.contains(q)){ return q; } q=q.next; } return null; } } 集合的比较消耗比较多，整体效率比较低 2 用链表长度 先计算两个链表的长度，让长的链表走多出来的距离，使得链表headA和headB等长。然后headA和headB同步走，如果这时两个节点headA等于headB，返回这个节点；如果遍历完节点也不满足这时的两个节点headA等于headB，则返回空节点。 public class Solution { public int length(ListNode p){ int count=0; while(p!=null){ count+=1; p=p.next; } return count; } public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA==null||headB==null){ return null; } //统计链表A和链表B的长度 int lenA = length(headA), lenB = length(headB); while(lenA!=lenB){ if(lenA\u003elenB){ headA=headA.next; lenA--; } if(lenA\u003clenB){ headB=headB.next; lenB--; } } while(headA!=null\u0026\u0026 headB!=null){ if(headA==headB){ return headA; } headA=headA.next; headB=headB.next; } return null; } } 3、双指针 假设公共链表长度为x,链表headA为lenA,链表headB为lenB， 两个指针跑完链表A和链表B， p 节点：lenA+lenB-X q 节点：lenA+lenB-X 则 p、q指针相遇的那个节点就是公共链表的头节点 分为三个阶段：（假设链表A更长，指针p、q分别从链表A、B出发） 阶段一：指针q 走完了链表B，指针p还在走链表B 阶段二：指针q 从链表A开始走，指针p 走完了链表A 阶段三：指针q正在走链表A，指针p开始走链表B 阶段四：指针p、q相遇在公共节点，返回公共节点 或者 都走完了各自的链表，返回空节点 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p=headA; ListNode q=headB; while(p!=q){ if(p==null){ p=headB; }else{ p=p.next; } if(q==null){ q=headA; }else{ q=q.next; } } return p; } } （参考leetcode题解，本篇文章内容只是个人解题思路总结） ","date":"2020/12/09","objectID":"/posts/leetcode%E9%A2%98%E9%9B%86--%E9%93%BE%E8%A1%A8/:2:0","tags":["leetcode","链表","数据结构"],"title":"leetcode题集--链表","uri":"/posts/leetcode%E9%A2%98%E9%9B%86--%E9%93%BE%E8%A1%A8/"},{"categories":["Echarts"],"content":"Echarts定制-中国飞行航线","date":"2020/12/07","objectID":"/posts/echarts%E5%AE%9A%E5%88%B66-%E4%B8%AD%E5%9B%BD%E9%A3%9E%E8%A1%8C%E8%88%AA%E7%BA%BF/","tags":["Echarts"],"title":"Echarts定制-中国飞行航线","uri":"/posts/echarts%E5%AE%9A%E5%88%B66-%E4%B8%AD%E5%9B%BD%E9%A3%9E%E8%A1%8C%E8%88%AA%E7%BA%BF/"},{"categories":["Echarts"],"content":" //地标经纬度 var geoCoordMap = { '上海': [121.4648, 31.2891], '东莞': [113.8953, 22.901], '东营': [118.7073, 37.5513], '中山': [113.4229, 22.478], '临汾': [111.4783, 36.1615], '临沂': [118.3118, 35.2936], '丹东': [124.541, 40.4242], '丽水': [119.5642, 28.1854], '乌鲁木齐': [87.9236, 43.5883], '佛山': [112.8955, 23.1097], '保定': [115.0488, 39.0948], '兰州': [103.5901, 36.3043], '包头': [110.3467, 41.4899], '北京': [116.4551, 40.2539], '北海': [109.314, 21.6211], '南京': [118.8062, 31.9208], '南宁': [108.479, 23.1152], '南昌': [116.0046, 28.6633], '南通': [121.1023, 32.1625], '厦门': [118.1689, 24.6478], '台州': [121.1353, 28.6688], '合肥': [117.29, 32.0581], '呼和浩特': [111.4124, 40.4901], '咸阳': [108.4131, 34.8706], '哈尔滨': [127.9688, 45.368], '唐山': [118.4766, 39.6826], '嘉兴': [120.9155, 30.6354], '大同': [113.7854, 39.8035], '大连': [122.2229, 39.4409], '天津': [117.4219, 39.4189], '太原': [112.3352, 37.9413], '威海': [121.9482, 37.1393], '宁波': [121.5967, 29.6466], '宝鸡': [107.1826, 34.3433], '宿迁': [118.5535, 33.7775], '常州': [119.4543, 31.5582], '广州': [113.5107, 23.2196], '廊坊': [116.521, 39.0509], '延安': [109.1052, 36.4252], '张家口': [115.1477, 40.8527], '徐州': [117.5208, 34.3268], '德州': [116.6858, 37.2107], '惠州': [114.6204, 23.1647], '成都': [103.9526, 30.7617], '扬州': [119.4653, 32.8162], '承德': [117.5757, 41.4075], '拉萨': [91.1865, 30.1465], '无锡': [120.3442, 31.5527], '日照': [119.2786, 35.5023], '昆明': [102.9199, 25.4663], '杭州': [119.5313, 29.8773], '枣庄': [117.323, 34.8926], '柳州': [109.3799, 24.9774], '株洲': [113.5327, 27.0319], '武汉': [114.3896, 30.6628], '汕头': [117.1692, 23.3405], '江门': [112.6318, 22.1484], '沈阳': [123.1238, 42.1216], '沧州': [116.8286, 38.2104], '河源': [114.917, 23.9722], '泉州': [118.3228, 25.1147], '泰安': [117.0264, 36.0516], '泰州': [120.0586, 32.5525], '济南': [117.1582, 36.8701], '济宁': [116.8286, 35.3375], '海口': [110.3893, 19.8516], '淄博': [118.0371, 36.6064], '淮安': [118.927, 33.4039], '深圳': [114.5435, 22.5439], '清远': [112.9175, 24.3292], '温州': [120.498, 27.8119], '渭南': [109.7864, 35.0299], '湖州': [119.8608, 30.7782], '湘潭': [112.5439, 27.7075], '滨州': [117.8174, 37.4963], '潍坊': [119.0918, 36.524], '烟台': [120.7397, 37.5128], '玉溪': [101.9312, 23.8898], '珠海': [113.7305, 22.1155], '盐城': [120.2234, 33.5577], '盘锦': [121.9482, 41.0449], '石家庄': [114.4995, 38.1006], '福州': [119.4543, 25.9222], '秦皇岛': [119.2126, 40.0232], '绍兴': [120.564, 29.7565], '聊城': [115.9167, 36.4032], '肇庆': [112.1265, 23.5822], '舟山': [122.2559, 30.2234], '苏州': [120.6519, 31.3989], '莱芜': [117.6526, 36.2714], '菏泽': [115.6201, 35.2057], '营口': [122.4316, 40.4297], '葫芦岛': [120.1575, 40.578], '衡水': [115.8838, 37.7161], '衢州': [118.6853, 28.8666], '西宁': [101.4038, 36.8207], '西安': [109.1162, 34.2004], '贵阳': [106.6992, 26.7682], '连云港': [119.1248, 34.552], '邢台': [114.8071, 37.2821], '邯郸': [114.4775, 36.535], '郑州': [113.4668, 34.6234], '鄂尔多斯': [108.9734, 39.2487], '重庆': [107.7539, 30.1904], '金华': [120.0037, 29.1028], '铜川': [109.0393, 35.1947], '银川': [106.3586, 38.1775], '镇江': [119.4763, 31.9702], '长春': [125.8154, 44.2584], '长沙': [113.0823, 28.2568], '长治': [112.8625, 36.4746], '阳泉': [113.4778, 38.0951], '青岛': [120.4651, 36.3373], '韶关': [113.7964, 24.7028] }; //飞机路线：起点-终点 var XAData = [ [{ name: '西安' }, { name: '北京', value: 100 }], [{ name: '西安' }, { name: '上海', value: 100 }], [{ name: '西安' }, { name: '广州', value: 100 }], [{ name: '西安' }, { name: '西宁', value: 100 }], [{ name: '西安' }, { name: '银川', value: 100 }], [{ name: '西安' }, { name: '南昌', value: 100 }] ]; var XNData = [ [{ name: '西宁' }, { name: '北京', value: 100 }], [{ name: '西宁' }, { name: '上海', value: 100 }], [{ name: '西宁' }, { name: '广州', value: 100 }], [{ name: '西宁' }, { name: '西安', value: 100 }], [{ name: '西宁' }, { name: '银川', value: 100 }] ]; var YCData = [ [{ name: '银川' }, { name: '北京', value: 100 }], [{ name: '银川' }, { name: '广州', value: 100 }], [{ name: '银川' }, { name: '上海', value: 100 }], [{ name: '银川' }, { name: '西安', value: 100 }], [{ name: '银川' }, { name: '西宁', value: 100 }], ]; //飞机图片样式 var planePath = 'path://M1705.06,1318.313v-89.254l-319.9-221.799l0.073-208.063c0.521-84.6","date":"2020/12/07","objectID":"/posts/echarts%E5%AE%9A%E5%88%B66-%E4%B8%AD%E5%9B%BD%E9%A3%9E%E8%A1%8C%E8%88%AA%E7%BA%BF/:0:0","tags":["Echarts"],"title":"Echarts定制-中国飞行航线","uri":"/posts/echarts%E5%AE%9A%E5%88%B66-%E4%B8%AD%E5%9B%BD%E9%A3%9E%E8%A1%8C%E8%88%AA%E7%BA%BF/"},{"categories":["Echarts"],"content":"Echarts定制-塔形雷达图","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B65-%E5%A1%94%E5%9E%8B%E9%9B%B7%E8%BE%BE%E5%9B%BE/","tags":["Echarts"],"title":"Echarts定制-塔形雷达图","uri":"/posts/echarts%E5%AE%9A%E5%88%B65-%E5%A1%94%E5%9E%8B%E9%9B%B7%E8%BE%BE%E5%9B%BE/"},{"categories":["Echarts"],"content":" //主要的思路就是，一个八边形的雷达图取最下面两份 //然后将雷达图的分割线等隐藏 option = { backgroundColor: '#0A2E5D', color: [ '#ff5b00', '#ffa800', '#006ced','#11A6D0','#00ffff'], radar: { name: { show: false }, indicator: [ { name: 'A', max: 100 }, { name: 'B', max: 100 }, { name: 'C', max: 100 }, { name: 'D', max: 100 }, { name: 'E', max: 100 }, { name: 'F', max: 100 }, { name: 'G', max: 100 }, { name: 'H', max: 100 } ], center: ['50%', '10%'], radius: 300, axisLine: { show: false }, splitLine: { show: false }, splitArea: { show: false } }, series: [ { type: 'radar', areaStyle: { opacity: 1, shadowBlur: 1, shadowColor: 'rgba(0,0,0,.5)', }, silent: true, data: [ { value: [0, 0, 0, 100, 100, 99, 0, 0], name: '8k以下', symbol: 'circle', symbolSize: 1, label: { show: true, position: [-5, -10], formatter: function(point) { if(point.value == 99) return \"—— \" + point.name else return '' }, } }, { value: [0, 0, 0, 79, 80, 80, 0, 0], name: '8k-10k', symbol: 'circle', symbolSize: 1, label: { show: true, position: [-55, -10], formatter: function(point) { if(point.value == 79) return \"\" + point.name + \" ——\" else return '' }, } }, { value: [0, 0, 0, 60, 60, 59, 0, 0], name: '10k-20k', symbol: 'circle', symbolSize: 1, label: { show: true, position: [-5, -10], formatter: function(point) { if(point.value == 59) return \"—— \" + point.name else return '' }, } }, { value: [0, 0, 0, 39, 40, 40, 0, 0], name: '20k-30k', symbol: 'circle', symbolSize: 1, label: { show: true, position: [-55, -10], formatter: function(point) { if(point.value == 39) return \"\" + point.name + \" ——\" else return '' }, } }, { value: [0, 0, 0, 20, 20, 19, 0, 0], name: '30k以上', symbol: 'circle', symbolSize: 1, label: { show: true, position: [-5, -10], formatter: function(point) { if(point.value == 19) return \"—— \" + point.name else return '' }, } } ] }], itemStyle: { emphasis: { show: false, shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' } } }; ","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B65-%E5%A1%94%E5%9E%8B%E9%9B%B7%E8%BE%BE%E5%9B%BE/:0:0","tags":["Echarts"],"title":"Echarts定制-塔形雷达图","uri":"/posts/echarts%E5%AE%9A%E5%88%B65-%E5%A1%94%E5%9E%8B%E9%9B%B7%E8%BE%BE%E5%9B%BE/"},{"categories":["Echarts"],"content":"Echarts定制-滑动条","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B64-%E6%BB%91%E5%8A%A8%E6%9D%A1/","tags":["Echarts"],"title":"Echarts定制-滑动条","uri":"/posts/echarts%E5%AE%9A%E5%88%B64-%E6%BB%91%E5%8A%A8%E6%9D%A1/"},{"categories":["Echarts"],"content":" //主要是配置dataZoom option = { backgroundColor: '#0A2E5D', tooltip: { trigger: \"axis\", axisPointer: { lineStyle: { color: \"#dddc6b\" } } }, legend: { top: \"10%\", textStyle: { color: \"rgba(255,255,255,.5)\", fontSize: \"12\" } }, grid: { left: \"50\", top: \"100\", right: \"50\", bottom: \"100\", containLabel: true }, xAxis: [{ type: \"category\", boundaryGap: false, axisLabel: { textStyle: { color: \"rgba(255,255,255,.6)\", fontSize: 12 } }, axisLine: { lineStyle: { color: \"rgba(255,255,255,.2)\" } }, data: [ \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\" ] }, { axisPointer: { show: false }, axisLine: { show: false }, position: \"bottom\", offset: 20 } ], yAxis: [{ type: \"value\", axisTick: { show: false }, axisLine: { lineStyle: { color: \"rgba(255,255,255,.1)\" } }, axisLabel: { textStyle: { color: \"rgba(255,255,255,.6)\", fontSize: 12 } }, splitLine: { lineStyle: { color: \"rgba(255,255,255,.1)\" } } }], //缩放组件 dataZoom: [ //滑动条 { show: true, height: 20, xAxisIndex: [0], //调整缩放组件位置 //top bottom left right bottom: 75, type: \"slider\", \"start\": 20, \"end\": 80, handleIcon: 'path://M306.1,413c0,2.2-1.8,4-4,4h-59.8c-2.2,0-4-1.8-4-4V200.8c0-2.2,1.8-4,4-4h59.8c2.2,0,4,1.8,4,4V413z', handleSize: '110%', handleStyle: { color: \"#5B3AAE\", }, textStyle: { color: \"rgba(204,187,225,0.5)\", }, fillerColor: \"rgba(67,55,160,0.4)\", borderColor: \"rgba(204,187,225,0.5)\", }, //内置于坐标系中，使用户可以在坐标系上 //通过鼠标拖拽、鼠标滚轮、手指滑动（触屏上）来缩放或漫游坐标系。 { type: \"inside\", show: true, height: 15, start: 1, end: 35 } ], series: [{ name: \"播放量\", type: \"line\", smooth: true, symbol: \"circle\", symbolSize: 5, showSymbol: false, lineStyle: { normal: { color: \"#0184d5\", width: 2 } }, areaStyle: { normal: { color: new echarts.graphic.LinearGradient( 0, 0, 0, 1, [{ offset: 0, color: \"rgba(1, 132, 213, 0.4)\" }, { offset: 0.8, color: \"rgba(1, 132, 213, 0.1)\" } ], false ), shadowColor: \"rgba(0, 0, 0, 0.1)\" } }, itemStyle: { normal: { color: \"#0184d5\", borderColor: \"rgba(221, 220, 107, .1)\", borderWidth: 12 } }, data: [ 30, 40, 30, 40, 30, 40, 30, 60, 20, 40, 20, 40, 30, 40, 30, 40, 30, 40, 30, 60, 20, 40, 20, 40, 30, 60, 20, 40, 20, 40 ] }, { name: \"转发量\", type: \"line\", smooth: true, symbol: \"circle\", symbolSize: 5, showSymbol: false, lineStyle: { normal: { color: \"#00d887\", width: 2 } }, areaStyle: { normal: { color: new echarts.graphic.LinearGradient( 0, 0, 0, 1, [{ offset: 0, color: \"rgba(0, 216, 135, 0.4)\" }, { offset: 0.8, color: \"rgba(0, 216, 135, 0.1)\" } ], false ), shadowColor: \"rgba(0, 0, 0, 0.1)\" } }, itemStyle: { normal: { color: \"#00d887\", borderColor: \"rgba(221, 220, 107, .1)\", borderWidth: 12 } }, data: [ 50, 30, 50, 60, 10, 50, 30, 50, 60, 40, 60, 40, 80, 30, 50, 60, 10, 50, 30, 70, 20, 50, 10, 40, 50, 30, 70, 20, 50, 10, 40 ] } ] }; ","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B64-%E6%BB%91%E5%8A%A8%E6%9D%A1/:0:0","tags":["Echarts"],"title":"Echarts定制-滑动条","uri":"/posts/echarts%E5%AE%9A%E5%88%B64-%E6%BB%91%E5%8A%A8%E6%9D%A1/"},{"categories":["Echarts"],"content":"Echarts定制-间断圆环","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B62-%E9%97%B4%E6%96%AD%E5%9C%86%E7%8E%AF/","tags":["Echarts"],"title":"Echarts定制-间断圆环","uri":"/posts/echarts%E5%AE%9A%E5%88%B62-%E9%97%B4%E6%96%AD%E5%9C%86%E7%8E%AF/"},{"categories":["Echarts"],"content":"Echarts定制- 间断圆环 ","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B62-%E9%97%B4%E6%96%AD%E5%9C%86%E7%8E%AF/:0:0","tags":["Echarts"],"title":"Echarts定制-间断圆环","uri":"/posts/echarts%E5%AE%9A%E5%88%B62-%E9%97%B4%E6%96%AD%E5%9C%86%E7%8E%AF/"},{"categories":["Echarts"],"content":"一、基础学习 B站有超详细的基础教学视频，这里我推荐 黑马程序员pink老师https://www.bilibili.com/video/BV1v7411R7mp 非常的详细，风格幽默 charts社区: https://www.makeapie.com/explore.html 这里有超多的炫酷效果 ","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B62-%E9%97%B4%E6%96%AD%E5%9C%86%E7%8E%AF/:1:0","tags":["Echarts"],"title":"Echarts定制-间断圆环","uri":"/posts/echarts%E5%AE%9A%E5%88%B62-%E9%97%B4%E6%96%AD%E5%9C%86%E7%8E%AF/"},{"categories":["Echarts"],"content":"二、间断圆环 //圆环的间断效果就是通过每个数据中间插一个值比较小的数据， //并且将这个数据的样式改为背景色，这样就实现了间断的效果 var data=[ {value: 178, name: '1-20岁', itemStyle:{ normal: { borderWidth: 5, shadowBlur: 20, borderColor:'#00ffff', shadowColor: '#00ffff' } } }, //实现间断的数据 {value: 50,//值根据自己需要的效果调大小 name: '', itemStyle: { normal: { label: { show: false }, labelLine: { show: false }, //设置间断的颜色样式 color: 'rgba(0, 0, 0, 0)', borderColor: 'rgba(0, 0, 0, 0)', borderWidth: 0 } } }, {value: 1335, name: '20-30岁', itemStyle:{ normal: { borderWidth: 5, shadowBlur: 20, borderColor:'#006ced', shadowColor: '#006ced' } } }, {value: 50, name: '', itemStyle: { normal: { label: { show: false }, labelLine: { show: false }, color: 'rgba(0, 0, 0, 0)', borderColor: 'rgba(0, 0, 0, 0)', borderWidth: 0 } } }, {value: 457, name: '30-40岁', itemStyle:{ normal: { borderWidth: 5, shadowBlur: 20, borderColor:'#ffa800', shadowColor: '#ffa800' } } }, {value: 50, name: '', itemStyle: { normal: { label: { show: false }, labelLine: { show: false }, color: 'rgba(0, 0, 0, 0)', borderColor: 'rgba(0, 0, 0, 0)', borderWidth: 0 } } }, {value: 567, name: '40岁以上', itemStyle:{ normal: { borderWidth: 5, shadowBlur: 20, borderColor:'#ff5b00', shadowColor: '#ff5b00' } } }, {value: 50, name: '', itemStyle: { normal: { label: { show: false }, labelLine: { show: false }, color: 'rgba(0, 0, 0, 0)', borderColor: 'rgba(0, 0, 0, 0)', borderWidth: 0 } } }, ]; option = { backgroundColor: '#0A2E5D', series: [ { name: '', type: 'pie', clockWise: false, radius: [55, 59],//设置圆环的内外半径 hoverAnimation: true, itemStyle: { normal: { label: { show: true, position: 'outside', color: '#ffffff', fontSize :8, //设置提示信息 formatter: function(params) { var percent = 0; var total = 0; for (var i = 0; i \u003c 8; i=i+2) { total += data[i].value; } percent = ((params.value / total) * 100).toFixed(0); if(params.name !== '') { return '年龄段：' + params.name + '\\n' + '\\n' + '占百分比：' + percent + '%'; }else { return ''; } }, }, labelLine: { length:10, length2:20, show: true, color:'#00ffff' } } }, data:data } ] }; ","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B62-%E9%97%B4%E6%96%AD%E5%9C%86%E7%8E%AF/:2:0","tags":["Echarts"],"title":"Echarts定制-间断圆环","uri":"/posts/echarts%E5%AE%9A%E5%88%B62-%E9%97%B4%E6%96%AD%E5%9C%86%E7%8E%AF/"},{"categories":["Echarts"],"content":"Echarts定制-立体圆柱","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B6-%E7%AB%8B%E4%BD%93%E5%9C%86%E6%9F%B1/","tags":["Echarts"],"title":"Echarts定制-立体圆柱","uri":"/posts/echarts%E5%AE%9A%E5%88%B6-%E7%AB%8B%E4%BD%93%E5%9C%86%E6%9F%B1/"},{"categories":["Echarts"],"content":"Echarts定制- 立体圆柱 ","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B6-%E7%AB%8B%E4%BD%93%E5%9C%86%E6%9F%B1/:0:0","tags":["Echarts"],"title":"Echarts定制-立体圆柱","uri":"/posts/echarts%E5%AE%9A%E5%88%B6-%E7%AB%8B%E4%BD%93%E5%9C%86%E6%9F%B1/"},{"categories":["Echarts"],"content":"一、基础学习 B站有超详细的基础教学视频，这里我推荐 黑马程序员pink老师[https://www.bilibili.com/video/BV1v7411R7mp] 非常的详细，风格幽默 charts社区[https://www.makeapie.com/explore.html] 这里有超多的炫酷效果 ","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B6-%E7%AB%8B%E4%BD%93%E5%9C%86%E6%9F%B1/:1:0","tags":["Echarts"],"title":"Echarts定制-立体圆柱","uri":"/posts/echarts%E5%AE%9A%E5%88%B6-%E7%AB%8B%E4%BD%93%E5%9C%86%E6%9F%B1/"},{"categories":["Echarts"],"content":"二、 立体圆柱 let data1 = ['游戏', '金融', '电商', '教育', '旅游']; let data2 = [120, 160, 150, 80, 70]; let barTopColor = [\"#02c3f1\", \"#ffe000\", \"#9a7fd1\", \"#06fdbc\", \"#006ced\"]; let barBottomColor = [\"rgba(2,195,241,0.1)\", \"rgba(83, 229, 104, 0.1)\", \"rgba(161, 84, 233, 0.1)\", \"rgba(83, 229, 104, 0.1)\", \"rgba(161, 84, 233, 0.1)\"]; option = { backgroundColor: '#0A2E5D', //设置网格布局，影响图形位置top bottom left right (上下左右) grid: { top: 10, left: 20, right: 10, bottom: 100, }, xAxis: { data: data1, axisTick: { show: false }, axisLine: { show: false }, axisLabel: { show: true, textStyle: { color: '#fff' }, margin: 18 }, }, yAxis: { type: 'value', splitLine: { show: false }, axisTick: { show: false }, axisLine: { show: false }, axisLabel: { show: false } }, series: [{ data: data2, name: '柱顶部', type: 'pictorialBar', //指定类型 //symbol标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 'diamond','pin','arrow', 'none' //默认为圆形 symbolSize: [16, 5], //指定大小，[宽,高] symbolOffset: [0, -3], //位置偏移 [右，下] 负数反方向 z: 12, itemStyle: { normal: { color: function(params) { return barTopColor[params.dataIndex]; } } }, label: { show: true, position: 'top', fontSize: 10 }, symbolPosition: 'end' }, { type: 'pictorialBar', symbolSize: [16, 5], symbolOffset: [0, 5], z: 12, itemStyle: { normal: { color: function(params) { return barTopColor[params.dataIndex]; } } }, data: data2 }, { name: '第一圈', type: 'pictorialBar', symbolSize: [20, 8], symbolOffset: [0, 11], z: 11, itemStyle: { normal: { //transparent是全透明黑色(black)的速记法，即一个类似rgba(0,0,0,0)这样的值。 //将整个圆颜色设置为全透明黑色相当于把圆隐藏，然后只留下边框，变成一个环 color: 'transparent', borderColor: '#3ACDC5', borderWidth: 2 } }, data: data2 }, { name: '第二圈', type: 'pictorialBar', symbolSize: [32, 16], symbolOffset: [0, 17], z: 10, itemStyle: { normal: { color: 'transparent', borderColor: barTopColor[0], borderWidth: 2 } }, data: data2 }, { type: 'bar', itemStyle: { normal: { color: function(params) { //使用echarts内置的渐变色生成器echarts.graphic.LinearGradient // //4个参数用于配置渐变色的起止位置, 这4个参数依次对应右/下/左/上四个方位. //而0 0 0 1则代表渐变色从正上方开始 return new echarts.graphic.LinearGradient( 0, 0, 0, 1, //数组, 用于配置颜色的渐变过程. 每一项为一个对象, //包含offset和color两个参数. offset的范围是0 ~ 1, 用于表示位置 [{ offset: 0, color: barTopColor[params.dataIndex] }, { offset: 1, color: barBottomColor[params.dataIndex] } ] ); }, opacity: 0.8 } }, z: 16, silent: true, barWidth: 16, barGap: '-100%', // Make series be overlap data: data2 } ] }; ","date":"2020/12/06","objectID":"/posts/echarts%E5%AE%9A%E5%88%B6-%E7%AB%8B%E4%BD%93%E5%9C%86%E6%9F%B1/:2:0","tags":["Echarts"],"title":"Echarts定制-立体圆柱","uri":"/posts/echarts%E5%AE%9A%E5%88%B6-%E7%AB%8B%E4%BD%93%E5%9C%86%E6%9F%B1/"},{"categories":["前端"],"content":"js怎么使用？接下来会详细说明","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"一、js的使用方法 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:0:0","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"1.1 内联式 通过script标签，写JavaScript代码,位置可以用放在head或者body内 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c!--script标签内，写JavaScript代码,位置可以用放在head\\body--\u003e \u003cscript\u003e alert(\"hello\"); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript\u003e console.log(\"hello\"); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:1:0","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"1.2 外联式 先在js文件里编写代码，然后在HTML script标签src 资源引用 tset_01.js alert(\"hello\"); console.log(\"hello\"); test_01.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c!--通过在src引用文件资源--\u003e \u003cscript src=\"tset_01.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 二、快速入门 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:0","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"2.1浏览控制台的使用 在浏览器打开开发者工具进行调试，具体使用方法 重点：可以设置断点和在console中直接输入变量来查看变量值 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:1","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"2.2js数据类型 ==number== js 不区分小数和整数 123 //整数 123.1 //浮点数 1.123e3 //科学计数法 -99 //负数 NaN //not a number Infinity //表示无限大 ==字符串== 'abc' \"我的\" ==布尔值== true false ==逻辑运算== \u0026\u0026 //与 || //或 ! //取反 ==比较运算符== == //等于（类型不一样，值一样也为真） === //等于（类型和值都相同为真） 坚持不要使用==比较 NaN===NaN: NaN与所有的数值都不相等，包括自己。只能通过isNaN()来判断这个数是否是NaN 浮点数问题： console.log((1/3)=== (1-2/3)) 尽量避免使用浮点数进行运算，存在精度问题！ ==null和undefined== null 空 undefined 未定义 ==数组== java数组是一组类型相同的对象，js不需要这样 var arr=[1,2,3,4,\"hello\",null,true]; new array(1,2,3,4,\"hello\",null,true); 取数组下标ined：如果越界了就会undefined ==对象== 每个属性之间使用逗号隔开，最后一个不要添加 var person={ name:\"张三\", age:12, tags:['js','python','c++'] } 取对象的值 person.name \u003e“张三” person.age \u003e12 ==变量== var 王者荣耀=倔强青铜； js没有限定变量类型 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:2","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"2.3、严格检查模式strict \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c!--'use strict';严格检查模式，预防JavaScript的随意性导致一些问题 必须要放在第一行 局部变量建议都使用 let 定义--\u003e \u003cscript \u003e 'use strict'; let i=1; \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 三、数据类型 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:3","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"3.1、字符串 正常字符串使用单引号或者双引号包起来 注意转义字符 \\' \\n 换行 \\t Tab空格 \\u4e2d Unicode字符 \\x41 Ascii字符 多行字符串编写 //tab键上面，esc下面，反引号 var msg=`hello world 你好 世界` 模板字符串 let name=\"zhangsan\" //用tab键上面，esc下面，反引号 console.log(`hello,${name}`) 字符串长度 console.log(str.length) 字符串的可变性，不可变 大小写转换 str.toUpperCase() str.toLowerCase() 查找字符下标 str.indexOf('t') 截取字符串 str.substring(1)//从第一个字符截取到最后一个字符 str.substring(1,3)//[1,3)包含第一个字符，不包含第三个字符 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:4","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"3.2、数组 array可以包含任意的数据类型 var arr=[1,2,3,\"hello\",true] 长度 arr.length 注意：给arr.length赋值，数组大小会发生变化，如果赋值过小，元素就会丢失 indexOf arr.indexOf(2) 字符串的“1”和数字1是不一样的 slice() arr.slice(1) //下标从0开始，截取下标为1开始的所有的元素 arr.slice(1,5)//截取下标为1开始到下标为5之前的所有元素，包头不包尾 截取数组的一部分，返回一个新数组，类似于String中的substring push() pop() arr.push('a','b') //压入到尾部 arr.pop()//弹出尾部的一个元素 unshift() shift() arr.unshift('a','b')//压入到头部 arr.shift()//弹出头部的一个元素 sort() arr.sort() //数组排序 reverse() arr.reverse()//元素反转 concat() arr.concat([1,2,3]) //数组拼接，返回一个新数组 注意：concat()并没有修改原数组，只是返回一个新的数组 join() arr.join(\"-\")//使用选定的字符串连接数组元素，返回拼接后的字符串 多维数组 arr=[[1,2],[2,4],['a','b']] 数组：存储数据（如何存，如何取） ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:5","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"3.3、对象类型 若干个键值对 //定义了person对象 var person{ name:\"张三\", age:12, sex:man } js中对象，{……}表示一个对象，键值对描述属性，多个属性之间逗号隔开。 js对象所有键都是字符串，值可以是任意对象。 对象赋值 person.name=\"李四\" 使用一个不存在的对象属性，不会报错！undefined person.emal=\"12345678\" 动态删减属性,通过delete删除对象的属性 delete person.name 动态的添加属性，直接对象.属性赋值 person.haha=\"haha\" 判断属性值是否在对象中，xx in xx name in person 判断一个属性是否是这个对象自身拥有的 person.hasOwnProperty('toString') ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:6","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"3.4、Map和Set var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]); m.get('Michael'); // 95，通过键获取对应的值 m.set('lisi',80) // 新增或修改键值对 m.delete('Tracy') // 删除键值对 map 类似于python的字典，通过键来获取相应的值，键只能用单引号包起来 let set = new Set([3,4,2,7,9，3]); //定义Set console.log(Array.from(set)); //输出set 所有元素 set.add(2); //添加元素 set.delete(3); //删除元素 console.log(set.has(3)); //判断set是否有这个元素 set是无序不重复的集合,new set()接收一个数组 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:7","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"3.5、iterator 遍历数组 var arr=[1,2,3,4,5,6] //num是下标 for(let num in arr){ console.log(arr[num]); } //num是arr的元素 for(let num of arr){ console.log(num); } 遍历map var map=new Map([['zhangsan',12],['lisi',23],['wangwu',56]]) for(let x of map){ console.log(x); } 遍历set var set=new Set([5,6,7]) for(let x of set){ console.log(x); } 四、流程控制 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:8","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"4.1、if判断 if(age\u003e12){ alert(\"haha\"); }else if(age\u003e2 \u0026\u0026 age\u003c10){ alert(\"smile\"); }else{ alert(\"cry\"); } ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:9","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"4.2、while循环 var age=3; while(age\u003c30){ age=age+1; } ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:10","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"4.3、for循环 for(let i=0;i\u003c100;i++){ console.log(i); } ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:11","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"4.4、forEach循环 var arr=[1,2,3,4,5,6] //需要放在函数中 arr.forEach(function(value){ console.log(value); }) ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:12","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"4.5、 for in 遍历 var arr=[1,2,3,4,5,6] //num是下标 for(var num in arr){ console.log(arr[num]); } //num是arr的元素 for(var num of arr){ console.log(num); } 五、函数 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:13","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"5.1、定义函数 定义方式一 function abs(x){ if(x\u003e=0){ return x; }else{ return -x; } } 执行到return代表函数结束，返回结果。如果没有执行return，函数执行完也会返回结果undfined 定义方式二 var abs=function(x){ if(x\u003e=0){ return x; }else{ return -x; } } function(x){……}这是一个匿名函数，可以把结果赋值给abs,通过abs就可以调用函数。 方式一和方式二是一样的！ ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:14","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"5.2、调用函数 abs(-10) //10 abs(10) //10 参数问题：Javascript可以传递任意个参数，也可以不传递参数。参数是否存在？参数是否符合要求？ var abs=function(x){ //如果参数不是数字就抛出异常 if(typeof(x)!=='number'){ throw 'Not a number'; } if(x\u003e=0){ return x; }else{ return -x; } } arguments 参数数组 arguments是一个关键字 var abs=function(x){ //通过arguments打印每一个参数 for(let i=0;i\u003carguments.length;i++){ console.log(arguments[i]); } if(x\u003e=0){ return x; }else{ return -x; } } 问题：arguments包含所有的参数，有时候需要使用多余的参数来进行附加操作，需要排除已有的参数。 rest ES6引入的新特性，获取除了已经定义的参数外的所有参数 //需要用...表示多余的多个参数 function concat(a,b,...rest){ console.log(rest) return a+b; } concat('a','b','c','d') ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:15","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"5.3、变量的作用域 在JavaScript中，var定义变量实际是有作用域的。 假设在函数体中，则在函数体外不可以使用 function a(){ var x=1; } x=x+2;//x is not defined 两个函数使用相同的变量名，不冲突 funtion a(){ var i=0; } function b(){ var i='a'; } 内部函数可以访问外部函数的成员，反之则不行 内部函数与外部函数变量同名时，根据就近原则，内部函数优先选内部定义的变量值 function a(){ var i=0; function b(){ var i='a'; console.log(i); } b(); console.log(i); } 提升变量的作用域 function a(){ var x=\"x\"+y; console.log(x); var y='y'; } 结果： x undfined 说明：js执行引擎，自动提升了y的声明，但是不会提升变量y的赋值,等于下面这个效果 function a(){ var y; var x=\"x\"+y; console.log(x); y='y'; } 规范：所有的变量定义都放在头部，便于代码维护； 全局变量 //全局变量 var i=0; function a(){ i=6; console.log(i); } function b(){ i='a'; console.log(i); } 可以在函数中引用修改全局变量 全局对象 window var x='xxx'; alert(x); alert(window.x);//默认所有的全局变量，都会自动绑定在window对象下； alert()这个函数本身也是一个window变量； var alert_old=window.alert; window.alert=function(){ //重写alert方法 } JavaScript实际上只有一个全局作用域，任何变量（函数也可以视为变量），假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，报错RefrenceError 规范 由于所有的全局变量都会绑定到window上，如果不同的js文件使用了相同的全家变量，发生冲突 如何减少冲突？ //定义唯一全局对象 var myData={} //定义全局变量 myData.name='zhangsan'; myData.x='a'; myData.add=function(a,b){ return a+b; } 用一个唯一全局对象来代替window对象来存储全局变量的功能，降低全局命名冲突的问题 局部作用域 let function a(){ for(var i=0;i\u003c10;i++){ console.log(i); } console.log(i+1);//问题？i出了作用域还可以使用 } ES6 let 关键字解决局部域冲突问题 function a(){ for(let i=0;i\u003c10;i++){ console.log(i); } console.log(i+1);//报错，出了i的作用域 } 建议使用let定义局部变量； 常量 const const PI=3.14; PI=3; 用全部大写字母命名的变量就是常量，不建议修改 ","date":"2020/12/01","objectID":"/posts/js%E5%AD%A6%E4%B9%A0/:2:16","tags":["前端","javascript"],"title":"js笔记","uri":"/posts/js%E5%AD%A6%E4%B9%A0/"}]