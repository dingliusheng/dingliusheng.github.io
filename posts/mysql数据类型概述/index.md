# mysql数据类型概述


<!--more-->


## 数据类型概述

mysql中有很多数据类型，包括整数、实数、字符串、时间、大文件存储。通过底层原理来看一下mysql数据类型的具体应用场景。

### 整数类型

#### 整数类型列表

| 数据类型     | 存储长度(byte) | 最小值                     | 最大值                    |
| ------------ | -------------- | -------------------------- | ------------------------- |
| TINYINT      | 1              | -128                       | 127                       |
| SMALLINT     | 2              | -32,768                    | 32,767                    |
| MEDIUMINT    | 3              | -8,388,608                 | 8,388,607                 |
| INT(INTEGER) | 4              | -2,147,483,648             | 2,147,483,647             |
| BIGINT       | 8              | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |

#### 整数的底层存储原理

整数的编码分为原码、反码和补码。计算机使用的是补码的存储方式。它们的定义如下：

**原码**：在数值前面增加了一位符号位(即最高位为符号位)，该位为0表示正数，该位为1表示负数，其余位表示数值的大小。

```java
以-100 为例子  100=64+32+4 用1个字节 8位二进制表示
二进制位对应的大小                 128 64 32 16   8  4  2  1
 100对应的二进制表示                0  1  1  0    0  1  0  0
 最高位是符号位 0表示正数 1表示负数  -100 的原码是 1110 0100
```

**反码**：正数的反码与其原码相同。负数的反码是对其原码逐位取反，但符号位除外。

```java
以-100 为例子  
-100 的原码是 1110 0100
-100 的反码是 1001 1011
```

**补码**：正数的补码与其原码相同，负数的补码就是对该负数的反码加1。

```java
以 -100为例子
-100 的反码是 1001 1011
-100 的补码是 1001 1100
```

计算机为什么使用补码作为存储方式呢？

 如果我们用原码来储存数据，那么 0 这个数字就会有两个数字来表示 =》 

```java
 原码+0  0000 0000
 原码-0  1000 0000 
```

 如果我们用反码来储存数据，那么 0 这个数字也会有两个数字来表示 =》 

```java
反码+0 0000 0000
反码-0 1111 1111
```

 这样的数据在计算机这样的精确软件中是不允许存在的，这样只有补码满足这个条件 

```java
补码+0 0000 0000
补码-0 0000 0000
```

 机器中只有加法，减法会变成补码的加法。 

1、补码加法运算：

```java
[x]补 + [y]补 = [x+y]补
```

2、补码减法运算：

```java
[x-y]补 = [x+(-y)]补 = [x]补 + [-y]补
```

下面从两个角度理解-128的补码为什么是1000 0000.

从补码的意义上去理解 

```java
因为：256-128=256+(-128) 的补码 
而    256-128=128 
所以  256+（-128）的补码=128 
所以      （-128）的补码=256-128 
                   =128 
数学上， 128的二进制表示为 1000 0000 
故规定-128的补码为 1000 0000 
```

注意：只是规定而已，下面还有原因

```java
8位二进制 的补码组合序列有256个
    
0000 0000 - 0111 1111   0 ~+127
1000 0000            用来干啥好呢？       
1000 0001 - 1111 1111   -127~-1  
```

再看看这个规律表

```java
 原码               补码             值
0111 1111        0111 1111        +127
0111 1110        0111 1110        +126

   ...            补码不断-1        ...

0000 0000        0000 0000          0
1000 0001        1111 1111         -1
1000 0010        1111 1110         -2
1000 0011        1111 1101         -3

   ...           补码不断-1          ...

1111 1111        1000 0001         -127
无法表达          1000 0000         -128   
```

于是就有了规定 1000 0000 定为 -128的补码

<span style="color: red;font-weight:bolder;">总结：整数在计算机都是补码形式存储的，以1个字节为例子，从 0~127 的正负两个值共255个数（0,+1,-1,+2,-2.....），因为0 没有正负的概念，就把剩余的一个补码  1000 000 规定为 -128 ，范围大小是-128~127</span>

### 实数类型

#### 实数类型列表

| 数据类型 | 存储长度(byte)             | 最小值        | 最大值        |
| -------- | -------------------------- | ------------- | ------------- |
| FLAOT    | 4                          | 10的38次方级  | 10的38次方级  |
| DOUBLE   | 8                          | 10的308次方级 | 10的308次方级 |
| DECIMAL  | 对decimal(M,D) ，依赖于M,D | 依赖于M,D     | 依赖于M,D     |





#### 浮点数的底层存储原理

<span style="color: green;font-weight:bolder;">float的表示原理：</span>首先我们知道常用科学计数法是将所有的数字转换成 <span style="color: green;font-weight:bolder;">$\pm{a.b*10^c}$</span>  的形式，其中a的范围是1到9共9个整数，b是小数点后的所有数字，c是10的指数。而计算机中存储的都是二进制数据，所以float存储的数字都要先转化<span style="color: green;font-weight:bolder;">$\pm{a.b*2^c}$</span>由于二进制中最大的数字就是1，所以表示法可以写成 的 <span style="color: green;font-weight:bolder;">$\pm{1.b*2^c}$</span>形式，float要想存储小数就只需要存储<span style="color: green;font-weight:bolder;">（$\pm$）、b 和 c </span>就可以了。

float的存储正是将4字节32位划分为了3部分来分别存储正负号，小数部分和指数部分的：

​	1、Sign（1位）：用来表示浮点数是正数还是负数，0表示正数，1表示负数。
​	2、Exponent（8位）：指数部分。即上文提到数字c，但是这里不是直接存储c，为了同时表示正负指数以及他们的大小顺序，这里实际范围是 -127~+127
​	3、Mantissa（23位）：尾数部分。也就是上文中提到的数字b

 比如8.25用二进制表示可表示为1000.01，转成指数的形式1.00001*2^3,在计算机中  
![在这里插入图片描述](https://img-blog.csdnimg.cn/536dd678cbf34f2fb13bc7d00c9d9c81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riF6aOO5ZKM5pyI5piO,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)


double和float 都是一样，double 是8个字节 64位二进制。

**DECIMAL类型简介**

DECIMAL从MySQL 5.1引入，列的声明语法是DECIMAL(M,D)。NUMERIC与DECIMAL同义，如果字段类型定义为NUMERIC，则将自动转成DECIMAL。

对于声明语法DECIMAL(M,D)，自变量的值范围如下：

- M是最大位数（精度），范围是1到65。可不指定，默认值是10。
- D是小数点右边的位数（小数位）。范围是0到30，并且不能大于M，可不指定，默认值是0。

例如字段 salary DECIMAL(5,2)，能够存储具有五位数字和两位小数的任何值，因此可以存储在salary列中的值的范围是从-999.99到999.99。

![在这里插入图片描述](https://img-blog.csdnimg.cn/cbd7fd7a99a74220b651d12d618c80d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5riF6aOO5ZKM5pyI5piO,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)


<span style="color: red;font-weight:bolder;">总结</span>

​    float单精度小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位

   double双精度小数部分能精确到小数点后的15位，加上小数点前的一位 有效位数为16位。

​    float 和doble 都是近似值，本身就无法保障数据就一定精准。 通常在设置小数的时候，都是用的decimal类型!! 

### 字符串类型

#### 字符串类型列表

| 数据类型   | 存储占用最大空间          |
| ---------- | ------------------------- |
| CHAR       | 255字符                   |
| VARCHAR    | 65535字节或者255字符      |
| TINYTEXT   | 255字节                   |
| TEXT       | 65,535字节  ( ~64kb）     |
| MEDIUMTEXT | 16,777,215字节 (~16MB)    |
| LONGTEXT   | 4,294,967,295字节（~4GB） |
| TINYBLOB   | 255字节                   |
| BLOB       | 65,535字节  ( ~64kb）     |
| MEDIUMBLOB | 16,777,215字节 (~16MB)    |

#### 相关拓展

**varchar 长度限制因素：**

a)  存储限制

​    varchar 字段是将实际内容单独存储在聚簇索引之外，内容开头用1到2个字节表示实际长度（长度超过255时需要2个字节），因此最大长度不能超过65535。 

b)  编码长度限制

​       字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766;

　　字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845。

　　使用GBK英文则每个字符占用2个字节，而使用UTF－8英文却只占一个字节。

　　**若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。** 

c)  行长度限制

　　MySQL要求一个行的定义长度不能超过65535。

**varchar 和char 比较：**

> **VARCHAR类型用于存储可变长字符串。**它比定长类型更节省空间，因为它仅使用必要的空间(例如，越短的字符串使用越少的空间)。有一种情况例外，如果MySQL表使用ROW_FORMAT=FIXED创建的话，每一行都会使用定长存储，这会很浪费空间。
>
> **VARCHAR需要使用1或2个额外字节记录字符串的长度**：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。假设采用latin1字符集，一个VARCHAR(10)的列需要11个字节的存储空间。VARCHAR(1000)的列则需要1002个字节，因为需要2个字节存储长度信息。
>
> **VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是变长的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。**如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，不同的存储引擎的处理方式是不一样的。例如，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。其他一些存储引擎也许从不在原数据位置更新数据。
>
> 下面这些情况下适用VARCHAR是合适的：
>
> - 字符串列的最大长度比平均长度大很多
> - 列的更新很少，所以碎片不是问题
> - 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储



>**CHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。**当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。
>
>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。例如，CHAR非常适合存储密码的MD5值，因为这是一个定长的值。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率。例如用CHAR(1)来存储只有Y和N的值，如果采用单字节字符集只需要一个字节，但是VARCHAR(1)却需要两个字节，因为还有一个记录长度的额外字节。

总结：

当我们为字符串类型的字段选取类型的时候，判断该选取VARCHAR还是CHAR，我们可以从以下几个方面来考虑：

- 该字段数据集的平均长度与最大长度是否相差很小，若相差很小优先考虑CHAR类型，反之，考虑VARCHAR类型。
- 若字段存储的是MD5后的哈希值，或一些定长的值，优先选取CHAR类型。
- 若字段经常需要更新，则优先考虑CHAR类型，由于CHAR类型为定长，因此不容易产生碎片。
- 对于字段值存储很小的信息，如性别等，优先选取CHAR类型，因为VARCHAR类型会占用额外的字节保存字符串长度信息。

总之一句话，当我们能够选取CHAR类型的时候，或者说空间消耗相对并不是影响因素的重点时，尽量选取CHAR类型，因为在其他方面，CHAR类型都有着或多或少的优势。而当空间消耗成为了很大的影响因素以后，我们则考虑使用VARCHAR类型。

 **BLOB 介绍**

 BLOB (binary large object)二进制大对象，是一个可以存储二进制文件的容器。在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。BLOB是一个大文件，典型的BLOB是一张图片或一个声音文件，由于它们的尺寸，必须使用特殊的方式来处理。 



### 时间类型

#### 时间类型列表

| 数据类型  | 存储长度(byte) | 最小值              | 最大值              |
| --------- | -------------- | ------------------- | ------------------- |
| YEAR      | 1              | 1001                | 9999                |
| TIME      | 3              | 00:00:00            | 23:59:59            |
| DATE      | 3              | 1001-01-01          | 9999-12-31          |
| DATETIME  | 8              | 1001-01-01 00:00:00 | 9999-12-31 23:59:59 |
| TIMESTAMP | 4              | 1970-01-01 00:00:00 |                     |



MySQL 中常见的时间类型有三种`DATE`, `DATETIME`和 `TIMESTAMP`，其中`DATE`类型用于表示日期，但是不会包含时间，格式为`YYYY-MM-DD`，而`DATETIME`和`TIMESTAMP`用于表示日期和时间，常见的格式为`YYYY-MM-DD HH:MM:SS`，也可以带6位小数来表示微秒。

不同于`DATETIME`，`TIMESTAMP`支持的时间范围从`1970-01-01 00:00:01.000000`到`2038-01-19 03:14:07.999999`，使用了`TIMESTAMP`的应用很有可能在`2038-01-19 03:14:07.999999`之后宕机，同样面临这个问题的还有所有的类`Unix`系统，因为他们使用了`time_t`这一32位数字来表示时间，这就是著名的**2038年问题**。

### 参考

[关于 -128 ，+128，-0，+0，-1 的反码补码](https://www.cnblogs.com/flowerslip/p/5933833.html)

[MySQL如何选择float, double, decimal](https://www.cnblogs.com/tusheng/articles/9389672.html)

[MySQL数据类型（decimal的存储大小）](https://blog.csdn.net/Mikeoperfect/article/details/78814824)

[MySQL中varchar和char类型的区别](https://www.jb51.net/article/229161.htm)

[MySQL中varchar最大长度是多少?](https://www.cnblogs.com/mo-beifeng/archive/2011/08/09/2133039.html)

[MySQL中“诡异”的TIMESTAMP数据类型](https://zhuanlan.zhihu.com/p/41982564)

[8.5. 日期/时间类型](http://www.postgres.cn/docs/12/datatype-datetime.html)

[MySQL 尽量避免使用 TIMESTAMP](https://zhuanlan.zhihu.com/p/426439142)

[Mysql varchar 最大长度是多少?](https://www.cnblogs.com/mo-beifeng/archive/2011/08/09/2133039.html)

[MySQL中“诡异”的TIMESTAMP数据类型](https://zhuanlan.zhihu.com/p/41982564)

[8.5. 日期/时间类型](http://www.postgres.cn/docs/12/datatype-datetime.html)

[MySQL 尽量避免使用 TIMESTAMP](https://zhuanlan.zhihu.com/p/426439142)


